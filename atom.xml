<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一帆磨砺</title>
  
  <subtitle>生活所迫，一叶孤舟</subtitle>
  <link href="http://janwarlen.com/atom.xml" rel="self"/>
  
  <link href="http://janwarlen.com/"/>
  <updated>2022-06-30T17:05:49.245Z</updated>
  <id>http://janwarlen.com/</id>
  
  <author>
    <name>Jan Warlen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一书一图-Java多线程编程核心技术</title>
    <link href="http://janwarlen.com/2022/06/30/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>http://janwarlen.com/2022/06/30/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</id>
    <published>2022-06-30T02:32:55.000Z</published>
    <updated>2022-06-30T17:05:49.245Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h4><ol><li>本书难度比较简单，属于实践类，难度不高建议跟随书中代码敲一遍，有兴趣的可以点到源码看一看</li><li>正版定价129，建议京东活动时买入，半价还是可以的</li><li>本书大量的代码案例都是简单的Api使用，原理与源码讲解较少，深入理解需要自己看源码或者搜索相关知识点的博文</li><li>推荐入手，整本书如果代码都跟着敲一遍，预计有10-20个小时的工作量</li><li>下方的思维导图可以用作知识点大纲，有感兴趣的知识点可以额外单独搜索或者阅读对应书中章节细节内容</li><li>多线程相关实践代码可以参考我的<a href="https://github.com/JanWarlen/JavaPractice/tree/master/Basic/src/main/java/com/janwarlen/learn/thread">练习代码</a><span id="more"></span></li></ol><p><img src="http://img.janwarlen.com/blog/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.png" alt="Java多线程编程核心技术"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;本书难度比较简单，属于实践类，难度不高建议跟随书中代码敲一遍，有兴趣的可以点到源码看一看&lt;/li&gt;
&lt;li&gt;正版定价129，建议京东活动时买入，半价还是可以的&lt;/li&gt;
&lt;li&gt;本书大量的代码案例都是简单的Api使用，原理与源码讲解较少，深入理解需要自己看源码或者搜索相关知识点的博文&lt;/li&gt;
&lt;li&gt;推荐入手，整本书如果代码都跟着敲一遍，预计有10-20个小时的工作量&lt;/li&gt;
&lt;li&gt;下方的思维导图可以用作知识点大纲，有感兴趣的知识点可以额外单独搜索或者阅读对应书中章节细节内容&lt;/li&gt;
&lt;li&gt;多线程相关实践代码可以参考我的&lt;a href=&quot;https://github.com/JanWarlen/JavaPractice/tree/master/Basic/src/main/java/com/janwarlen/learn/thread&quot;&gt;练习代码&lt;/a&gt;</summary>
    
    
    
    <category term="多线程" scheme="http://janwarlen.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="读书笔记" scheme="http://janwarlen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="多线程编程" scheme="http://janwarlen.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一书一图-Java高并发与集合框架</title>
    <link href="http://janwarlen.com/2022/06/26/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://janwarlen.com/2022/06/26/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-Java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2022-06-26T02:46:21.000Z</published>
    <updated>2022-06-26T14:34:10.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>书中主要内容是源码解读，因为是黑白印刷，阅读体验会有所影响</li><li>书中关于大顶堆&#x2F;小顶堆&#x2F;红黑树&#x2F;管程(Object Monitor&#x2F;AQS)建议单独拎出来阅读</li><li>并发部分对于没有足够编程经验的同学门槛会有一些高，建议同时搜索相关博文多方参考学习</li><li>因为是源码解读，建议读者先使用相关类做简单的编码demo，可以更容易理解解读内容（最好可以先自己阅读一遍源码）</li><li>因书中主要内容是源码解析，因此不建议作为系统化学习的教材使用，可以用作学习过程中的辅助教材</li><li>打折时推荐入手，原价不推荐</li><li>下方思维导图仅是个人的简单记录，可以用作知识点列表按图索骥的单独去学习，图中无任何具体知识内容<span id="more"></span></li></ol><p><img src="http://img.janwarlen.com/blog/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.png" alt="Java高并发与集合框架"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;书中主要内容是源码解读，因为是黑白印刷，阅读体验会有所影响&lt;/li&gt;
&lt;li&gt;书中关于大顶堆&amp;#x2F;小顶堆&amp;#x2F;红黑树&amp;#x2F;管程(Object Monitor&amp;#x2F;AQS)建议单独拎出来阅读&lt;/li&gt;
&lt;li&gt;并发部分对于没有足够编程经验的同学门槛会有一些高，建议同时搜索相关博文多方参考学习&lt;/li&gt;
&lt;li&gt;因为是源码解读，建议读者先使用相关类做简单的编码demo，可以更容易理解解读内容（最好可以先自己阅读一遍源码）&lt;/li&gt;
&lt;li&gt;因书中主要内容是源码解析，因此不建议作为系统化学习的教材使用，可以用作学习过程中的辅助教材&lt;/li&gt;
&lt;li&gt;打折时推荐入手，原价不推荐&lt;/li&gt;
&lt;li&gt;下方思维导图仅是个人的简单记录，可以用作知识点列表按图索骥的单独去学习，图中无任何具体知识内容</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="读书笔记" scheme="http://janwarlen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK18</title>
    <link href="http://janwarlen.com/2022/06/22/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK18/"/>
    <id>http://janwarlen.com/2022/06/22/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK18/</id>
    <published>2022-06-22T05:53:21.000Z</published>
    <updated>2022-06-22T05:54:27.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://openjdk.org/projects/jdk/18/">jdk18特性列表</a></li><li><a href="https://www.jdon.com/60407">迁移到JDK18为何写一个空的finalize()方法？</a></li><li><a href="https://www.oracle.com/java/technologies/javase/seccodeguide.html">Java-SE 安全编码指南</a></li><li><a href="https://www.hboehm.info/misc_slides/java_finalizers.pdf">Finalization对GC的影响</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>反射核心重新实现，从API的维护成本和性能都有所提升</li><li>互联网解析器可自定义</li><li><code>switch</code>针对<code>case</code>覆盖范围和<code>sealed</code>类的检测进行了加强</li><li><code>Finalization</code>标注弃用，因目前仍默认启用，因此迁移成本暂时无变化，后期该特性正式删除后，迁移的成本估计需要仔细评估。<span id="more"></span></li></ol><h1 id="默认字符集为UTF-8"><a href="#默认字符集为UTF-8" class="headerlink" title="默认字符集为UTF-8"></a>默认字符集为UTF-8</h1><p> Java API 默认字符集为UTF-8，除了console I&#x2F;O</p><h1 id="极简web服务器"><a href="#极简web服务器" class="headerlink" title="极简web服务器"></a>极简web服务器</h1><p> 从官方文档描述，功能基本与nginx重合。并且从<code>Motivation</code>中得知它的定位主要是校园内的教学场景。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="代码demo"><a href="#代码demo" class="headerlink" title="代码demo"></a>代码demo</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * snippet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeSnippets</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@snippet</span> :</span></span><br><span class="line"><span class="comment">     *  CodeSnippets.func(); // <span class="doctag">@highlight</span> substring=&quot;func&quot;</span></span><br><span class="line"><span class="comment">     *&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CodeSnippets&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@snippet</span> file=&quot;CodeSnippets.java&quot; region=&quot;test&quot;&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 打印内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CodeSnippets:func2:&quot;</span> + text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * for region test</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// @start region=&quot;test&quot;</span></span><br><span class="line">        CodeSnippets.func2(<span class="string">&quot;hihihi&quot;</span>); <span class="comment">// @replace regex=&#x27;&quot;.*&quot;&#x27; replacement=&quot;...&quot;</span></span><br><span class="line">        <span class="comment">// @end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="部分注释说明"><a href="#部分注释说明" class="headerlink" title="部分注释说明"></a>部分注释说明</h4><ul><li>@highlight substring&#x3D;”func”<br>是将当前行的注释java代码中的func高亮</li><li>&#x2F;&#x2F; @replace regex&#x3D;’”.*”‘ replacement&#x3D;”…”<br> 当前行在作为注释代码时，通过正则匹配，将“hihihi”替换为…</li></ul><h3 id="javadoc脚本"><a href="#javadoc脚本" class="headerlink" title="javadoc脚本"></a>javadoc脚本</h3> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -private -d .../Downloads/test --source-path &quot;.../JavaFeature/JDK18/src/main/java:.../JavaFeature/JDK18/src/main/resources&quot; &quot;.../JavaFeature/JDK18/src/main/java/module-info.java&quot; &quot;.../JavaFeature/JDK18/src/main/java/com/janwarlen/feature/CodeSnippets.java&quot; &quot;.../JavaFeature/JDK18/src/main/java/com/janwarlen/Demo.java&quot; --snippet-path &quot;.../JavaFeature/JDK18/src/main/java/com/janwarlen/feature/&quot;</span><br></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>–source-path 指明有哪些路径需要参与本次生成</li><li>–snippet-path 标注在使用@snippet 的file文件范围</li><li>-d doc生成文件存放目录，文件较多，建议单独创建空目录</li><li>-private 扫描所有文件</li></ul><h3 id="结果简单展示"><a href="#结果简单展示" class="headerlink" title="结果简单展示"></a>结果简单展示</h3><p><img src="http://img.janwarlen.com/blog/Java-snippet-res.png"></p><h1 id="使用Method-Handles重新实现反射核心内容"><a href="#使用Method-Handles重新实现反射核心内容" class="headerlink" title="使用Method Handles重新实现反射核心内容"></a>使用Method Handles重新实现反射核心内容</h1><p>Method Handles 作为反射的底层机制，重新实现了 java.lang.reflect.Method、Constructor、Field 组件，将大大降低反射 API 的维护和开发成本。</p><blockquote><p>This benefits Project Loom by reducing the use of native stack frames.</p></blockquote><h1 id="Vector-API-第三次孵化"><a href="#Vector-API-第三次孵化" class="headerlink" title="Vector API (第三次孵化)"></a>Vector API (第三次孵化)</h1><p>变动内容：</p><ul><li>支持ARM 标量矢量扩展 (SVE) 平台。</li><li>在支持硬件掩码的架构上提高接受掩码的向量操作的性能。</li></ul><h1 id="互联网地址解析-SPI"><a href="#互联网地址解析-SPI" class="headerlink" title="互联网地址解析 SPI"></a>互联网地址解析 SPI</h1><p>为主机名和地址解析定义服务提供者接口 (SPI)，以便java.net.InetAddress可以使用平台内置解析器以外的解析器。<br>在尝试自定义解析器的过程中发现一个难以解决的问题，<code>InetAddress</code>是通过<code>ServiceLoader.load(InetAddressResolverProvider.class)</code>去找所有实现的解析器，但是用户自定义的解析器所在的<code>module</code>不在<code>java.base</code>的<code>requires</code>&#x2F;<code>uses</code>中，根据模块化的隔离，此时<code>java.base</code>是看不到自定义实现的解析器的。。。<br>原因在于如果类在声明了module的工程中，就跳过不load了。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.ServiceLoader.LazyClassPathLookupIterator#hasNextService</span><br><span class="line">                    <span class="title function_">if</span> <span class="params">(clazz.getModule()</span>.isNamed()) &#123;</span><br><span class="line">                        <span class="comment">// ignore class if in named module</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>当我删除<code>module-info.java</code>后，自定义的解析器就可以被识别了。</p><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.net.spi.InetAddressResolver;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressResolver</span> <span class="keyword">implements</span> <span class="title class_">InetAddressResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Stream&lt;InetAddress&gt; <span class="title function_">lookupByName</span><span class="params">(String host, LookupPolicy lookupPolicy)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">// 自定义根据hostname生成InetAddress流</span></span><br><span class="line">        <span class="comment">// 可查找DNS 或者本地的 /etc/hosts</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AddressResolver:lookupByName&quot;</span>);</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> Inet4Address.getLoopbackAddress();</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(<span class="keyword">new</span> <span class="title class_">InetAddress</span>[]&#123;localHost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lookupByAddress</span><span class="params">(<span class="type">byte</span>[] addr)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">// 根据ip找hostname</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AddressResolver:lookupByAddress&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.spi.InetAddressResolver;</span><br><span class="line"><span class="keyword">import</span> java.net.spi.InetAddressResolverProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResolverProvider</span>  <span class="keyword">extends</span> <span class="title class_">InetAddressResolverProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader load class:ResolverProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InetAddressResolver <span class="title function_">get</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AddressResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;自定义&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单调用代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ids</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classLoader load class:ResolverProvider</span><br><span class="line">AddressResolver:lookupByName</span><br><span class="line">WARNING: Unknown <span class="keyword">module</span>: JDK18 specified to --add-<span class="keyword">exports</span></span><br></pre></td></tr></table></figure><h1 id="调用本地方法和操作堆外内存（第二次孵化）"><a href="#调用本地方法和操作堆外内存（第二次孵化）" class="headerlink" title="调用本地方法和操作堆外内存（第二次孵化）"></a>调用本地方法和操作堆外内存（第二次孵化）</h1><p>本次变更内容：</p><ul><li>内存访问var句柄中支持更多的载体，如booleanand MemoryAddress；</li><li>一个更通用的解引用 API，在MemorySegment和MemoryAddress接口中都可用；</li><li>一个更简单的 API 来获取下调用方法句柄，MethodType不再需要传递参数；</li><li>一个更简单的 API 来管理资源范围之间的时间依赖关系；和</li><li>用于将 Java 数组复制到内存段和从内存段复制的新 API。</li></ul><p>挖个坑，后续补上代码demo；</p><h1 id="switch匹配模式增强（第二次预调整）"><a href="#switch匹配模式增强（第二次预调整）" class="headerlink" title="switch匹配模式增强（第二次预调整）"></a>switch匹配模式增强（第二次预调整）</h1><p>变更内容：</p><ul><li>同类型的case必须所有case都有类型声明(我的理解应该产生了偏差)，在该案例中，<code>CharSequence</code>的覆盖范围比<code>String</code>大，因此此处就是有问题的。该变动应该是增强了case之间的条件覆盖范围检查。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(o) &#123;</span><br><span class="line">        <span class="keyword">case</span> CharSequence cs -&gt;</span><br><span class="line">            System.out.println(<span class="string">&quot;A sequence of length &quot;</span> + cs.length());</span><br><span class="line">        <span class="keyword">case</span> String s -&gt;    <span class="comment">// Error - pattern is dominated by previous pattern</span></span><br><span class="line">            System.out.println(<span class="string">&quot;A string: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对<code>sealed</code>进行了拓展支持，当case中出现<code>sealed</code>相关的类时，会检测其他类是否都已覆盖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">S</span> permits A, B, C &#123;&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">S</span> &#123;&#125;</span><br><span class="line"><span class="keyword">record</span> <span class="title class_">C</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">implements</span> <span class="title class_">S</span> &#123;&#125;  <span class="comment">// Implicitly final</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testSealedExhaustive</span><span class="params">(S s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">        <span class="keyword">case</span> A a -&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> B b -&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> C c -&gt; <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">I</span>&lt;T&gt; permits A, B &#123;&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;X&gt; <span class="keyword">implements</span> <span class="title class_">I</span>&lt;String&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">B</span>&lt;Y&gt; <span class="keyword">implements</span> <span class="title class_">I</span>&lt;Y&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testGenericSealedExhaustive</span><span class="params">(I&lt;Integer&gt; i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="comment">// Exhaustive as no A case possible!  </span></span><br><span class="line">        <span class="keyword">case</span> B&lt;Integer&gt; bi -&gt; <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="弃用-Finalization"><a href="#弃用-Finalization" class="headerlink" title="弃用 Finalization"></a>弃用 Finalization</h1><p>可以先查看<a href="https://www.jdon.com/60407">迁移到JDK18为何写一个空的finalize()方法？</a><br>官方文档共4个角度决定放弃</p><ul><li>安全漏洞（资源泄漏可通过<code>try-with-resources</code> 和<code>Cleaners</code>方式避免）</li><li>性能</li><li>不可靠的执行</li><li>困难的编程模型（编码成本较高）</li></ul><p>目前仍默认启用，可通过<code>--finalization=disabled</code>禁用</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/projects/jdk/18/&quot;&gt;jdk18特性列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jdon.com/60407&quot;&gt;迁移到JDK18为何写一个空的finalize()方法？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/java/technologies/javase/seccodeguide.html&quot;&gt;Java-SE 安全编码指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hboehm.info/misc_slides/java_finalizers.pdf&quot;&gt;Finalization对GC的影响&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;反射核心重新实现，从API的维护成本和性能都有所提升&lt;/li&gt;
&lt;li&gt;互联网解析器可自定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;switch&lt;/code&gt;针对&lt;code&gt;case&lt;/code&gt;覆盖范围和&lt;code&gt;sealed&lt;/code&gt;类的检测进行了加强&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Finalization&lt;/code&gt;标注弃用，因目前仍默认启用，因此迁移成本暂时无变化，后期该特性正式删除后，迁移的成本估计需要仔细评估。</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK18" scheme="http://janwarlen.com/tags/JDK18/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK17</title>
    <link href="http://janwarlen.com/2022/06/22/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK17/"/>
    <id>http://janwarlen.com/2022/06/22/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK17/</id>
    <published>2022-06-21T21:23:33.000Z</published>
    <updated>2022-06-21T21:24:17.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://openjdk.org/projects/jdk/17/">jdk17特性列表</a></li><li><a href="https://segmentfault.com/a/1190000041252650">Java 随机数相关 API 的演进与思考（上）</a></li><li><a href="https://segmentfault.com/a/1190000041262013">Java 随机数相关 API 的演进与思考（下）</a></li><li><a href="https://cloud.tencent.com/developer/article/1890732">支持上下文的序列化过滤器，又一次给序列化打补丁</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>浮点数计算将跨系统平台结果统一，不过float这个坑已经几乎所有人都知道，这个改动即便知道大部分也会遵循之前的安全习惯</li><li>switch的匹配模式增强虽然还没开放，但可以直观的看出对简化代码的帮助很大</li><li>密封类<code>sealed</code>将会让多态环境更好控制，避免代码的无序扩张</li><li>反序列化过滤器没有想到使用场景，但是从介绍到demo可以直观的感受到它的重要性，一个是安全性，一个是反序列化过程的可控性</li><li>调用本地方法和操作堆外内存是非常重要的点，只是平时接触和使用的机会太少，这个特性未来能够正式使用一定能绽放精彩<span id="more"></span></li></ol><h1 id="float跨平台值统一"><a href="#float跨平台值统一" class="headerlink" title="float跨平台值统一"></a>float跨平台值统一</h1><p>使浮点运算始终保持严格。所有的浮点数计算都遵循<code>strictfp</code><br>该特性令我比较疑惑。疑惑的点是这个遵循的是所有系统平台执行的结果一致还是没有了数据波动。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrictFloat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1231231f</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.23456d</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">strictfp</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1231231f</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.23456d</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JDK8 中执行结果</span></span><br><span class="line"><span class="comment">// 0.3576831018900871</span></span><br><span class="line"><span class="comment">// 0.3576831018900871</span></span><br><span class="line"><span class="comment">// JDK17 执行 func 结果</span></span><br><span class="line"><span class="comment">// 0.3576831018900871</span></span><br></pre></td></tr></table></figure><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>按照个人理解的<code>strictfp</code>，执行结果应该是 <code>0.3576831</code>。<br>但是依然有不稳定的波动值存在，因此只能理解为跨平台系统的执行结果统一了。。。。<br>上方案例代码在JDK8反编译汇编后，两个函数指令集一样，只有函数2有<code>strictfp</code>修饰符一个区别</p><h2 id="JDK17不需要使用strictfp"><a href="#JDK17不需要使用strictfp" class="headerlink" title="JDK17不需要使用strictfp"></a>JDK17不需要使用<code>strictfp</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    Modifier &#x27;strictfp&#x27; is redundant on Java 17 and later</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">strictfp</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1231231f</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.23456d</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="增强PRNG（伪随机数生成器）"><a href="#增强PRNG（伪随机数生成器）" class="headerlink" title="增强PRNG（伪随机数生成器）"></a>增强PRNG（伪随机数生成器）</h1><p>提供新的接口类型和实现，包括可跳转 PRNG 和另一类可拆分 PRNG 算法 (LXM)。<br>具体详细内容和关于随机数的可以浏览博文<a href="https://segmentfault.com/a/1190000041252650">Java 随机数相关 API 的演进与思考（上）</a>&#x2F;<a href="https://segmentfault.com/a/1190000041262013">Java 随机数相关 API 的演进与思考（下）</a>，博主写的非常详尽</p><h1 id="macOS新的渲染管道"><a href="#macOS新的渲染管道" class="headerlink" title="macOS新的渲染管道"></a>macOS新的渲染管道</h1><p>使用 Apple Metal API 为 macOS 实现 Java 2D 内部渲染管道，以替代使用已弃用的 Apple OpenGL API 的现有管道。</p><h1 id="系统平台架构兼容：-macOS-x2F-AArch64"><a href="#系统平台架构兼容：-macOS-x2F-AArch64" class="headerlink" title="系统平台架构兼容： macOS&#x2F;AArch64"></a>系统平台架构兼容： macOS&#x2F;AArch64</h1><h1 id="弃用-Applet-API"><a href="#弃用-Applet-API" class="headerlink" title="弃用 Applet API"></a>弃用 Applet API</h1><blockquote><p>It is essentially irrelevant since all web-browser vendors have either removed support for Java browser plug-ins or announced plans to do so.</p></blockquote><p>市面主流浏览器已经不再支持Java的浏览器插件，这个API已经没有作用了。</p><h1 id="JDK内部代码继续加强-强封装"><a href="#JDK内部代码继续加强-强封装" class="headerlink" title="JDK内部代码继续加强 强封装"></a>JDK内部代码继续加强 强封装</h1><p>除了部分<a href="https://openjdk.org/jeps/260#Description">关键代码</a>，对其他所有JDK内部的Java类内部元素进行强封装，以提高JDK的安全性和可维护性。</p><h1 id="switch模式匹配增强（预调整）"><a href="#switch模式匹配增强（预调整）" class="headerlink" title="switch模式匹配增强（预调整）"></a>switch模式匹配增强（预调整）</h1><p>因还未开放使用，因此使用官方文档案例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">formatterPatternSwitch</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">null</span>      -&gt; System.out.println(<span class="string">&quot;Oops&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">        <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">        <span class="keyword">case</span> String s &amp;&amp; (s.length() &gt; <span class="number">100</span>)  -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">default</span>        -&gt; o.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可跨类型匹配，带匹配对象无类型限制（从文档看起来是这样）</li><li>可匹配null</li><li>可在匹配条件添加判断条件</li></ul><h1 id="删除-RMI-Activation"><a href="#删除-RMI-Activation" class="headerlink" title="删除 RMI Activation"></a>删除 RMI Activation</h1><p> JDK15标注弃用，JDK17删除。<br>删除远程方法调用 (RMI) 激活机制，同时保留 RMI 的其余部分。</p><h1 id="密封类-开放使用"><a href="#密封类-开放使用" class="headerlink" title="密封类-开放使用"></a>密封类-开放使用</h1><p> 与JDK16相比，JDK17没有新增变更。</p><ul><li><code>sealed</code>修饰的类必须有子类</li><li><code>non-sealed</code>修饰的子类被其他类继承不受限制</li><li><code>sealed</code>修饰的类的子类在不同包时，所有类必须在同一个模块下（同一个<code>module-info.java</code>）</li></ul><h1 id="删除实验性-AOT-和-JIT-编译器"><a href="#删除实验性-AOT-和-JIT-编译器" class="headerlink" title="删除实验性 AOT 和 JIT 编译器"></a>删除实验性 AOT 和 JIT 编译器</h1><p>官方发现没啥人用，就给删了。（维护工作量大）<br>保留了实验性的JVMCI。</p><h1 id="弃用安全管理器（Security-Manager）"><a href="#弃用安全管理器（Security-Manager）" class="headerlink" title="弃用安全管理器（Security Manager）"></a>弃用安全管理器（Security Manager）</h1><p>根据官方文档的说法，安全管理器使用率较低，有一部分框架甚至避开JDK内置策略实现自定义安全管理器。加上官方认定的性能不佳&#x2F;权限模型脆弱&#x2F;编码困难，因此决定弃用。<br>但是没有提到替代方案，只是在未来工作列表中表示会在多个方面增强安全性。</p><h1 id="本地方法调用和操作堆外内存-API（孵化器）"><a href="#本地方法调用和操作堆外内存-API（孵化器）" class="headerlink" title="本地方法调用和操作堆外内存 API（孵化器）"></a>本地方法调用和操作堆外内存 API（孵化器）</h1><p>JDK14&#x2F;15&#x2F;16已经进行过孵化，这次是在之前基础之上的演变。<br>官方文档没说和之前相比的变动内容，挖个坑，等以后填。。。。。</p><h1 id="Vector-API（第二次孵化器）"><a href="#Vector-API（第二次孵化器）" class="headerlink" title="Vector API（第二次孵化器）"></a>Vector API（第二次孵化器）</h1><ul><li>增强 API 以支持字符操作，例如 UTF-8 字符解码。short具体来说，我们添加了用于在向量和数组之间复制字符的方法char，以及用于与整数向量进行无符号比较的新向量比较运算符。</li><li>byte用于将向量转换为数组和从boolean 数组转换为 API 的增强功能。</li><li>使用英特尔的短向量数学库 (SVML)对 x64 上的超越和三角通道运算的内在支持。</li><li>对 Intel x64 和 ARM NEON 实施的一般性能增强。</li></ul><h1 id="特定于上下文的反序列化过滤器"><a href="#特定于上下文的反序列化过滤器" class="headerlink" title="特定于上下文的反序列化过滤器"></a>特定于上下文的反序列化过滤器</h1><p>结合官方文档和<a href="https://cloud.tencent.com/developer/article/1890732">支持上下文的序列化过滤器，又一次给序列化打补丁</a>大致明白了这个是干啥的。<br>简单的总结就是在所有使用<code>ObjectInputStream</code>的时候，都会经过反序列化过滤器，如果不符合所有过滤器，则无法反序列化。</p><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializationFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以先不执行该方法正常序列化/反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 该过滤器将只允许java.base路径的类反序列化，其他所有反序列化操作均拒绝</span></span><br><span class="line">        <span class="type">ObjectInputFilter</span> <span class="variable">filter</span> <span class="operator">=</span> ObjectInputFilter.Config.createFilter(<span class="string">&quot;java.base/*;!*&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputFilter</span> <span class="variable">serialFilter</span> <span class="operator">=</span> ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">        ObjectInputFilter.Config.setSerialFilter(filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serial</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">            objectOutputStream.writeObject(obj);</span><br><span class="line">            objectOutputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deserial</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Shape s) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;deserial:&quot;</span>);</span><br><span class="line">                s.func();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不设置过滤器"><a href="#不设置过滤器" class="headerlink" title="不设置过滤器"></a>不设置过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// DeserializationFilter.func();</span></span><br><span class="line">    DeserializationFilter.serial(cirle);</span><br><span class="line">    DeserializationFilter.deserial();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序列化正常</span></span><br><span class="line"><span class="comment">// deserial:</span></span><br><span class="line"><span class="comment">// com.janwarlen.feature.Circle</span></span><br></pre></td></tr></table></figure><h3 id="设置过滤器"><a href="#设置过滤器" class="headerlink" title="设置过滤器"></a>设置过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    DeserializationFilter.func();</span><br><span class="line">    DeserializationFilter.serial(cirle);</span><br><span class="line">    DeserializationFilter.deserial();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序列化失败</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.RuntimeException: java.io.InvalidClassException: filter status: REJECTED</span><br><span class="line">at JDK17/com.janwarlen.feature.DeserializationFilter.deserial(DeserializationFilter.java:<span class="number">38</span>)</span><br><span class="line">at JDK17/com.janwarlen.Demo.main(Demo.java:<span class="number">26</span>)</span><br><span class="line">Caused by: java.io.InvalidClassException: filter status: REJECTED</span><br><span class="line">at java.base/java.io.ObjectInputStream.filterCheck(ObjectInputStream.java:<span class="number">1414</span>)</span><br><span class="line">at java.base/java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">2055</span>)</span><br><span class="line">at java.base/java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1909</span>)</span><br><span class="line">at java.base/java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2235</span>)</span><br><span class="line">at java.base/java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1744</span>)</span><br><span class="line">at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">514</span>)</span><br><span class="line">at java.base/java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">472</span>)</span><br><span class="line">at JDK17/com.janwarlen.feature.DeserializationFilter.deserial(DeserializationFilter.java:<span class="number">32</span>)</span><br><span class="line">... <span class="number">1</span> more</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/projects/jdk/17/&quot;&gt;jdk17特性列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000041252650&quot;&gt;Java 随机数相关 API 的演进与思考（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000041262013&quot;&gt;Java 随机数相关 API 的演进与思考（下）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1890732&quot;&gt;支持上下文的序列化过滤器，又一次给序列化打补丁&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;浮点数计算将跨系统平台结果统一，不过float这个坑已经几乎所有人都知道，这个改动即便知道大部分也会遵循之前的安全习惯&lt;/li&gt;
&lt;li&gt;switch的匹配模式增强虽然还没开放，但可以直观的看出对简化代码的帮助很大&lt;/li&gt;
&lt;li&gt;密封类&lt;code&gt;sealed&lt;/code&gt;将会让多态环境更好控制，避免代码的无序扩张&lt;/li&gt;
&lt;li&gt;反序列化过滤器没有想到使用场景，但是从介绍到demo可以直观的感受到它的重要性，一个是安全性，一个是反序列化过程的可控性&lt;/li&gt;
&lt;li&gt;调用本地方法和操作堆外内存是非常重要的点，只是平时接触和使用的机会太少，这个特性未来能够正式使用一定能绽放精彩</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK17" scheme="http://janwarlen.com/tags/JDK17/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK16</title>
    <link href="http://janwarlen.com/2022/06/21/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK16/"/>
    <id>http://janwarlen.com/2022/06/21/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK16/</id>
    <published>2022-06-21T08:12:33.000Z</published>
    <updated>2022-06-21T15:50:12.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://openjdk.org/projects/jdk/16/">jdk16特性列表</a></li><li><a href="https://cr.openjdk.java.net/~stuefe/JEP-Improve-Metaspace-Allocator/review-guide/review-guide-1.0.html">JEP-Improve-Metaspace-Allocator</a></li><li><a href="https://my.oschina.net/benhaile/blog/214159">元空间（MetaSpace）一种新的内存空间诞生</a></li><li><a href="https://cloud.tencent.com/developer/article/1933656">Java 16 中对于 Project Valhalla 的铺垫</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li><code>record</code>的开放使用对于一些简单的数据建模场景非常友好，能简化很多重复的编码工作</li><li><code>instanceof</code>正式放出，可以简化代码，提高代码可读性<span id="more"></span></li></ol><h1 id="矢量API"><a href="#矢量API" class="headerlink" title="矢量API"></a>矢量API</h1><p>经历了一顿能干三顿饭的四年，已经不知道矢量计算的相关公示和理论了。有需求的可以看官方给出的案例简单了解下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scalarComputation</span><span class="params">(<span class="type">float</span>[] a, <span class="type">float</span>[] b, <span class="type">float</span>[] c)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        c[i] = (a[i] * a[i] + b[i] * b[i]) * -<span class="number">1.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等效于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> VectorSpecies&lt;Float&gt; SPECIES = FloatVector.SPECIES_256;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">vectorComputation</span><span class="params">(<span class="type">float</span>[] a, <span class="type">float</span>[] b, <span class="type">float</span>[] c)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i += SPECIES.length()) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">m</span> <span class="operator">=</span> SPECIES.indexInRange(i, a.length);</span><br><span class="line"><span class="comment">// FloatVector va, vb, vc;</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">va</span> <span class="operator">=</span> FloatVector.fromArray(SPECIES, a, i, m);</span><br><span class="line">        <span class="type">var</span> <span class="variable">vb</span> <span class="operator">=</span> FloatVector.fromArray(SPECIES, b, i, m);</span><br><span class="line">        <span class="type">var</span> <span class="variable">vc</span> <span class="operator">=</span> va.mul(va).</span><br><span class="line">                    add(vb.mul(vb)).</span><br><span class="line">                    neg();</span><br><span class="line">        vc.intoArray(c, i, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可使用-C-14"><a href="#可使用-C-14" class="headerlink" title="可使用 C++14"></a>可使用 C++14</h1><p>Java有相当一部分代码底层实现是通过调用本地C++库实现，并且也支持开发人员自定义C++本地实现调用，本次版本是升级了C++的支持范围。</p><h1 id="JDK-源码迁移至git"><a href="#JDK-源码迁移至git" class="headerlink" title="JDK 源码迁移至git"></a>JDK 源码迁移至git</h1><p><a href="https://github.com/openjdk/">https://github.com/openjdk/</a></p><h1 id="ZGC增强：并发线程堆栈处理"><a href="#ZGC增强：并发线程堆栈处理" class="headerlink" title="ZGC增强：并发线程堆栈处理"></a>ZGC增强：并发线程堆栈处理</h1><p>将 ZGC 线程堆栈处理从安全点移至并发阶段。减少ZGC在safepoint上的暂停时间，官方文档说是基本控制在1ms内。</p><h1 id="Unix-Domain-Socket-Channels"><a href="#Unix-Domain-Socket-Channels" class="headerlink" title="Unix-Domain Socket Channels"></a>Unix-Domain Socket Channels</h1><p>对于本地、进程间通信，Unix 域套接字比 TCP&#x2F;IP 环回连接更安全、更高效。</p><ul><li>Unix 域套接字严格用于同一系统上的进程之间的通信。不打算接受远程连接的应用程序可以通过使用 Unix 域套接字来提高安全性。</li><li>Unix 域套接字进一步受到操作系统强制、基于文件系统的访问控制的保护。</li><li>与 TCP&#x2F;IP 环回连接相比，Unix 域套接字具有更快的设置时间和更高的数据吞吐量。</li><li>对于需要在同一系统上的容器之间进行通信的容器环境，Unix 域套接字可能是比 TCP&#x2F;IP 套接字更好的解决方案。这可以使用位于共享卷中的套接字来实现。<br>Unix 域套接字长期以来一直是大多数 Unix 平台的一项功能，现在在 Windows 10 和 Windows Server 2019 中得到支持</li></ul><h1 id="兼容新系统：Alpine-Linux"><a href="#兼容新系统：Alpine-Linux" class="headerlink" title="兼容新系统：Alpine Linux"></a>兼容新系统：Alpine Linux</h1><p>以及其他使用 musl 作为主要 C 库的 Linux 发行版，机器是x64和AArch64架构的</p><h1 id="弹性元空间"><a href="#弹性元空间" class="headerlink" title="弹性元空间"></a>弹性元空间</h1><p>更及时地将未使用的 HotSpot 类元数据（即元空间）内存返回给操作系统，减少元空间占用，并简化元空间代码以降低维护成本。<br><code>-XX:MetaspaceReclaimPolicy=(balanced|aggressive|none)</code></p><ul><li>balanced：大多数应用程序应该看到元空间内存占用有所改善，而内存回收的负面影响应该是微不足道的。此模式是默认模式，旨在向后兼容。</li><li>‘aggressive’：以增加虚拟内存碎片为代价提供更高的内存回收率。</li><li>‘none’：完全禁用内存回收。<br>新算法说明文档：<a href="https://cr.openjdk.java.net/~stuefe/JEP-Improve-Metaspace-Allocator/review-guide/review-guide-1.0.html">https://cr.openjdk.java.net/~stuefe/JEP-Improve-Metaspace-Allocator/review-guide/review-guide-1.0.html</a></li></ul><h1 id="兼容Windows-x2F-AArch64"><a href="#兼容Windows-x2F-AArch64" class="headerlink" title="兼容Windows&#x2F;AArch64"></a>兼容Windows&#x2F;AArch64</h1><p>AArch64架构的兼容越来越多了，这次针对Windows的兼容应该是针对桌面软件领域。</p><h1 id="开放新API调用本地代码"><a href="#开放新API调用本地代码" class="headerlink" title="开放新API调用本地代码"></a>开放新API调用本地代码</h1><p>还在孵化阶段，目标应该是替换JNI，提供一种更高校更安全的调用本地方法的方式。</p><h1 id="针对值类型的告警信息"><a href="#针对值类型的告警信息" class="headerlink" title="针对值类型的告警信息"></a>针对值类型的告警信息</h1><p>可以先浏览<a href="https://cloud.tencent.com/developer/article/1933656">Java 16 中对于 Project Valhalla 的铺垫</a>，这篇文章对于值类型讲解和demo展示比较到位。</p><h1 id="新的打包工具（正式开放使用）"><a href="#新的打包工具（正式开放使用）" class="headerlink" title="新的打包工具（正式开放使用）"></a>新的打包工具（正式开放使用）</h1><p>JDK14开始孵化的打包工具，用以给各个系统打包各自平台的应用包：exe&#x2F;pkg&#x2F;dmg&#x2F;deb&#x2F;rpm</p><h1 id="外部内存访问-API（第三次孵化）"><a href="#外部内存访问-API（第三次孵化）" class="headerlink" title="外部内存访问 API（第三次孵化）"></a>外部内存访问 API（第三次孵化）</h1><ul><li><code>MemorySegment</code> 和 <code>MemoryAddress</code>之间的职责区别更清晰</li><li>提供新的接口<code>MemoryAccess</code>，在简单的使用场景降低<code>VarHandle API</code>的使用需求，即简化普通场景的使用</li><li>支持 <code>shared segments</code>(多线程场景)</li><li>可以通过<code>Cleaner</code>注册<code>segments</code>（API 保证段的清理操作最多会被调用一次——要么显式地（通过客户端代码），要么隐式地（通过清理器）。）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MemorySegment</span> <span class="variable">segment</span> <span class="operator">=</span> MemorySegment.allocateNative(<span class="number">100</span>);</span><br><span class="line"><span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> Cleaner.create();</span><br><span class="line">segment.registerCleaner(cleaner);</span><br><span class="line"><span class="comment">// do some work</span></span><br><span class="line">segment = <span class="literal">null</span>; <span class="comment">// Cleaner might reclaim the segment memory now</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="instanceof增强开放使用"><a href="#instanceof增强开放使用" class="headerlink" title="instanceof增强开放使用"></a><code>instanceof</code>增强开放使用</h1><p>需要注意变量的声明，避免重复，重复不会影响使用，会影响代码可读性。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Model</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instanceof</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Model</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&quot;private&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Model m) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;instanceof:&quot;</span> + m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;out:instanceof:&quot;</span> + m.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Instanceof.func(<span class="string">&quot;sedg3&quot;</span>);</span><br><span class="line">    Instanceof.func(<span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&quot;demo&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sedg3</span><br><span class="line">out:<span class="keyword">instanceof</span>:<span class="keyword">private</span></span><br><span class="line"><span class="keyword">instanceof</span>:demo</span><br><span class="line">out:<span class="keyword">instanceof</span>:<span class="keyword">private</span></span><br></pre></td></tr></table></figure><h1 id="record-开放使用"><a href="#record-开放使用" class="headerlink" title="record 开放使用"></a>record 开放使用</h1><p>经过JDK14与JDK15的两次调整，在JDK16中开放使用，对于只需要数据建模的场景比较有用，需要额外注意record的限制规则：</p><ul><li>无法继承其他类，与<code>Enum</code>类似，父类限制为<code>java.lang.Record</code></li><li><code>record</code>修饰的类自动包含<code>final</code>规则限制</li><li>类的内部属性默认都是<code>final</code>的</li><li><code>record</code>修饰的类不能在内部显示声明变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">RecordPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="comment">//        Instance field is not allowed in record</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> z;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>不能声明<code>native</code>方法</li></ul><h1 id="强封装JDK"><a href="#强封装JDK" class="headerlink" title="强封装JDK"></a>强封装JDK</h1><p>建议开发人员通过标准API使用JDK内部类的内部元素，而不是直接使用。<br>提高JDK的安全性和可维护性。<br>影响的类涉足领域较多，如果迁移版本后编译失败，可以通过<a href="https://openjdk.org/jeps/396">JEP-396</a>查看替代方案</p><h1 id="密封类（第二次预调整）"><a href="#密封类（第二次预调整）" class="headerlink" title="密封类（第二次预调整）"></a>密封类（第二次预调整）</h1><p>添加了<code>non-sealed</code>，当<code>sealed</code>类的子类使用<code>non-sealed</code>修饰时，该子类可以被其他类继承。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/projects/jdk/16/&quot;&gt;jdk16特性列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cr.openjdk.java.net/~stuefe/JEP-Improve-Metaspace-Allocator/review-guide/review-guide-1.0.html&quot;&gt;JEP-Improve-Metaspace-Allocator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://my.oschina.net/benhaile/blog/214159&quot;&gt;元空间（MetaSpace）一种新的内存空间诞生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1933656&quot;&gt;Java 16 中对于 Project Valhalla 的铺垫&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;record&lt;/code&gt;的开放使用对于一些简单的数据建模场景非常友好，能简化很多重复的编码工作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instanceof&lt;/code&gt;正式放出，可以简化代码，提高代码可读性</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK16" scheme="http://janwarlen.com/tags/JDK16/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK15</title>
    <link href="http://janwarlen.com/2022/06/21/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK15/"/>
    <id>http://janwarlen.com/2022/06/21/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK15/</id>
    <published>2022-06-20T18:04:11.000Z</published>
    <updated>2022-06-21T15:50:12.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://openjdk.org/projects/jdk/15/">jdk15特性列表</a></li><li><a href="https://blog.csdn.net/JAVA88866/article/details/124673213">隐藏类使用案例</a></li><li><a href="http://c.biancheng.net/view/1203.html">UDP通信:DatagramSocket类和DatagramPacket类</a></li><li><a href="http://t.zoukankan.com/yif0118-p-15315745.html">Java17新特性初探</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>ZGC和Shenandoah 的可正式投产比较重要</li><li>隐藏类的使用场景不多，但是对于agent和平台框架开发人员来说比较重要</li><li>文本块的正式开放使用，喜大普奔，相较于以前的大文本操作用起来是真的舒服很多<span id="more"></span></li></ol><h1 id="新签名方案：EdDSA-爱德华兹曲线数字签名算法"><a href="#新签名方案：EdDSA-爱德华兹曲线数字签名算法" class="headerlink" title="新签名方案：EdDSA(爱德华兹曲线数字签名算法)"></a>新签名方案：EdDSA(爱德华兹曲线数字签名算法)</h1><p>新增的签名方案，相比于现有的其他签名方案，它更快并且不降低安全性。可在TLS 1.3 中使用。</p><h1 id="密封类-预调整"><a href="#密封类-预调整" class="headerlink" title="密封类(预调整)"></a>密封类(预调整)</h1><p>使用<code>sealed</code>修饰类后，通过<code>permits</code>限制可以继承当前类的子类，避免无限制的继承扩张。<br>接口也是同样的使用规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">    permits com.example.polar.Circle,</span><br><span class="line">            com.example.quad.Rectangle,</span><br><span class="line">            com.example.quad.simple.Square &#123;...&#125;</span><br></pre></td></tr></table></figure><p>子类必须是 <code>final</code> 或者 <code>sealed</code></p><h1 id="隐藏类"><a href="#隐藏类" class="headerlink" title="隐藏类"></a>隐藏类</h1><p>官方文档看的比较晦涩，可以浏览<a href="https://blog.csdn.net/JAVA88866/article/details/124673213">隐藏类使用案例</a>进行初步的了解，该特性对于平台、框架、agent开发人员比较友好，正常的业务场景不会使用到该特性。</p><h1 id="删除Nashorn-JavaScript-引擎"><a href="#删除Nashorn-JavaScript-引擎" class="headerlink" title="删除Nashorn JavaScript 引擎"></a>删除Nashorn JavaScript 引擎</h1><p>删除 Nashorn JavaScript 脚本引擎和 API 以及该jjs 工具。JDK11标注弃用，JDK15删除。</p><h1 id="重新实现-DatagramSocket-API"><a href="#重新实现-DatagramSocket-API" class="headerlink" title="重新实现 DatagramSocket API"></a>重新实现 DatagramSocket API</h1><p>用易于维护和调试的更简单、更现代的实现替换java.net.DatagramSocket和API的底层实现。<br>笔者未使用过，因此通过其他博主分享的文章了解<code>DatagramSocket</code>是UDP通信的相关类。网络编程相关需要重点关注下。</p><h1 id="弃用和禁用偏向锁"><a href="#弃用和禁用偏向锁" class="headerlink" title="弃用和禁用偏向锁"></a>弃用和禁用偏向锁</h1><p>根据官方文档的说明</p><ol><li>应用不会通过偏向锁获得明显的性能优化</li><li>偏向锁的维护成本较高，并且侵入了其他的HotSpot组件<br>因此，官方决定禁用并且弃用偏向锁。<br>实际的编码中，不会直接涉及偏向锁，主要是JVM内部实现涉及。</li></ol><h1 id="instanceof增强-第二次预调整"><a href="#instanceof增强-第二次预调整" class="headerlink" title="instanceof增强(第二次预调整)"></a>instanceof增强(第二次预调整)</h1><blockquote><p>This JEP proposes to re-preview the feature in JDK 15, with no changes relative to the preview in JDK 14, in order to gather additional feedback.</p></blockquote><p>没变动，纯粹属于提个醒，想收集更多的反馈…..</p><h1 id="ZGC可正式投产"><a href="#ZGC可正式投产" class="headerlink" title="ZGC可正式投产"></a>ZGC可正式投产</h1><p>默认仍是G1，通过启动参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code>启用</p><h1 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h1><p>无新增调整，正式开放使用。</p><h1 id="Shenandoah-可正式投产"><a href="#Shenandoah-可正式投产" class="headerlink" title="Shenandoah 可正式投产"></a>Shenandoah 可正式投产</h1><p>默认仍是G1，通过启动参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>启用。<br>本次无新增功能，并且JDK8于JDK11同步可正式投产使用。</p><h1 id="删除-Solaris-和-SPARC-端口"><a href="#删除-Solaris-和-SPARC-端口" class="headerlink" title="删除 Solaris 和 SPARC 端口"></a>删除 Solaris 和 SPARC 端口</h1><p>JDK14标记弃用，本次迭代彻底删除。</p><ul><li>删除所有特定于 Solaris 操作系统的源代码</li><li>删除特定于 SPARC 体系结构的所有源代码</li></ul><h1 id="外部内存访问-API（更新调整）"><a href="#外部内存访问-API（更新调整）" class="headerlink" title="外部内存访问 API（更新调整）"></a>外部内存访问 API（更新调整）</h1><p>本次更新内容：</p><ul><li>丰富的VarHandle组合器 API，用于自定义内存访问 var 句柄；</li><li>通过接口有针对性地支持内存段的并行处理Spliterator；</li><li>增强了对映射内存段的支持（例如，MappedMemorySegment::force）；</li><li>支持串行限制的安全 API 点（例如，在两个线程之间转移线程所有权）；和</li><li>不安全的 API 指向操作和取消引用来自例如本地调用的地址，或者将这些地址包装到合成内存段中</li></ul><p>因为使用经验较少，对于更新内容无法作出总结…</p><h1 id="新的数据建模方式-Records-第二次预调整"><a href="#新的数据建模方式-Records-第二次预调整" class="headerlink" title="新的数据建模方式 Records(第二次预调整)"></a>新的数据建模方式 Records(第二次预调整)</h1><ul><li>适配了<code>sealed</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.expression;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">Expr</span></span><br><span class="line">    permits ConstantExpr, PlusExpr, TimesExpr, NegExpr &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">ConstantExpr</span><span class="params">(<span class="type">int</span> i)</span>       <span class="keyword">implements</span> <span class="title class_">Expr</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">PlusExpr</span><span class="params">(Expr a, Expr b)</span>  <span class="keyword">implements</span> <span class="title class_">Expr</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">TimesExpr</span><span class="params">(Expr a, Expr b)</span> <span class="keyword">implements</span> <span class="title class_">Expr</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">NegExpr</span><span class="params">(Expr e)</span>           <span class="keyword">implements</span> <span class="title class_">Expr</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li>可局部数据建模<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Merchant&gt; <span class="title function_">findTopMerchants</span><span class="params">(List&lt;Merchant&gt; merchants, <span class="type">int</span> month)</span> &#123;</span><br><span class="line">    <span class="comment">// Local record</span></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">MerchantSales</span><span class="params">(Merchant merchant, <span class="type">double</span> sales)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merchants.stream()</span><br><span class="line">        .map(merchant -&gt; <span class="keyword">new</span> <span class="title class_">MerchantSales</span>(merchant, computeSales(merchant, month)))</span><br><span class="line">        .sorted((m1, m2) -&gt; Double.compare(m2.sales(), m1.sales()))</span><br><span class="line">        .map(MerchantSales::merchant)</span><br><span class="line">        .collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="弃用-RMI-Remote-Method-Invocation-Activation"><a href="#弃用-RMI-Remote-Method-Invocation-Activation" class="headerlink" title="弃用 RMI(Remote Method Invocation) Activation"></a>弃用 RMI(Remote Method Invocation) Activation</h1><blockquote><p>RMI 即 Remote Method Invocation ，其为 Java 提供了远程方法调用的能力，不过，比较鸡肋，基本不会用到。RMI Activation 为激活分布式对象提供支持，不过，一般也不会用到。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/projects/jdk/15/&quot;&gt;jdk15特性列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/JAVA88866/article/details/124673213&quot;&gt;隐藏类使用案例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://c.biancheng.net/view/1203.html&quot;&gt;UDP通信:DatagramSocket类和DatagramPacket类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://t.zoukankan.com/yif0118-p-15315745.html&quot;&gt;Java17新特性初探&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ZGC和Shenandoah 的可正式投产比较重要&lt;/li&gt;
&lt;li&gt;隐藏类的使用场景不多，但是对于agent和平台框架开发人员来说比较重要&lt;/li&gt;
&lt;li&gt;文本块的正式开放使用，喜大普奔，相较于以前的大文本操作用起来是真的舒服很多</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK15" scheme="http://janwarlen.com/tags/JDK15/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK14</title>
    <link href="http://janwarlen.com/2022/06/20/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK14/"/>
    <id>http://janwarlen.com/2022/06/20/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK14/</id>
    <published>2022-06-20T12:22:33.000Z</published>
    <updated>2022-06-21T15:51:56.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://openjdk.org/projects/jdk/14/">jdk14特性列表</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>switch已经可以正式使用，用起来很爽</li><li>官方开放了API可以访问堆外的外部内存，这个特性看起来在大数据领域可以发挥很大的作用</li><li>空指针异常信息的细节增强非常方便开发人员的本地开发过程，大大的简化了本地调试的工作<span id="more"></span></li></ol><h1 id="instanceof增强-预调整"><a href="#instanceof增强-预调整" class="headerlink" title="instanceof增强(预调整)"></a><code>instanceof</code>增强(预调整)</h1><p>目前<code>instanceof</code>大多数使用方式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    <span class="comment">// use s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先判断是否是String类型</li><li>类型强转并赋值新变量</li><li>变量使用<br>增强后，将1-2步骤合并，如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// can use s here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// can&#x27;t use s here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>该特性属于代码简化，增加代码可读性。<br>目前JDK14未开放使用。</li></ol><h1 id="新增一个打包工具"><a href="#新增一个打包工具" class="headerlink" title="新增一个打包工具"></a>新增一个打包工具</h1><p>基于JavaFX的打包工具，能够将Java应用程序打包成各系统对应的应用类型，如exe、dmg、dep等。应该是针对客户端软件的更新。</p><h1 id="G1增强：NUMA-Aware-内存分配"><a href="#G1增强：NUMA-Aware-内存分配" class="headerlink" title="G1增强：NUMA-Aware 内存分配"></a>G1增强：NUMA-Aware 内存分配</h1><p>随着使用非统一内存访问架构(NUMA)的机器越来越多，G1将针对NUMA场景处理增强</p><ol><li>年轻代将保证在同一NUMA节点分配内存，如果内存不够将触发垃圾回收</li><li>老年代不需要保证在同一NUMA节点分配内存</li><li>Humongous区域不适用该策略<br>通过启动参数<code>+XX:+UseNUMA</code>开启</li></ol><h1 id="JFR增强：事件流"><a href="#JFR增强：事件流" class="headerlink" title="JFR增强：事件流"></a>JFR增强：事件流</h1><p>在JDK14之前，JFR都是通过命令手动开启录制，转储文件，再进行分析，现在开放了API，可以通过Java代码进行持续的监控，接下来举例两种使用方式(还有其他使用方式)。<code>agent</code>领域的开发同学狂喜。</p><h2 id="RecordingStream"><a href="#RecordingStream" class="headerlink" title="RecordingStream"></a>RecordingStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecordingStream</span>()) &#123;</span><br><span class="line">    rs.enable(<span class="string">&quot;jdk.CPULoad&quot;</span>).withPeriod(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    rs.enable(<span class="string">&quot;jdk.JavaMonitorEnter&quot;</span>).withThreshold(Duration.ofMillis(<span class="number">10</span>));</span><br><span class="line">    rs.onEvent(<span class="string">&quot;jdk.CPULoad&quot;</span>, event -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1:jdk.CPULoad:&quot;</span> + event.getFloat(<span class="string">&quot;machineTotal&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    rs.onEvent(<span class="string">&quot;jdk.JavaMonitorEnter&quot;</span>, event -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func1:jdk.JavaMonitorEnter:&quot;</span> + event.getClass(<span class="string">&quot;monitorClass&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    rs.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以直接进行指定的参数录制，并在对应的事件中触发，可由自定义代码收集</p><h2 id="EventStream-openRepository"><a href="#EventStream-openRepository" class="headerlink" title="EventStream::openRepository()"></a>EventStream::openRepository()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">EventStream</span> <span class="variable">eventStream</span> <span class="operator">=</span> EventStream.openRepository();</span><br><span class="line">    <span class="keyword">try</span> (eventStream) &#123;</span><br><span class="line">        eventStream.onEvent(recordedEvent -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;func2:getEventType:&quot;</span> + recordedEvent.getEventType().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">        eventStream.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式需要在进程外通过命令行或其他方式开启JFR才能够开始录制。</p><h1 id="硬件适配增强：Non-Volatile-Mapped-Byte-Buffers"><a href="#硬件适配增强：Non-Volatile-Mapped-Byte-Buffers" class="headerlink" title="硬件适配增强：Non-Volatile Mapped Byte Buffers"></a>硬件适配增强：Non-Volatile Mapped Byte Buffers</h1><p>针对 Linux&#x2F;x64 和 Linux&#x2F;AArch64 的非易失性存储器 (NVM)场景下，应用程序可以有效且连贯的访问和更新NVM。<br>官方文档说</p><blockquote><p>NVM offers the opportunity for application programmers to create and update program state across program runs without incurring the significant copying and&#x2F;or translation costs that output to and input from a persistent medium normally implies. This is particularly significant for transactional programs, where regular persistence of in-doubt state is required to enable crash recovery.</p></blockquote><p>跨程序的数据交互场景，笔者想不到能够容易理解的业务场景。这中特定的硬件组合，和JDK10提出的<code>Heap Allocation on Alternative Memory Devices</code>很类似，应该在大数据集群处理的业务场景可能会有用处？</p><h1 id="空指针异常信息增强"><a href="#空指针异常信息增强" class="headerlink" title="空指针异常信息增强"></a>空指针异常信息增强</h1><p>以前的空指针异常信息只显示到某一行，如果某一行的变量比较多，是没办法直接定位哪个变量为null的，这时候基本上都需要本地再运行debug才行，而JDK14中，通过启动参数<code>-XX:+ShowCodeDetailsInExceptionMessages</code>可以开启更详细的空指针异常信息.<br>需要注意的是，官方文档提出这种详细信息是经过了额外的计算的，因此性能方面需要考虑自己的应用空指针异常是否频繁，避免带来额外的性能开销。</p><h2 id="异常示例代码"><a href="#异常示例代码" class="headerlink" title="异常示例代码"></a>异常示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NPE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.b = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.b.a.name = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            B.test().arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[][] arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> B b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h2><h3 id="开启前"><a href="#开启前" class="headerlink" title="开启前"></a>开启前</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">at com.janwarlen.feature.NPE.func(NPE.java:<span class="number">9</span>)</span><br><span class="line">at com.janwarlen.Demo.main(Demo.java:<span class="number">15</span>)</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">at com.janwarlen.feature.NPE.func(NPE.java:<span class="number">14</span>)</span><br><span class="line">at com.janwarlen.Demo.main(Demo.java:<span class="number">15</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="开启后"><a href="#开启后" class="headerlink" title="开启后"></a>开启后</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Cannot assign field <span class="string">&quot;name&quot;</span> because <span class="string">&quot;c.b.a&quot;</span> is <span class="literal">null</span></span><br><span class="line">at com.janwarlen.feature.NPE.func(NPE.java:<span class="number">9</span>)</span><br><span class="line">at com.janwarlen.Demo.main(Demo.java:<span class="number">15</span>)</span><br><span class="line">java.lang.NullPointerException: Cannot load from object array because <span class="string">&quot;com.janwarlen.feature.NPE$B.test().arr&quot;</span> is <span class="literal">null</span></span><br><span class="line">at com.janwarlen.feature.NPE.func(NPE.java:<span class="number">14</span>)</span><br><span class="line">at com.janwarlen.Demo.main(Demo.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure><h1 id="新的数据建模方式-预调整"><a href="#新的数据建模方式-预调整" class="headerlink" title="新的数据建模方式(预调整)"></a>新的数据建模方式(预调整)</h1><p>目前想要封装一个数据模型类，有很多方法需要重复的编码，如<code>equals</code>、<code>hashcode</code>、<code>toString</code>等。因此JDK14中预添加了该技术特性(添加但未开放使用)，以便开发人员更简单的创建数据模型类。因未开放使用，因此只能从官方文档上简单的阅读，从表面上看是简化了数据模型的类的创建，但是看起来实际使用效果并不会太好，因为数据模型类的创建，那些重复编码的函数并不是非常重要的部分，继承多态、工程结构才是。使用该特性是有额外的限制的，比如：不能继承于其他的类，不能为抽象类，并且是隐式的<code>final</code>等等。综合对比，似乎该特性即便开放使用，也只能在有限的场景里发挥作用。</p><h1 id="Switch增强-正式开发使用"><a href="#Switch增强-正式开发使用" class="headerlink" title="Switch增强(正式开发使用)"></a>Switch增强(正式开发使用)</h1><p>前两次JDK的预调整终于开放使用，放Demo代码</p><h2 id="增强前"><a href="#增强前" class="headerlink" title="增强前"></a>增强前</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;small&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;6&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;big&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;illegal&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">switch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            x = <span class="number">111</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            x = <span class="number">222</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            x = <span class="number">233</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            x = <span class="number">666</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增强后"><a href="#增强后" class="headerlink" title="增强后"></a>增强后</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1Enhanced</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span> -&gt; System.out.println(<span class="string">&quot;small&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span> -&gt; System.out.println(<span class="string">&quot;big&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;illegal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2Enhanced</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">switch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="number">111</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="number">222</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> -&gt; <span class="number">233</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="number">666</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>官方文档没有明确说明yield的作用，从示例代码来看(和之前JDK版本的说明)，该关键字使用场景为case中执行语句有多条，但是又必须返回值的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func3</span><span class="params">(String yield)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">switch</span> (yield) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;MONDAY&quot;</span> -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;monday&quot;</span>);</span><br><span class="line">                yield <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;TUESDAY&quot;</span> -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;TUESDAY&quot;</span>);</span><br><span class="line">                yield <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;not monday&quot;</span>);</span><br><span class="line">                yield <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;func3:&quot;</span> + d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="弃用-Solaris-and-SPARC-Ports"><a href="#弃用-Solaris-and-SPARC-Ports" class="headerlink" title="弃用 Solaris and SPARC Ports"></a>弃用 Solaris and SPARC Ports</h1><p>不太明白这俩是干嘛的，也没有搜到有博主分享关于这两个的文档，根据官方文档的这段话</p><blockquote><p>Dropping support for these ports will enable contributors in the OpenJDK Community to accelerate the development of new features that will move the platform forward.</p></blockquote><p>看着像是针对特殊的系统平台类的兼容，该弃用应该也是为了更方便的迭代和扩展。</p><h1 id="删除垃圾回收器-CMS-Concurrent-Mark-Sweep"><a href="#删除垃圾回收器-CMS-Concurrent-Mark-Sweep" class="headerlink" title="删除垃圾回收器: CMS(Concurrent Mark Sweep)"></a>删除垃圾回收器: CMS(Concurrent Mark Sweep)</h1><p>G1已经可以完全替代CMS，从性能和效率各个方面，JDK9标注废弃，等到这个版本才正式删除。</p><h1 id="ZGC移植：macOS、Windows-实验性"><a href="#ZGC移植：macOS、Windows-实验性" class="headerlink" title="ZGC移植：macOS、Windows(实验性)"></a>ZGC移植：macOS、Windows(实验性)</h1><p>方便开发人员在本地调试，也针对开发桌面客户端软件的用户能够使用ZGC。</p><h1 id="垃圾回收算法弃用：ParallelScavenge-SerialOld"><a href="#垃圾回收算法弃用：ParallelScavenge-SerialOld" class="headerlink" title="垃圾回收算法弃用：ParallelScavenge + SerialOld"></a>垃圾回收算法弃用：ParallelScavenge + SerialOld</h1><p>官方假设使用这种算法组合的人较少才进行弃用，如果后续反馈的人数较多，可能会重新启用。<br>官方认为这种组合仅适用于具有非常大的年轻一代和非常小的老一代的部署。<br>涉及启动参数:<code>-XX:+UseParallelGC -XX:-UseParallelOldGC -XX:UseParallelOldGC</code></p><h1 id="删除Pack200及其API"><a href="#删除Pack200及其API" class="headerlink" title="删除Pack200及其API"></a>删除Pack200及其API</h1><p>JDK11弃用的，在本此JDK迭代中彻底删除<br>该针对jar包的压缩方案已经不再适用于现在的各种场景。</p><h1 id="文本块-第二次预调整"><a href="#文本块-第二次预调整" class="headerlink" title="文本块(第二次预调整)"></a>文本块(第二次预调整)</h1><p>为了更好地控制换行符和空格的处理，我们引入了两个新的转义序列。</p><h2 id="当前行末尾添加-表示不换行"><a href="#当前行末尾添加-表示不换行" class="headerlink" title="当前行末尾添加\表示不换行"></a>当前行末尾添加\表示不换行</h2><p>该转义仅在文本块中生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">literal</span> <span class="operator">=</span> <span class="string">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;elit, sed do eiusmod tempor incididunt ut labore &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;et dolore magna aliqua.&quot;</span>;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                Lorem ipsum dolor sit amet, consectetur adipiscing \</span></span><br><span class="line"><span class="string">                elit, sed do eiusmod tempor incididunt ut labore \</span></span><br><span class="line"><span class="string">                et dolore magna aliqua.\</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="s"><a href="#s" class="headerlink" title="\s"></a>\s</h2><p>等效于’ ‘。该转义在String中都可以使用。<br>应该是针对String::stripIndent()和trim()提出的，<code>Escape sequences aren&#39;t translated until after incident space stripping</code>，使用\s防止文本块中行末的空格被清空。</p><h1 id="添加API以便Java可以访问堆外外部内存"><a href="#添加API以便Java可以访问堆外外部内存" class="headerlink" title="添加API以便Java可以访问堆外外部内存"></a>添加API以便Java可以访问堆外外部内存</h1><ol><li>避开垃圾回收器维护大量的缓存</li><li>跨进程通信</li><li>映射文件到内存<br>等等场景皆可使用，不过官方仅是给出API可以访问堆外的外部内存，具体的功能实现还需要用户自己去封装。<br>核心三个类<code>MemorySegment/MemoryAddress/MemoryLayout</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/projects/jdk/14/&quot;&gt;jdk14特性列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;switch已经可以正式使用，用起来很爽&lt;/li&gt;
&lt;li&gt;官方开放了API可以访问堆外的外部内存，这个特性看起来在大数据领域可以发挥很大的作用&lt;/li&gt;
&lt;li&gt;空指针异常信息的细节增强非常方便开发人员的本地开发过程，大大的简化了本地调试的工作</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK14" scheme="http://janwarlen.com/tags/JDK14/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK13</title>
    <link href="http://janwarlen.com/2022/06/20/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK13/"/>
    <id>http://janwarlen.com/2022/06/20/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK13/</id>
    <published>2022-06-20T08:12:33.000Z</published>
    <updated>2022-06-21T15:50:12.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://openjdk.org/projects/jdk/13/">jdk13特性列表</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>本次版本没有对用户代码直接影响特性</li><li>AppCDS的增强对于使用AppCDS的用户来说是降低了日常的使用成本</li><li>对于大多数开发人员来说，我想<code>文本块</code>的提出是非常令人舒畅的，日常的大文本的使用的确是一直为人诟病的，这个虽然只是小细节的优化调整，甚至都未开放使用，但是却令笔者对Java的后续更新迭代增加了很多期望<span id="more"></span></li></ol><h1 id="AppCDS增强"><a href="#AppCDS增强" class="headerlink" title="AppCDS增强"></a>AppCDS增强</h1><p>应用程序退出时将动态创建共享的归档，该归档是在JDK12中新增的默认归档基础上创建，因此启动参数不可指定<code>-Xshare:off</code>(默认为on)，该特性提高了AppCDS的可用性，JDK10 中需要先运行几次应用来创建类列表，再转储为归档文件，再使用归档文件启动。<br>应用程序退出时动态创建归档需要使用启动参数<code>-XX:ArchiveClassesAtExit</code>开启。</p><h1 id="ZGC增强：允许释放未使用堆内存回操作系统"><a href="#ZGC增强：允许释放未使用堆内存回操作系统" class="headerlink" title="ZGC增强：允许释放未使用堆内存回操作系统"></a>ZGC增强：允许释放未使用堆内存回操作系统</h1><p>该功能与JDK10 的G1增强一致，都是为了尽可能减少应用程序的资源消耗。<br>不会将内存减少到低于<code>-Xms</code>。</p><h1 id="替换-Socket-API-底层实现"><a href="#替换-Socket-API-底层实现" class="headerlink" title="替换 Socket API 底层实现"></a>替换 Socket API 底层实现</h1><p>将 java.net.Socket 和 java.net.ServerSocket API 使用的底层实现替换为更简单、更现代且易于维护和调试的实现。</p><h1 id="switch表达式第二次预调整"><a href="#switch表达式第二次预调整" class="headerlink" title="switch表达式第二次预调整"></a>switch表达式第二次预调整</h1><p>对比于JDK12的调整，本次是取消了break 返回值，使用<code>yield</code>返回值进行替换。<br>JDK13未正式开放使用该特性。</p><h1 id="文本块-预调整"><a href="#文本块-预调整" class="headerlink" title="文本块(预调整)"></a>文本块(预调整)</h1><p>目前对于大量文本大多用<code>+</code>和换行进行拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;    &lt;body&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;        &lt;p&gt;Hello, world&lt;/p&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;    &lt;/body&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>新的文本块特性将允许<code>&quot;&quot;&quot;</code>标记文本区域，从而简化文本块的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              &lt;html&gt;</span></span><br><span class="line"><span class="string">                  &lt;body&gt;</span></span><br><span class="line"><span class="string">                      &lt;p&gt;Hello, world&lt;/p&gt;</span></span><br><span class="line"><span class="string">                  &lt;/body&gt;</span></span><br><span class="line"><span class="string">              &lt;/html&gt;</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>JDK13未正式开放使用该特性。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/projects/jdk/13/&quot;&gt;jdk13特性列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;本次版本没有对用户代码直接影响特性&lt;/li&gt;
&lt;li&gt;AppCDS的增强对于使用AppCDS的用户来说是降低了日常的使用成本&lt;/li&gt;
&lt;li&gt;对于大多数开发人员来说，我想&lt;code&gt;文本块&lt;/code&gt;的提出是非常令人舒畅的，日常的大文本的使用的确是一直为人诟病的，这个虽然只是小细节的优化调整，甚至都未开放使用，但是却令笔者对Java的后续更新迭代增加了很多期望</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK13" scheme="http://janwarlen.com/tags/JDK13/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK12</title>
    <link href="http://janwarlen.com/2022/06/19/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK12/"/>
    <id>http://janwarlen.com/2022/06/19/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK12/</id>
    <published>2022-06-19T12:12:33.000Z</published>
    <updated>2022-06-21T15:50:12.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://openjdk.org/projects/jdk/12/">jdk12特性列表</a></li><li><a href="https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK">Shenandoah算法论文</a></li><li><a href="https://github.com/openjdk/jmh-jdk-microbenchmarks">jmh Git仓库</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>JDK12对用户代码无直接影响</li><li>主要内容是新增GC(实验阶段)和对已有G1的增强<span id="more"></span></li></ol><h1 id="新GC：Shenandoah-实验"><a href="#新GC：Shenandoah-实验" class="headerlink" title="新GC：Shenandoah(实验)"></a>新GC：Shenandoah(实验)</h1><p>GC时间不受堆内存大小影响，200M与200G 停顿时间一致，通过启动参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</code>开启。</p><h1 id="基准测试组件"><a href="#基准测试组件" class="headerlink" title="基准测试组件"></a>基准测试组件</h1><p>添加了基础的基准测试组件，方便开发人员(测试方向)执行现有的基准测试和创建新的基准测试。<br>实际尝试了，从JDK12-18在maven未引入<code>jmh</code>相关jar包是无法使用相关注解的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是官方文档明确说了将基础的组件添加到了jdk的源码中，因此只能推测是只开放给JDK开发人员使用。通过官方github下载的<code>jdk12</code>源码，目录结构也与文档一致，相关代码都在test目录中，因此该特性是针对JDK开发人员来说的….</p><h1 id="Switch表达式优化-JDK12暂未开放"><a href="#Switch表达式优化-JDK12暂未开放" class="headerlink" title="Switch表达式优化(JDK12暂未开放)"></a>Switch表达式优化(JDK12暂未开放)</h1><h2 id="简化case分支"><a href="#简化case分支" class="headerlink" title="简化case分支"></a>简化case分支</h2><p>但在JDK12中还不能使用，会提示<code>Enhanced &#39;switch&#39; blocks are not supported at language level &#39;12&#39;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        System.out.println(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        System.out.println(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        System.out.println(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch代码块可当作函数返回值"><a href="#switch代码块可当作函数返回值" class="headerlink" title="switch代码块可当作函数返回值"></a>switch代码块可当作函数返回值</h2><p>实际不确定这样写会不会影响代码的可读性，尤其是switch的case情况较多的场景，还是建议封装为单独的函数，避免switch代码块庞大影响代码可读性。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">    <span class="keyword">case</span> L1 -&gt; e1;</span><br><span class="line">    <span class="keyword">case</span> L2 -&gt; e2;</span><br><span class="line">    <span class="keyword">default</span> -&gt; e3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Foo&quot;</span>: </span><br><span class="line">        <span class="keyword">break</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Bar&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Neither Foo nor Bar, hmmm...&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="JVM常量API"><a href="#JVM常量API" class="headerlink" title="JVM常量API"></a>JVM常量API</h1><blockquote><p>Introduce an API to model nominal descriptions of key class-file and run-time artifacts, in particular constants that are loadable from the constant pool.</p></blockquote><p>引入一个 API 来模拟关键类文件和运行时工件的名义描述，特别是可从常量池加载的常量。<br>没有搜到有博主分享使用该特性的场景，应该也是JDK或JVM内部的开发工作优化。</p><h1 id="AArch64兼容代码优化"><a href="#AArch64兼容代码优化" class="headerlink" title="AArch64兼容代码优化"></a>AArch64兼容代码优化</h1><p>属于代码重构，简化后续JDK工作。</p><h1 id="默认-CDS"><a href="#默认-CDS" class="headerlink" title="默认 CDS"></a>默认 CDS</h1><p>该特性仅针对64位的JDK，相当于默认开启JDK的CDS，如果不需要CDS，需要使用启动参数<code>-Xshare:off</code>停止。</p><h1 id="可中断的Mixed-G1"><a href="#可中断的Mixed-G1" class="headerlink" title="可中断的Mixed G1"></a>可中断的Mixed G1</h1><p>当G1预计回收的区域过多时，将会切换到Mixed模式，将目标切割为必须回收与可选回收，在目标时间内，有限回收必须回收部分，如果时间有剩余，才会处理可选回收部分，并且时间结束就立即停止，无论可选回收部分是否全部回收结束。<br>有效的避免G1的回收时间超过用户指定时间(<code>-XX:MaxGCPauseMillis</code>默认200ms)</p><h1 id="空闲时G1也可释放内存回操作系统"><a href="#空闲时G1也可释放内存回操作系统" class="headerlink" title="空闲时G1也可释放内存回操作系统"></a>空闲时G1也可释放内存回操作系统</h1><p>增强G1(定期触发)，使得G1在应用程序不活动期间，也可以进行内存回收行动，减少资源消耗。<br>触发条件有两个，需同时满足：</p><ol><li>G1PeriodicGCInterval时间内无任何垃圾回收行为(包括并发标记周期)</li><li>一分钟内，系统负载(通过<code>getloadavg()</code>获取)低于<code>G1PeriodicGCSystemLoadThreshold</code>(该值为0则此条件忽略)</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/projects/jdk/12/&quot;&gt;jdk12特性列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/publication/306112816_Shenandoah_An_open-source_concurrent_compacting_garbage_collector_for_OpenJDK&quot;&gt;Shenandoah算法论文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/openjdk/jmh-jdk-microbenchmarks&quot;&gt;jmh Git仓库&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;JDK12对用户代码无直接影响&lt;/li&gt;
&lt;li&gt;主要内容是新增GC(实验阶段)和对已有G1的增强</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK12" scheme="http://janwarlen.com/tags/JDK12/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK11</title>
    <link href="http://janwarlen.com/2022/06/17/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK11/"/>
    <id>http://janwarlen.com/2022/06/17/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK11/</id>
    <published>2022-06-17T08:38:41.000Z</published>
    <updated>2022-06-21T15:50:12.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://openjdk.org/projects/jdk/11/">jdk11特性列表</a></li><li><a href="https://www.bbsmax.com/A/QW5Ybg23dm/">nest class和inner class的区别</a></li><li><a href="https://cloud.tencent.com/developer/article/1165256">JDK11中增加了一个常量池类型：CONSTANT_Dynamic</a></li><li><a href="https://www.techwell.com/techwell-insights/2021/08/new-jvm-features-jdk-11">new-jvm-features-jdk-11</a></li><li><a href="https://www.javacodegeeks.com/2018/08/hands-on-java-constantdynamic.html">hands-on-java-constantdynamic</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>直接影响编码的功能几乎没有，大多数都是幕后工作的更新</li><li>ZGC是一个核心内容，不过JDK11中是实验版</li><li>JFR的加入方便了性能监控，建议上手实际操作几次，非常好用</li><li>加密算法的几个新增实现未进行深入了解(未涉足领域，功力不足)<span id="more"></span></li></ol><h1 id="内部类-嵌套类-的权限控制-Nest-Based-Access-Control"><a href="#内部类-嵌套类-的权限控制-Nest-Based-Access-Control" class="headerlink" title="内部类(嵌套类)的权限控制(Nest-Based Access Control)"></a>内部类(嵌套类)的权限控制(Nest-Based Access Control)</h1><blockquote><p>Introduce nests, an access-control context that aligns with the existing notion of nested types in the Java programming language. Nests allow classes that are logically part of the same code entity, but which are compiled to distinct class files, to access each other’s private members without the need for compilers to insert accessibility-broadening bridge methods.</p></blockquote><p> <a href="https://openjdk.org/jeps/181">原文</a>的开头介绍说自该版本起，内部类之间访问私有属性不用再通过编译器生成<code>accessibility-broadening bridge methods</code>。然后我阅读整篇文档都没有举例说明这个是啥，并且又引入了新的概念<code>InnerClasses</code>和<code>EnclosingMethod</code>，越看越迷糊，百度也没有比较好的文章去说明这个特性，不过还好搜到了<code>nest class和inner class的区别</code>，但是光明白这个也没用，还好之前看<code>《深入理解Java虚拟机》</code>时了解到了java的class文件反编译汇编的概念，于是尝试了一下</p><h2 id="Demo类"><a href="#Demo类" class="headerlink" title="Demo类"></a>Demo类</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//https://openjdk.org/jeps/181</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NestClass_1</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">NestClass_2</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestClass_2</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;NestClass_1:func:NestClass_2:name:&quot;</span> + n2.name);</span><br><span class="line">            <span class="type">NestClass</span> <span class="variable">nestClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestClass</span>();</span><br><span class="line">            <span class="type">InnerClass</span> <span class="variable">i1</span> <span class="operator">=</span> nestClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;NestClass_1:func:InnerClass:name:&quot;</span> + i1.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NestClass_2</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;NestClass_2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;InnerClass&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该类通过JDK8和JDK11分别得到两套class文件，使用<code>javap -c class文件名</code>命令去得到反编译结果，可直接查看<a href="#%E5%AF%B9%E6%AF%94%E8%A7%A3%E8%AF%BB">对比解读</a></p><h2 id="反编译结果"><a href="#反编译结果" class="headerlink" title="反编译结果"></a>反编译结果</h2><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"> jan<span class="meta">@JanWarlendeMacBook</span>-Pro feature % javap -c NestClass.<span class="keyword">class</span> </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">&quot;NestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.janwarlen.feature.NestClass &#123;</span><br><span class="line">  <span class="keyword">public</span> com.janwarlen.feature.NestClass();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">jan<span class="meta">@JanWarlendeMacBook</span>-Pro feature % javap -c NestClass\$NestClass_1.<span class="keyword">class</span> </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">&quot;NestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.janwarlen.feature.NestClass$NestClass_1 &#123;</span><br><span class="line">  <span class="keyword">public</span> com.janwarlen.feature.NestClass$NestClass_1();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/janwarlen/feature/NestClass$NestClass_2</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method com/janwarlen/feature/NestClass$NestClass_2.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">11</span>: <span class="keyword">new</span>           #<span class="number">5</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">      <span class="number">14</span>: dup</span><br><span class="line">      <span class="number">15</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">18</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String NestClass_1:func:NestClass_2:name:</span></span><br><span class="line">      <span class="number">20</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">23</span>: aload_1</span><br><span class="line">      <span class="number">24</span>: invokestatic  #<span class="number">9</span>                  <span class="comment">// Method com/janwarlen/feature/NestClass$NestClass_2.access$000:(Lcom/janwarlen/feature/NestClass$NestClass_2;)Ljava/lang/String;</span></span><br><span class="line">      <span class="number">27</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">30</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">33</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">36</span>: <span class="keyword">new</span>           #<span class="number">12</span>                 <span class="comment">// class com/janwarlen/feature/NestClass</span></span><br><span class="line">      <span class="number">39</span>: dup</span><br><span class="line">      <span class="number">40</span>: invokespecial #<span class="number">13</span>                 <span class="comment">// Method com/janwarlen/feature/NestClass.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">43</span>: astore_2</span><br><span class="line">      <span class="number">44</span>: <span class="keyword">new</span>           #<span class="number">14</span>                 <span class="comment">// class com/janwarlen/feature/NestClass$InnerClass</span></span><br><span class="line">      <span class="number">47</span>: dup</span><br><span class="line">      <span class="number">48</span>: aload_2</span><br><span class="line">      <span class="number">49</span>: dup</span><br><span class="line">      <span class="number">50</span>: invokevirtual #<span class="number">15</span>                 <span class="comment">// Method java/lang/Object.getClass:()Ljava/lang/Class;</span></span><br><span class="line">      <span class="number">53</span>: pop</span><br><span class="line">      <span class="number">54</span>: invokespecial #<span class="number">16</span>                 <span class="comment">// Method com/janwarlen/feature/NestClass$InnerClass.&quot;&lt;init&gt;&quot;:(Lcom/janwarlen/feature/NestClass;)V</span></span><br><span class="line">      <span class="number">57</span>: astore_3</span><br><span class="line">      <span class="number">58</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">61</span>: <span class="keyword">new</span>           #<span class="number">5</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">      <span class="number">64</span>: dup</span><br><span class="line">      <span class="number">65</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">68</span>: ldc           #<span class="number">17</span>                 <span class="comment">// String NestClass_1:func:InnerClass:name:</span></span><br><span class="line">      <span class="number">70</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">73</span>: aload_3</span><br><span class="line">      <span class="number">74</span>: invokestatic  #<span class="number">18</span>                 <span class="comment">// Method com/janwarlen/feature/NestClass$InnerClass.access$100:(Lcom/janwarlen/feature/NestClass$InnerClass;)Ljava/lang/String;</span></span><br><span class="line">      <span class="number">77</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">80</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">83</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">86</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">jan<span class="meta">@JanWarlendeMacBook</span>-Pro feature % javap -c NestClass\$NestClass_2.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">&quot;NestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.janwarlen.feature.NestClass$NestClass_2 &#123;</span><br><span class="line">  <span class="keyword">public</span> com.janwarlen.feature.NestClass$NestClass_2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">2</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String NestClass_2</span></span><br><span class="line">       <span class="number">7</span>: putfield      #<span class="number">1</span>                  <span class="comment">// Field name:Ljava/lang/String;</span></span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> java.lang.String access$<span class="number">000</span>(com.janwarlen.feature.NestClass$NestClass_2);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">1</span>                  <span class="comment">// Field name:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line">&#125;</span><br><span class="line">jan<span class="meta">@JanWarlendeMacBook</span>-Pro feature % javap -c NestClass\$InnerClass.<span class="keyword">class</span> </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">&quot;NestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.janwarlen.feature.NestClass$InnerClass &#123;</span><br><span class="line">  <span class="keyword">final</span> com.janwarlen.feature.NestClass <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.janwarlen.feature.NestClass$InnerClass(com.janwarlen.feature.NestClass);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field this$0:Lcom/janwarlen/feature/NestClass;</span></span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       <span class="number">6</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">9</span>: aload_0</span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String InnerClass</span></span><br><span class="line">      <span class="number">12</span>: putfield      #<span class="number">1</span>                  <span class="comment">// Field name:Ljava/lang/String;</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> java.lang.String access$<span class="number">100</span>(com.janwarlen.feature.NestClass$InnerClass);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">1</span>                  <span class="comment">// Field name:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">jan<span class="meta">@JanWarlendeMacBook</span>-Pro feature % javap -c NestClass.<span class="keyword">class</span> </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">&quot;NestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.janwarlen.feature.NestClass &#123;</span><br><span class="line">  <span class="keyword">public</span> com.janwarlen.feature.NestClass();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">jan<span class="meta">@JanWarlendeMacBook</span>-Pro feature % javap -c NestClass\$NestClass_1.<span class="keyword">class</span> </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">&quot;NestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.janwarlen.feature.NestClass$NestClass_1 &#123;</span><br><span class="line">  <span class="keyword">public</span> com.janwarlen.feature.NestClass$NestClass_1();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/janwarlen/feature/NestClass$NestClass_2</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method com/janwarlen/feature/NestClass$NestClass_2.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      <span class="number">12</span>: getfield      #<span class="number">5</span>                  <span class="comment">// Field com/janwarlen/feature/NestClass$NestClass_2.name:Ljava/lang/String;</span></span><br><span class="line">      <span class="number">15</span>: invokedynamic #<span class="number">6</span>,  <span class="number">0</span>              <span class="comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line">      <span class="number">20</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">23</span>: <span class="keyword">new</span>           #<span class="number">8</span>                  <span class="comment">// class com/janwarlen/feature/NestClass</span></span><br><span class="line">      <span class="number">26</span>: dup</span><br><span class="line">      <span class="number">27</span>: invokespecial #<span class="number">9</span>                  <span class="comment">// Method com/janwarlen/feature/NestClass.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">30</span>: astore_2</span><br><span class="line">      <span class="number">31</span>: <span class="keyword">new</span>           #<span class="number">10</span>                 <span class="comment">// class com/janwarlen/feature/NestClass$InnerClass</span></span><br><span class="line">      <span class="number">34</span>: dup</span><br><span class="line">      <span class="number">35</span>: aload_2</span><br><span class="line">      <span class="number">36</span>: dup</span><br><span class="line">      <span class="number">37</span>: invokestatic  #<span class="number">11</span>                 <span class="comment">// Method java/util/Objects.requireNonNull:(Ljava/lang/Object;)Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">40</span>: pop</span><br><span class="line">      <span class="number">41</span>: invokespecial #<span class="number">12</span>                 <span class="comment">// Method com/janwarlen/feature/NestClass$InnerClass.&quot;&lt;init&gt;&quot;:(Lcom/janwarlen/feature/NestClass;)V</span></span><br><span class="line">      <span class="number">44</span>: astore_3</span><br><span class="line">      <span class="number">45</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">48</span>: aload_3</span><br><span class="line">      <span class="number">49</span>: getfield      #<span class="number">13</span>                 <span class="comment">// Field com/janwarlen/feature/NestClass$InnerClass.name:Ljava/lang/String;</span></span><br><span class="line">      <span class="number">52</span>: invokedynamic #<span class="number">14</span>,  <span class="number">0</span>             <span class="comment">// InvokeDynamic #1:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line">      <span class="number">57</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">60</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">jan<span class="meta">@JanWarlendeMacBook</span>-Pro feature % javap -c NestClass\$NestClass_2.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">&quot;NestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.janwarlen.feature.NestClass$NestClass_2 &#123;</span><br><span class="line">  <span class="keyword">public</span> com.janwarlen.feature.NestClass$NestClass_2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String NestClass_2</span></span><br><span class="line">       <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field name:Ljava/lang/String;</span></span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">jan<span class="meta">@JanWarlendeMacBook</span>-Pro feature % javap -c NestClass\$InnerClass.<span class="keyword">class</span> </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">&quot;NestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.janwarlen.feature.NestClass$InnerClass &#123;</span><br><span class="line">  <span class="keyword">final</span> com.janwarlen.feature.NestClass <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.janwarlen.feature.NestClass$InnerClass(com.janwarlen.feature.NestClass);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       <span class="number">2</span>: putfield      #<span class="number">1</span>                  <span class="comment">// Field this$0:Lcom/janwarlen/feature/NestClass;</span></span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       <span class="number">6</span>: invokespecial #<span class="number">2</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">9</span>: aload_0</span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String InnerClass</span></span><br><span class="line">      <span class="number">12</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field name:Ljava/lang/String;</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比解读"><a href="#对比解读" class="headerlink" title="对比解读"></a><span id="对比解读">对比解读</span></h3><h4 id="EnclosingMethod"><a href="#EnclosingMethod" class="headerlink" title="EnclosingMethod"></a><code>EnclosingMethod</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.janwarlen.feature.NestClass$InnerClass(com.janwarlen.feature.NestClass);</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: aload_0</span><br><span class="line">     <span class="number">1</span>: aload_1</span><br><span class="line">     <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field this$0:Lcom/janwarlen/feature/NestClass;</span></span><br><span class="line">     <span class="number">5</span>: aload_0</span><br><span class="line">     <span class="number">6</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">     <span class="number">9</span>: aload_0</span><br><span class="line">    <span class="number">10</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String InnerClass</span></span><br><span class="line">    <span class="number">12</span>: putfield      #<span class="number">1</span>                  <span class="comment">// Field name:Ljava/lang/String;</span></span><br><span class="line">    <span class="number">15</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>JDK8和JDK11反编译结果中均有此代码，但是源码中只有一个属性，因此我推测这个就是所谓的<code>EnclosingMethod</code>（笔者此时还不了解闭包），而内部类的特殊创建方式估计也是与此有关。需要注意的是<code>Nest Class</code>是没有该代码的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NestClass</span> <span class="variable">nestClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestClass</span>();</span><br><span class="line"><span class="type">InnerClass</span> <span class="variable">i1</span> <span class="operator">=</span> nestClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure><h4 id="accessibility-broadening-bridge-methods"><a href="#accessibility-broadening-bridge-methods" class="headerlink" title="accessibility-broadening bridge methods"></a><code>accessibility-broadening bridge methods</code></h4><p>因为在<code>nest class</code> <code>NestClass_1</code>中我们使用了<code>inner class</code>的私有属性，因此，在反编译的结果中，我们看到了JDK8和JDK11的不同之处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> java.lang.String access$<span class="number">100</span>(com.janwarlen.feature.NestClass$InnerClass);</span><br><span class="line">  Code:</span><br><span class="line">     <span class="number">0</span>: aload_0</span><br><span class="line">     <span class="number">1</span>: getfield      #<span class="number">1</span>                  <span class="comment">// Field name:Ljava/lang/String;</span></span><br><span class="line">     <span class="number">4</span>: areturn</span><br></pre></td></tr></table></figure><p>上述汇编代码在<code>JDK11</code>的反编译结果中不存在，需要明白这个编码的作用我们需要再看调用方的反编译汇编码。</p><h5 id="调用源码"><a href="#调用源码" class="headerlink" title="调用源码"></a>调用源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;NestClass_1:func:InnerClass:name:&quot;</span> + i1.name);</span><br></pre></td></tr></table></figure><h5 id="JDK8调用汇编码"><a href="#JDK8调用汇编码" class="headerlink" title="JDK8调用汇编码"></a>JDK8调用汇编码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分节选</span></span><br><span class="line">      <span class="number">58</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">61</span>: <span class="keyword">new</span>           #<span class="number">5</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">      <span class="number">64</span>: dup</span><br><span class="line">      <span class="number">65</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">68</span>: ldc           #<span class="number">17</span>                 <span class="comment">// String NestClass_1:func:InnerClass:name:</span></span><br><span class="line">      <span class="number">70</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">73</span>: aload_3</span><br><span class="line">      <span class="number">74</span>: invokestatic  #<span class="number">18</span>                 <span class="comment">// Method com/janwarlen/feature/NestClass$InnerClass.access$100:(Lcom/janwarlen/feature/NestClass$InnerClass;)Ljava/lang/String;</span></span><br><span class="line">      <span class="number">77</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">80</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">83</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br></pre></td></tr></table></figure><h5 id="JDK11调用汇编码"><a href="#JDK11调用汇编码" class="headerlink" title="JDK11调用汇编码"></a>JDK11调用汇编码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">45</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">48</span>: aload_3</span><br><span class="line"><span class="number">49</span>: getfield      #<span class="number">13</span>                 <span class="comment">// Field com/janwarlen/feature/NestClass$InnerClass.name:Ljava/lang/String;</span></span><br><span class="line"><span class="number">52</span>: invokedynamic #<span class="number">14</span>,  <span class="number">0</span>             <span class="comment">// InvokeDynamic #1:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line"><span class="number">57</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br></pre></td></tr></table></figure><h4 id="accessibility-broadening-bridge-methods续"><a href="#accessibility-broadening-bridge-methods续" class="headerlink" title="accessibility-broadening bridge methods续"></a><code>accessibility-broadening bridge methods</code>续</h4><p>观察上方两者汇编码，我们可以看出在JDK11中字符串的拼接也进行了优化，此处先不赘述，我们单独看变量使用，JDK8是通过<code>Method com/janwarlen/feature/NestClass$InnerClass.access$100</code>去获得私有属性的值，而JDK11则是直接去获取了属性，这样，突然就明白了为什么说是<code>bridge methods</code>了，并且这样对比，发现汇编的指令码也少了很多，这样对于JVM的性能提升也是有帮助的。</p><h3 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h3><p>期待后续有机会回填，以下的优化点实在是难以通过代码直观查看，因此只好暂时先跳过，也许以后实力见长，可以去深入JVM内部去查看对比，届时再返回填土….</p><ol><li>JVM Access Control for Nestmates</li><li>Nest Membership Validation</li></ol><h1 id="常量池添加新类型CONSTANT-Dynamic"><a href="#常量池添加新类型CONSTANT-Dynamic" class="headerlink" title="常量池添加新类型CONSTANT_Dynamic"></a>常量池添加新类型<code>CONSTANT_Dynamic</code></h1><p>官方的JEP原文看的头痛欲裂，和上一个一样，概念性居多，整篇看下来感觉添加这个是因为本次JDK更新的一些内容和指令<code>invokedynamic</code>经常起冲突导致工作量增多而进行的调整，也算是为后续的工作减少工作量<code>improving program performance and simplifying compiler logic</code>。<br>浏览<a href="https://www.techwell.com/techwell-insights/2021/08/new-jvm-features-jdk-11">new-jvm-features-jdk-11</a>和<a href="https://www.javacodegeeks.com/2018/08/hands-on-java-constantdynamic.html">hands-on-java-constantdynamic</a>之后，感觉<code>java agent</code>领域的同学可能需要更多的关注这个，可能需要深入研究，尤其是<code>hands-on-java-constantdynamic</code>中有这么一段话(虽然目前并不能想到使用场景以及使用方式)</p><blockquote><p>The constantdynamic feature can also be useful to Java agents that often need to enhance existing classes with additional information. Java agents cannot normally alter a classes by for example adding static fields as this can both interfere with reflection-based frameworks and since class format changes are forbidden on most JVMs when redefining an already loaded class. Neither restriction does however apply to dynamic constants that are added during runtime where a Java agent can now easily tag classes with additional information.</p></blockquote><h1 id="针对AArch64处理器优化部分函数"><a href="#针对AArch64处理器优化部分函数" class="headerlink" title="针对AArch64处理器优化部分函数"></a>针对AArch64处理器优化部分函数</h1><p>该特性是硬件适配内容，如果使用的服务器有涉及AArch64处理器，建议增加额外的性能测试，避免未知问题，因为原文中有如下一段话，大致意思就是官方性能测试并未覆盖所有<code>AArch64</code>架构，相当一部分还是依靠OpenJDK社区反馈，因此需要额外注意。</p><blockquote><p>It is not possible to perform testing and performance measurements on all AArch64 hardware variants. We will rely on the OpenJDK Community to perform testing on hardware we currently do not have in-house should they find it necessary when patches are submitted for review.</p></blockquote><h1 id="新GC：Epsilon-GC（实验性）"><a href="#新GC：Epsilon-GC（实验性）" class="headerlink" title="新GC：Epsilon GC（实验性）"></a>新GC：Epsilon GC（实验性）</h1><blockquote><p>Develop a GC that handles memory allocation but does not implement any actual memory reclamation mechanism. Once the available Java heap is exhausted, the JVM will shut down.</p></blockquote><p>官方文档原文明确指出该GC只处理内存分配，不进行任何内存回收动作(那还叫啥GC…)，并且一旦堆内存耗尽，JVM将GG。<br>使用场景官方文档给出了几个用途：</p><ol><li>做其他GC的性能测试背景板(对比)</li><li>内存压力测试，应该是一些特殊应用可以用到，测试出内存使用的上限，方便启动参数进行内存分配</li><li>声明周期极短的应用，一些应用可以通过进程的消亡快速的释放资源，该场景下GC的内存回收则显得多此一举(不确定理解的是否正确)</li><li>…</li></ol><h1 id="删除-Java-EE-和-CORBA-模块"><a href="#删除-Java-EE-和-CORBA-模块" class="headerlink" title="删除 Java EE 和 CORBA 模块"></a>删除 Java EE 和 CORBA 模块</h1><p>JDK9中声明过期的模块，本次进行了大范围的删除。如果有相关代码，版本迁移需要额外注意。</p><h1 id="对-HTTP-客户端-API-进行标准化"><a href="#对-HTTP-客户端-API-进行标准化" class="headerlink" title="对 HTTP 客户端 API 进行标准化"></a>对 HTTP 客户端 API 进行标准化</h1><p>有部分类和方法存在删除，版本迁移需要额外注意。</p><h1 id="Lambda-参数的局部变量语法"><a href="#Lambda-参数的局部变量语法" class="headerlink" title="Lambda 参数的局部变量语法"></a>Lambda 参数的局部变量语法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">var</span> x, <span class="keyword">var</span> y) -&gt; x.process(y)</span><br><span class="line">(x, y) -&gt; x.process(y)</span><br></pre></td></tr></table></figure><p>em…可能是为了补充之前lambda不用声明类型的”漏洞”？不使用<code>var</code>也没有什么问题，使用<code>var</code>还必须都使用，不能有入参无类型声明或指明类型，以下为错误用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">var</span> x, y) -&gt; x.process(y)         <span class="comment">// Cannot mix &#x27;var&#x27; and &#x27;no var&#x27; in implicitly typed lambda expression</span></span><br><span class="line">(<span class="keyword">var</span> x, <span class="type">int</span> y) -&gt; x.process(y)     <span class="comment">// Cannot mix &#x27;var&#x27; and manifest types in explicitly typed lambda expression</span></span><br></pre></td></tr></table></figure><h1 id="拓展两个加密算法实现-Curve25519-和-Curve448"><a href="#拓展两个加密算法实现-Curve25519-和-Curve448" class="headerlink" title="拓展两个加密算法实现(Curve25519 和 Curve448)"></a>拓展两个加密算法实现(Curve25519 和 Curve448)</h1><p>笔者未涉足过加密算法领域，不太清楚这两个拓展的具体含义，但是根据官方的文档和其他博主的分享，应该是更安全更高效的算法。<br>官方示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KeyPairGenerator</span> <span class="variable">kpg</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;XDH&quot;</span>);</span><br><span class="line"><span class="type">NamedParameterSpec</span> <span class="variable">paramSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamedParameterSpec</span>(<span class="string">&quot;X25519&quot;</span>);</span><br><span class="line">kpg.initialize(paramSpec); <span class="comment">// equivalent to kpg.initialize(255)</span></span><br><span class="line"><span class="comment">// alternatively: kpg = KeyPairGenerator.getInstance(&quot;X25519&quot;)</span></span><br><span class="line"><span class="type">KeyPair</span> <span class="variable">kp</span> <span class="operator">=</span> kpg.generateKeyPair();</span><br><span class="line"></span><br><span class="line"><span class="type">KeyFactory</span> <span class="variable">kf</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;XDH&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">u</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">XECPublicKeySpec</span> <span class="variable">pubSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XECPublicKeySpec</span>(paramSpec, u);</span><br><span class="line"><span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> kf.generatePublic(pubSpec);</span><br><span class="line"></span><br><span class="line"><span class="type">KeyAgreement</span> <span class="variable">ka</span> <span class="operator">=</span> KeyAgreement.getInstance(<span class="string">&quot;XDH&quot;</span>);</span><br><span class="line">ka.init(kp.getPrivate());</span><br><span class="line">ka.doPhase(pubKey, <span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] secret = ka.generateSecret();</span><br></pre></td></tr></table></figure><h1 id="Unicode-10持续更新"><a href="#Unicode-10持续更新" class="headerlink" title="Unicode 10持续更新"></a>Unicode 10持续更新</h1><p>支持到JDK11发布时的Unicode 10，下列四个未涉及：</p><ol><li>UTS #10，Unicode 排序算法</li><li>UTS #39，Unicode 安全机制</li><li>UTS #46，Unicode IDNA 兼容性处理</li><li>UTS #51，Unicode 表情符号</li></ol><h1 id="Flight-Recorder-飞行记录仪"><a href="#Flight-Recorder-飞行记录仪" class="headerlink" title="Flight Recorder(飞行记录仪)"></a>Flight Recorder(飞行记录仪)</h1><p>好用的性能分析工具，官方说不会超过1%的性能消耗，看起来是可以在生产环境中使用的，但实际还是慎重，除非特殊情况，临时需要该工具进行问题分析，否则不建议常驻。<code>-XX:StartFlightRecording</code>启动参数开启。<br>读取jmr文件工具:<a href="https://github.com/openjdk/jmc">jmc</a></p><h1 id="拓展新的加密算法实现-ChaCha20-和-Poly1305"><a href="#拓展新的加密算法实现-ChaCha20-和-Poly1305" class="headerlink" title="拓展新的加密算法实现(ChaCha20 和 Poly1305)"></a>拓展新的加密算法实现(ChaCha20 和 Poly1305)</h1><p>这两个加密算法已经是广泛使用，JDK11的该更新算是”紧跟潮流”。</p><h1 id="启动单文件源代码程序"><a href="#启动单文件源代码程序" class="headerlink" title="启动单文件源代码程序"></a>启动单文件源代码程序</h1><p>看起来和JShell一样，降低部分场景下的Java使用成本。除了一些特殊的小型应用使用场景，不建议使用该功能，哪怕是在学习Java的前期。</p><h1 id="低开销堆内存分配管理"><a href="#低开销堆内存分配管理" class="headerlink" title="低开销堆内存分配管理"></a>低开销堆内存分配管理</h1><p>对于堆内存管理的一个优化方案，甚至可以查看Java对象的存活信息。</p><h1 id="传输层安全性-TLS-升至1-3"><a href="#传输层安全性-TLS-升至1-3" class="headerlink" title="传输层安全性 (TLS)升至1.3"></a>传输层安全性 (TLS)升至1.3</h1><p>对之前的版本如1.2存在兼容性风险，建议全局统一升级。</p><h1 id="新GC：ZGC（实验性）"><a href="#新GC：ZGC（实验性）" class="headerlink" title="新GC：ZGC（实验性）"></a>新GC：ZGC（实验性）</h1><ol><li>GC停顿时间优化效果明显</li><li>GC停顿时间不会因堆大小有明显变化</li><li>JDK11不可以在生产环境中使用</li></ol><h1 id="弃用-Nashorn-JavaScript-引擎"><a href="#弃用-Nashorn-JavaScript-引擎" class="headerlink" title="弃用 Nashorn JavaScript 引擎"></a>弃用 Nashorn JavaScript 引擎</h1><p>未删除，仅通过<code>@Deprecated(forRemoval=true)</code>标记，未来版本可能会删除。</p><h1 id="弃用-Pack200-工具和-API"><a href="#弃用-Pack200-工具和-API" class="headerlink" title="弃用 Pack200 工具和 API"></a>弃用 Pack200 工具和 API</h1><p>和Java应用程序打包有关，属于压缩工具。一句话总结就是跟不上时代的脚步而被抛弃，JDK11仅标记<code>@Deprecated(forRemoval=true)</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/projects/jdk/11/&quot;&gt;jdk11特性列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bbsmax.com/A/QW5Ybg23dm/&quot;&gt;nest class和inner class的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1165256&quot;&gt;JDK11中增加了一个常量池类型：CONSTANT_Dynamic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.techwell.com/techwell-insights/2021/08/new-jvm-features-jdk-11&quot;&gt;new-jvm-features-jdk-11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.javacodegeeks.com/2018/08/hands-on-java-constantdynamic.html&quot;&gt;hands-on-java-constantdynamic&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;直接影响编码的功能几乎没有，大多数都是幕后工作的更新&lt;/li&gt;
&lt;li&gt;ZGC是一个核心内容，不过JDK11中是实验版&lt;/li&gt;
&lt;li&gt;JFR的加入方便了性能监控，建议上手实际操作几次，非常好用&lt;/li&gt;
&lt;li&gt;加密算法的几个新增实现未进行深入了解(未涉足领域，功力不足)</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK11" scheme="http://janwarlen.com/tags/JDK11/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK10</title>
    <link href="http://janwarlen.com/2022/06/16/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK10/"/>
    <id>http://janwarlen.com/2022/06/16/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK10/</id>
    <published>2022-06-15T19:38:41.000Z</published>
    <updated>2022-06-21T15:50:12.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://openjdk.org/projects/jdk/10/">JDK10特性列表</a></li><li><a href="https://shipilev.net/jvm/anatomy-quarks/16-megamorphic-virtual-calls/">megamorphic-virtual-calls</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/class-data-sharing.html">class-data-sharing</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javah.html">javah</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>JDK10的更新内容不多，核心就是<code>局部变量类型推断</code></li><li><code>Heap Allocation on Alternative Memory Devices</code>可能在未来会发挥相当重要的作用，不过是在运维层面了，是和机器的物理架构相结合的技术</li><li>有一些面对运行性能的优化，比如<code>G1的全并行</code>、<code>Thread-Local Handshakes</code>和<code>基于 Java 的 JIT 编译器</code>，分别针对垃圾回收、多线程场景、代码编译，并且这几项技术启用需要做额外的性能测试，以确认是否在生产环境使用</li></ol><span id="more"></span><h1 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h1><p>简单来说就是在部分场景里，降低了对类型的关注度，减轻编码负担</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  <span class="comment">// infers ArrayList&lt;String&gt;</span></span><br><span class="line"><span class="type">var</span> <span class="variable">stream</span> <span class="operator">=</span> list.stream();          <span class="comment">// infers Stream&lt;String&gt;</span></span><br></pre></td></tr></table></figure><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ol><li>var声明对象必须初始化，初始化也不可以为null<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cannot infer type: &#x27;var&#x27; on variable without initializer</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// Cannot infer type: variable initializer is &#x27;null&#x27;</span></span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li>var声明对象不可接收lambda表达式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cannot infer type: lambda expression requires an explicit target type</span></span><br><span class="line"><span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> () -&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li>var声明对象初始化数组时必须指定数组类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器会直接异常提示</span></span><br><span class="line"><span class="comment">// var k = &#123; 1 , 2 &#125;;</span></span><br><span class="line"><span class="type">var</span> <span class="variable">k</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol><h1 id="JDK源码整合为一个工程"><a href="#JDK源码整合为一个工程" class="headerlink" title="JDK源码整合为一个工程"></a>JDK源码整合为一个工程</h1><p>从<a href="https://openjdk.org/jeps/296">特性详情页</a>来看，该特性主要是为了bug修复方便，因为多工程模式下，存在部分bug涉及多工程，这样bug的修复提交就不是原子性的了，工程合并之后，bug修复提交就是原子性操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ROOT/jdk/src/java.base</span><br><span class="line">...</span><br><span class="line">$ROOT/langtools/src/java.compiler</span><br><span class="line">...</span><br><span class="line">变更为</span><br><span class="line">$ROOT/src/java.base</span><br><span class="line">$ROOT/src/java.compiler</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="垃圾收集器接口"><a href="#垃圾收集器接口" class="headerlink" title="垃圾收集器接口"></a>垃圾收集器接口</h1><p>虚拟机内部的代码重构，对外部不影响，方便JDK的内部GC开发人员扩展垃圾收集器和虚拟机开发人员更容易理解垃圾收集器相关代码(容易找到，之前的代码是散落的，甚至部分由if-else维护)，不过以下这段原文可能需要额外注意</p><blockquote><p>There is a risk that performance could be harmed, for example if additional virtual calls would be introduced. This risk can be mitigated by continuous performance testing.</p></blockquote><p>大致意思是性能可能会受到影响，并用<code>virtual calls</code>的额外调用举例。因此JDK10+版本需要多做性能测试，以避免该影响。关于<code>virtual call</code>可参考<a href="https://shipilev.net/jvm/anatomy-quarks/16-megamorphic-virtual-calls/">megamorphic-virtual-calls</a>，大体场景可以理解为父类声明变量接收子类对象，调用函数时，因是在运行时确定，该情况可以称作<code>virtual call</code>。(主要还是看编译后的字节码，反编译为汇编时，看到指令<code>invokevirtual</code>基本就是了)</p><h1 id="G1的GC全并行"><a href="#G1的GC全并行" class="headerlink" title="G1的GC全并行"></a>G1的GC全并行</h1><p>万恶的JDK9将G1设置为默认垃圾收集器的尾声，在JDK10之前，<code>mark-sweep-compact</code>的算法实现(<code>full GC</code>场景)采取的单线程，在JDK10中，该实现修改为多线程实现，线程数与年轻代和混合代(?Mixed)收集线程数一致，并且该线程数可通过启动参数<code>-XX:ParallelGCThreads</code>指定。<br>但是原文中有这么一句话</p><blockquote><p>The fact that G1 uses regions will most likely lead to more wasted space after a parallel full GC than for a single threaded one.</p></blockquote><p>具体没说是怎么样的浪费空间，内存是一定回收了的，我推测是并行可能会导致空间碎片比较多，影响后续内存使用</p><h1 id="CDS-Class-Data-Sharing-的应用级拓展"><a href="#CDS-Class-Data-Sharing-的应用级拓展" class="headerlink" title="CDS(Class-Data Sharing)的应用级拓展"></a>CDS(Class-Data Sharing)的应用级拓展</h1><p>CDS(Class-Data Sharing)在JDK5中引入(感兴趣可以研究<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/class-data-sharing.html">class-data-sharing</a>原文)<br>在JDK10中将JDK内部的CDS拓展到应用级别，可以指定类到归档文件(<code>archive file</code>)，可以有效的减少应用启动时间和内存消耗。但是根据原文描述，个人理解该技术仅限于多个Java应用程序在同一个系统镜像内运行，才可以有效的发挥作用，对于目前大多数公司的实际运行环境(一个应用一个镜像)来说，该技术没有什么实际意义。<br>JDK8&#x2F;JDK9已经有APPCDS的实现，因此在长期的测试中，基本不需要考虑风险和稳定性问题….</p><h1 id="Thread-Local-Handshakes"><a href="#Thread-Local-Handshakes" class="headerlink" title="Thread-Local Handshakes"></a>Thread-Local Handshakes</h1><p>实在不知道怎么翻译，用了原文，该技术是想通过减少全局安全点从而降低JVM的延迟，尤其是在GC领域。<br>没说具体实现，但在偏向锁、堆栈追踪、G1有良好的优化功能</p><h1 id="删除了javah"><a href="#删除了javah" class="headerlink" title="删除了javah"></a>删除了<code>javah</code></h1><p>功能被JDK8的javac的拓展功能所取代，在JDK10中才删除<br><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javah.html"><code>javah</code></a>就是当java代码调用native方法(C&#x2F;C++本地实现)时，生成对应的文件头，方便JVM运行时调用<br>应该是安卓场景会用到</p><h1 id="Unicode拓展"><a href="#Unicode拓展" class="headerlink" title="Unicode拓展"></a>Unicode拓展</h1><p>增强了类<code>java.util.Locale</code>及相关API拓展支持<a href="https://www.rfc-editor.org/rfc/bcp/bcp47.txt">bcp47</a>.<br>JDK7就已经在日期和数字上针对<code>bcp 47</code>进行了补充实现，在JDK10中进行了更完整的拓展实现。</p><blockquote><p>An IETF BCP 47 language tag is a standardized code or tag that is used to identify human languages in the Internet.<br>                                                            ——-wiki</p></blockquote><p>从wiki的这段话来理解就是各国语言的标识，在国际化场景中会有重要的作用，例如安卓…..</p><h1 id="Heap-Allocation-on-Alternative-Memory-Devices"><a href="#Heap-Allocation-on-Alternative-Memory-Devices" class="headerlink" title="Heap Allocation on Alternative Memory Devices"></a>Heap Allocation on Alternative Memory Devices</h1><p>痛苦，没办法精确的翻译，还没确定<code>Alternative Memory Devices</code>指代的是什么，从原文的理解来说，应该是一台物理机器有多个内存系统，尤其是针对<code>non-DRAM</code>内存系统，可以通过指令<code>-XX:AllocateHeapAt=&lt;path&gt;</code>去辅助JVM在这种类型的内存上进行堆分配。<br>这应该是一项未来将会发挥很大作用的功能，尤其是在简单了解<code>NV-DIMM</code>之后。这算是硬件适配。</p><h1 id="基于-Java-的-JIT-编译器"><a href="#基于-Java-的-JIT-编译器" class="headerlink" title="基于 Java 的 JIT 编译器"></a>基于 Java 的 JIT 编译器</h1><p>可以预先把Java代码编译为本地代码，以提高运行效率。通过<code>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code>开启。<br>存在以下风险：</p><ol><li>启动会变慢</li><li>堆的使用将会难以评估<br>需要额外的性能测试指标去覆盖，以确认是否需要开启该功能。</li></ol><h1 id="根证书"><a href="#根证书" class="headerlink" title="根证书"></a>根证书</h1><p>为了推广<code>OpenJDK</code>和降低<code>OpenJDK</code>与<code>Oracle JDK</code>差异的。</p><h1 id="基于时间的发布版本控制"><a href="#基于时间的发布版本控制" class="headerlink" title="基于时间的发布版本控制"></a>基于时间的发布版本控制</h1><p>新的JDK版本号规则，影响不大，直观影响就是<code>java -v</code>显示信息会和以往不同…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$FEATURE.$INTERIM.$UPDATE.$PATCH</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://openjdk.org/projects/jdk/10/&quot;&gt;JDK10特性列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shipilev.net/jvm/anatomy-quarks/16-megamorphic-virtual-calls/&quot;&gt;megamorphic-virtual-calls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/class-data-sharing.html&quot;&gt;class-data-sharing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javah.html&quot;&gt;javah&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;JDK10的更新内容不多，核心就是&lt;code&gt;局部变量类型推断&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Heap Allocation on Alternative Memory Devices&lt;/code&gt;可能在未来会发挥相当重要的作用，不过是在运维层面了，是和机器的物理架构相结合的技术&lt;/li&gt;
&lt;li&gt;有一些面对运行性能的优化，比如&lt;code&gt;G1的全并行&lt;/code&gt;、&lt;code&gt;Thread-Local Handshakes&lt;/code&gt;和&lt;code&gt;基于 Java 的 JIT 编译器&lt;/code&gt;，分别针对垃圾回收、多线程场景、代码编译，并且这几项技术启用需要做额外的性能测试，以确认是否在生产环境使用&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK10" scheme="http://janwarlen.com/tags/JDK10/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-JDK9</title>
    <link href="http://janwarlen.com/2022/06/11/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK9/"/>
    <id>http://janwarlen.com/2022/06/11/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK9/</id>
    <published>2022-06-11T10:05:32.000Z</published>
    <updated>2022-06-21T15:50:12.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://docs.oracle.com/javase/9/">Oracle Java9官方文档</a></li><li><a href="https://www.oracle.com/java/technologies/javase/9-relnotes.html">JDK 9 Release Notes</a></li><li><a href="http://openjdk.java.net/projects/jigsaw/quick-start">Module System Quick-Start Guide</a></li><li><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-7744EF96-5899-4FB2-B34E-86D49B2E89B6">JDK9迁移指南</a></li><li><a href="http://openjdk.java.net/jeps/213">Milling Project Coin</a></li><li><a href="http://openjdk.java.net/jeps/282">jlink: The Java Linker</a></li><li><a href="http://openjdk.java.net/jeps/222">The Java Shell</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>本文仅涉及部分JDK9变更，完整可查看官方文档<a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm">Standard Edition What’s New in Oracle JDK 9</a></li><li>除了模块化，其他改动对日常开发影响不多，可以着重关注模块化和接口私有函数</li></ol><span id="more"></span><h1 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="ModularDemo"><a href="#ModularDemo" class="headerlink" title="ModularDemo"></a><a href="https://github.com/JanWarlen/ModularDemo">ModularDemo</a></h3><p>因目前Oracle开放的JDK下载版本仅有8&#x2F;11&#x2F;17&#x2F;18，因此该项目通过JDK18编译JDK9(Project language level设置为9)模拟</p><h4 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h4><p><img src="http://img.janwarlen.com/blog/Modular-%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="Modular"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><code>common</code>与<code>service</code>是在 Maven 层面上的子模块,JDK9的模块化主要通过类<code>module-info.java</code></li><li>每个工程(模块)仅可有一个<code>module-info.java</code></li><li>对外开放的最小粒度是<code>package</code>，无法以类作为最小单位，如果有类不愿对外开放，建议迁移到单独的包中</li><li>打包后，虽然<code>common</code>没有开放<code>intern</code>包，但是最终common.jar中还是会有<code>intern</code>中的类</li><li>如果类不惜那个对外开放，但是其中部分功能还需要对外使用，可以单独在对外开放的包中新建一个类，作为转发调用</li><li>从初步的使用感觉，目前仅在权限控制方面有明显的作用</li><li><code>maven-compiler-plugin</code>仅在<code>3.8.0+</code>才支持<code>module</code>(可查看<code>ModularDemo/pom.xml</code>)</li></ol><h1 id="jlink"><a href="#jlink" class="headerlink" title="jlink"></a>jlink</h1><p>可以自定义Java程序运行时的JRE环境</p><h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jlink --module-path &lt;modulepath&gt; --add-modules &lt;modules&gt; --limit-modules &lt;modules&gt; --output &lt;path&gt;</span><br><span class="line">module-path: 指的是你自定义的JRE环境所有需要的module所处的路径</span><br><span class="line">add-modules: 在 module-path 中，你需要那些module</span><br><span class="line">limit-modules: 根据module名称限制搜寻范围</span><br><span class="line">output: 自定义JRE的输出路径</span><br><span class="line"></span><br><span class="line">jlink --output service/src/main/resources/jre --module-path &quot;service/src/main/resources&quot; --add-modules common</span><br><span class="line">我将入门案例中的common的jar包拷贝到service/src/main/resources中，因此 module-path 就是 &quot;service/src/main/resources&quot;，而因 service 仅需要 common 一个模块，因此我只添加了 common</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ol><li>自定义的JRE环境没有无关的jar包，因此启动内存消耗会少<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;totalMemory:&quot;</span> + Runtime.getRuntime().totalMemory()/ (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;freeMemory:&quot;</span> + Runtime.getRuntime().freeMemory()/ (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;maxMemory:&quot;</span> + Runtime.getRuntime().maxMemory()/ (<span class="number">1024</span> * <span class="number">1024</span>));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(base) MacBook-Pro ModularDemo % ./service/src/main/resources/jre/bin/java -jar service/target/service-1.0-SNAPSHOT.jar</span><br><span class="line">hello</span><br><span class="line">this is private class.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">false</span><br><span class="line">totalMemory:512</span><br><span class="line">freeMemory:510</span><br><span class="line">maxMemory:8192</span><br><span class="line">(base) MacBook-Pro ModularDemo % java -jar service/target/service-1.0-SNAPSHOT.jar </span><br><span class="line">hello</span><br><span class="line">this is private class.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">false</span><br><span class="line">totalMemory:520</span><br><span class="line">freeMemory:514</span><br><span class="line">maxMemory:8192</span><br></pre></td></tr></table></figure></li><li>可以根据应用自定义不同的JRE，而不用将所有 module 对全部应用开放</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>初步感受，该功能在嵌入式领域可以发挥非常重要的作用，在服务器端程序，作用可能没有那么明显</li><li>最好可以搭配<a href="http://openjdk.java.net/jeps/200">The Modular JDK</a>、<a href="http://openjdk.java.net/jeps/201">Modular Source Code</a>、<a href="http://openjdk.java.net/jeps/220">Modular Run-Time Images</a>一起使用，效果更佳(此处埋坑，以后有时间再回头来研究这三个)</li></ol><h1 id="正则-调整作用范围"><a href="#正则-调整作用范围" class="headerlink" title="正则^调整作用范围"></a>正则<code>^</code>调整作用范围</h1><p>将作用到整个表达式，而不是第一个group</p><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[^a-b[c-d]e-f]&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">a</span> <span class="operator">=</span> compile.matcher(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">c</span> <span class="operator">=</span> compile.matcher(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// JDK8 false JDK9 false</span></span><br><span class="line">System.out.println(a.matches());</span><br><span class="line"><span class="comment">// JDK8 true JDK9 false</span></span><br><span class="line">System.out.println(c.matches());</span><br></pre></td></tr></table></figure><h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><p>可以在try外部声明变量，将变量名放在try中即可，但是该变量受<code>final or effectively final</code>规则限制，即在初始化完成后不可再次进行赋值操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Files.newInputStream(Paths.get(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> (in) &#123;</span><br><span class="line">    <span class="comment">// JDK8中该用法会有以下异常提示</span></span><br><span class="line">    <span class="comment">// Resource references are not supported at language level &#x27;8&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名类的泛型推断"><a href="#匿名类的泛型推断" class="headerlink" title="匿名类的泛型推断"></a>匿名类的泛型推断</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InferredType</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// JDK8 中会有如下异常提示</span></span><br><span class="line">    <span class="comment">// Class &#x27;Anonymous class derived from InferredType&#x27; must either be declared abstract or implement abstract method &#x27;test(T)&#x27; in &#x27;InferredType&#x27;</span></span><br><span class="line">    InferredType&lt;String&gt; inferredType = <span class="keyword">new</span> <span class="title class_">InferredType</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String o)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="允许接口定义private方法"><a href="#允许接口定义private方法" class="headerlink" title="允许接口定义private方法"></a>允许接口定义private方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PrivateFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        func3();</span><br><span class="line">        <span class="comment">// JDK8+</span></span><br><span class="line">        System.out.println(<span class="string">&quot;默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">func3</span><span class="params">()</span> &#123;</span><br><span class="line">        func4();</span><br><span class="line">        System.out.println(<span class="string">&quot;私有默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态私有实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以起到优化重复代码的帮助</li></ol><h1 id="不可作为变量名"><a href="#不可作为变量名" class="headerlink" title="_不可作为变量名"></a><code>_</code>不可作为变量名</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// As of Java 9, &#x27;_&#x27; is a keyword, and may not be used as an identifier</span></span><br><span class="line"><span class="comment">// JDK8 是可以正常使用的，影响不大，几乎很少有场景会单独使用 _ 作为变量名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">_</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure><h1 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="comment">// 不用该注解，仅会导致编译器提示，不会异常</span></span><br><span class="line"><span class="comment">// 此注解用于泛型可变入参函数，JDK9是拓展至可声明private函数</span></span><br><span class="line"><span class="comment">//  Possible heap pollution from parameterized vararg type</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  &lt;T&gt; <span class="keyword">void</span> <span class="title function_">saveVarargs</span><span class="params">(T... params)</span> &#123;</span><br><span class="line">    Arrays.stream(params).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Class文件版本号变动至53"><a href="#Class文件版本号变动至53" class="headerlink" title="Class文件版本号变动至53"></a>Class文件版本号变动至53</h1><h1 id="编译旧版本范围变动"><a href="#编译旧版本范围变动" class="headerlink" title="编译旧版本范围变动"></a>编译旧版本范围变动</h1><blockquote><p>The javac command no longer supports -source or-target values for releases before 6&#x2F;1.6. However, older class files are still readable by javac. Source code for an older release can be ported to a newer source level. To generate class files usable by releases older than JDK 6, a javac from a JDK 6, 7, or 8 release family can be used.<br><a href="https://openjdk.java.net/jeps/182">JEP 182</a> documents the policy for retiring old -source and -target options.  </p></blockquote><p>JDK9在使用javac编译java文件时，指定java的版本仅支持*1.6+*，不再支持编译到1.5以及更早期的版本</p><h1 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h1><p>引用官方原文</p><blockquote><p>Immediate feedback is important when learning a programming language and its APIs. The number one reason schools cite for moving away from Java as a teaching language is that other languages have a “REPL” and have far lower bars to an initial “Hello, world!” program. A Read-Eval-Print Loop (REPL) is an interactive programming tool which loops, continually reading user input, evaluating the input, and printing the value of the input or a description of the state change the input caused. Scala, Ruby, JavaScript, Haskell, Clojure, and Python all have REPLs and all allow small initial programs. JShell adds REPL functionality to the Java platform.<br>Exploration of coding options is also important for developers prototyping code or investigating a new API. Interactive evaluation is vastly more efficient in this regard than edit&#x2F;compile&#x2F;execute and System.out.println.<br>Without the ceremony of class Foo { public static void main(String[] args) { … } }, learning and exploration is streamlined.</p></blockquote><p>大致含义是降低Java学习的入门门槛，可以更方便的测试API<br>吐槽:</p><ol><li>对于习惯了ide的代码提示和代码模板(<code>code templates</code>)来说，突然使用<code>jshell</code>会有些难受</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/&quot;&gt;Oracle Java9官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/java/technologies/javase/9-relnotes.html&quot;&gt;JDK 9 Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/quick-start&quot;&gt;Module System Quick-Start Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-7744EF96-5899-4FB2-B34E-86D49B2E89B6&quot;&gt;JDK9迁移指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/213&quot;&gt;Milling Project Coin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/282&quot;&gt;jlink: The Java Linker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/222&quot;&gt;The Java Shell&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;本文仅涉及部分JDK9变更，完整可查看官方文档&lt;a href=&quot;https://docs.oracle.com/javase/9/whatsnew/toc.htm&quot;&gt;Standard Edition What’s New in Oracle JDK 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;除了模块化，其他改动对日常开发影响不多，可以着重关注模块化和接口私有函数&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="模块系统" scheme="http://janwarlen.com/tags/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="REPL (JShell)" scheme="http://janwarlen.com/tags/REPL-JShell/"/>
    
    <category term="JDK9" scheme="http://janwarlen.com/tags/JDK9/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-StreamAPI</title>
    <link href="http://janwarlen.com/2022/06/08/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-StreamAPI/"/>
    <id>http://janwarlen.com/2022/06/08/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-StreamAPI/</id>
    <published>2022-06-08T12:13:11.000Z</published>
    <updated>2022-06-21T15:50:12.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h3><ol><li><a href="https://dev.java/learn/the-stream-api/">Java官方学习手册-Stream</a></li><li><a href="https://github.com/CarpenterLee/JavaLambdaInternals">GitHub-CarpenterLee-JavaLambdaInternals</a></li><li><a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html">Oracle关于parallelism官方文档</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description">Oracle关于Stream包官方描述文档</a><span id="more"></span></li></ol><h2 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol><li>Stream API 是关于向 JDK 提供众所周知的 map-filter-reduce 算法的实现</li><li><code>map</code>只会变更对象的类型，不会改变对象集合的数量</li><li><code>filter</code>只会改变对象集合的数量，而不会改变其中对象的类型</li><li><code>reduce</code>允许针对数据流构建任何你想构建的数据结构</li></ol><h4 id="案例-统计所有人口超过10w的城市人口总和"><a href="#案例-统计所有人口超过10w的城市人口总和" class="headerlink" title="案例 - 统计所有人口超过10w的城市人口总和"></a>案例 - 统计所有人口超过10w的城市人口总和</h4><h5 id="城市类定义"><a href="#城市类定义" class="headerlink" title="城市类定义"></a>城市类定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">City</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">City</span><span class="params">(String name, <span class="type">int</span> population)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.population = population;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 城市名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 城市人口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> population;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPopulation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> population;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPopulation</span><span class="params">(<span class="type">int</span> population)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.population = population;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;City&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, population=&quot;</span> + population +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;City&gt; cities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">City</span> <span class="variable">city1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;1&quot;</span>, <span class="number">50_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;2&quot;</span>, <span class="number">2_100_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;3&quot;</span>, <span class="number">90_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;4&quot;</span>, <span class="number">130_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;5&quot;</span>, <span class="number">1_000_000</span>);</span><br><span class="line">cities.add(city1);</span><br><span class="line">cities.add(city2);</span><br><span class="line">cities.add(city3);</span><br><span class="line">cities.add(city4);</span><br><span class="line">cities.add(city5);</span><br></pre></td></tr></table></figure><h5 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (City city : cities) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">population</span> <span class="operator">=</span> city.getPopulation();</span><br><span class="line">    <span class="keyword">if</span> (population &gt; <span class="number">100_000</span>) &#123;</span><br><span class="line">        sum += population;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure><h5 id="StreamApi写法"><a href="#StreamApi写法" class="headerlink" title="StreamApi写法"></a>StreamApi写法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步先创建流</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> cities.stream()</span><br><span class="line"><span class="comment">// 第二步 将城市集合转换为人口集合</span></span><br><span class="line">        .mapToInt(City::getPopulation)</span><br><span class="line"><span class="comment">// 第三步 过滤人口超过 10w 的城市人口</span></span><br><span class="line">        .filter(population -&gt; population &gt; <span class="number">100_000</span>)</span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line">        .sum();</span><br><span class="line">System.out.println(<span class="string">&quot;Stream Sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h4><h5 id="创建一个空流"><a href="#创建一个空流" class="headerlink" title="创建一个空流"></a>创建一个空流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.empty()</span><br></pre></td></tr></table></figure><p>一般场景不会用到，通常与<code>flatMap</code>结合使用，过滤不需要的元素</p><h5 id="从可变参数或数组创建流"><a href="#从可变参数或数组创建流" class="headerlink" title="从可变参数或数组创建流"></a>从可变参数或数组创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Arrays.stream(array)</span><br></pre></td></tr></table></figure><h5 id="给定规则创建流并持续添加元素"><a href="#给定规则创建流并持续添加元素" class="headerlink" title="给定规则创建流并持续添加元素"></a>给定规则创建流并持续添加元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Supplier&lt;T&gt; s)</span><br><span class="line"></span><br><span class="line">Stream.generate(() -&gt; <span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><p>需注意的是，该方法将会无限制的添加元素进入流中，需要搭配<code>limit</code>使用，避免<code>OOM</code></p><h5 id="创建符合一定规则的流"><a href="#创建符合一定规则的流" class="headerlink" title="创建符合一定规则的流"></a>创建符合一定规则的流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// seed是第一个元素， UnaryOperator则是所有后续元素将要遵守的规则</span></span><br><span class="line">Stream.iterate(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">Stream.iterate(<span class="string">&quot;+&quot;</span>, s -&gt; s + <span class="string">&quot;+&quot;</span>)</span><br><span class="line"><span class="comment">// +</span></span><br><span class="line"><span class="comment">// ++</span></span><br><span class="line"><span class="comment">// +++</span></span><br><span class="line"><span class="comment">// ++++</span></span><br><span class="line"><span class="comment">// +++++</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>通常需要搭配<code>limit</code>使用,<code>Java9</code>该方法添加了重载，添加了入参，可自定义停止创建规则，当规则符合false则停止创建流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="string">&quot;+&quot;</span>, s -&gt; s.length() &lt;= <span class="number">5</span>, s -&gt; s + <span class="string">&quot;+&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="创建一个在一定范围的数字流"><a href="#创建一个在一定范围的数字流" class="headerlink" title="创建一个在一定范围的数字流"></a>创建一个在一定范围的数字流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">IntStream.range(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">IntStream.rangeClosed(<span class="number">0</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h5 id="创建随机数流"><a href="#创建随机数流" class="headerlink" title="创建随机数流"></a>创建随机数流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10L</span>);</span><br><span class="line">random.ints();</span><br><span class="line">random.ints(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// [0, 7)</span></span><br><span class="line">random.ints(<span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// [2,9)</span></span><br><span class="line">random.ints(<span class="number">10</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>相对应的，还有<code>long</code>与<code>double</code></p><h5 id="通过String创建char字符流"><a href="#通过String创建char字符流" class="headerlink" title="通过String创建char字符流"></a>通过String创建char字符流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">chars</span> <span class="operator">=</span> test.chars();</span><br></pre></td></tr></table></figure><h5 id="读取文件创建流"><a href="#读取文件创建流" class="headerlink" title="读取文件创建流"></a>读取文件创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">log</span> <span class="operator">=</span> Path.of(<span class="string">&quot;/tmp/debug.log&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(log)) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="variable">warnings</span> <span class="operator">=</span> </span><br><span class="line">        lines.filter(line -&gt; line.contains(<span class="string">&quot;WARNING&quot;</span>))</span><br><span class="line">             .count();</span><br><span class="line">    System.out.println(<span class="string">&quot;Number of warnings = &quot;</span> + warnings);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// do something with the exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过正则创建流"><a href="#通过正则创建流" class="headerlink" title="通过正则创建流"></a>通过正则创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;For there is good news yet to hear and fine things to be seen&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot; &quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = pattern.splitAsStream(sentence);</span><br></pre></td></tr></table></figure><h5 id="通过Builder创建流"><a href="#通过Builder创建流" class="headerlink" title="通过Builder创建流"></a>通过Builder创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream.Builder&lt;String&gt; builder = Stream.&lt;String&gt;builder();</span><br><span class="line"></span><br><span class="line">builder.add(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">       .add(<span class="string">&quot;two&quot;</span>)</span><br><span class="line">       .add(<span class="string">&quot;three&quot;</span>)</span><br><span class="line">       .add(<span class="string">&quot;four&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = builder.build();</span><br></pre></td></tr></table></figure><h4 id="常用方法及功能描述"><a href="#常用方法及功能描述" class="headerlink" title="常用方法及功能描述"></a>常用方法及功能描述</h4><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>filter</td><td>根据用户自定义条件过滤Stream中所有数据，符合条件的通过</td></tr><tr><td>map</td><td>使用用户自定义的功能代码应用到每一个元素，常规用于类型转换</td></tr><tr><td>mapToInt</td><td>通过用户自定义的代码将当前Stream转换为IntStream(通常是为了调用IntStream额外的接口，如<code>sum</code>)</td></tr><tr><td>mapToLong</td><td>通过用户自定义代码将当前Stream转换为LongStream</td></tr><tr><td>mapToDouble</td><td>通过用户自定义代码将当前Stream转换为DoublegStream</td></tr><tr><td>flatMap</td><td>将Stream中的多维元素降一维，如<code>Stream&lt;List&lt;City&gt;&gt;</code>转换为<code>Stream&lt;City&gt;</code></td></tr><tr><td>flatMapToInt</td><td>效果同<code>flatMap</code>，仅可用于<code>int</code>类型,如 <code>Stream&lt;int[]&gt;</code> 转换为 <code>Stream&lt;int&gt;</code></td></tr><tr><td>flatMapToLong</td><td>效果同 <code>flatMapToInt</code> ，类型限制为<code>long</code></td></tr><tr><td>flatMapToDouble</td><td>效果同<code>flatMapToInt</code>，类型限制为<code>double</code></td></tr><tr><td>distinct</td><td>对数据流进行去重，重复判定由<code>Object.equals(Object)</code>确认</td></tr><tr><td>sorted</td><td>将流中元素根据用户实现<code>Comparable</code>内容进行自然排序，若类型未实现该接口，则抛出异常<code>java.lang.ClassCastException</code></td></tr><tr><td>sorted(Comparator&lt;? super T&gt; comparator)</td><td>重载函数，根据入参的自定义规则进行自然排序</td></tr><tr><td>peek</td><td>使用用户自定义操作应用到流中每一个元素</td></tr><tr><td>limit</td><td>根据用户自定义长度，对流进行截断</td></tr><tr><td>skip</td><td>从流开头跳过用户给定长度，如果流元素数不够，则流将会被清空</td></tr><tr><td>forEach</td><td>将用户自定义操作应用到流中每一个元素</td></tr><tr><td>forEachOrdered</td><td>通常在<code>parallel stream</code>中使用，对流按照给定顺序进行元素操作</td></tr><tr><td>toArray</td><td>将流中元素组成数组返回,返回<code>Object[]</code></td></tr><tr><td>toArray(IntFunction&lt;A[]&gt; generator)</td><td>重载函数，可由用户指定数组类型，使用方式<code>toArray(String[]::new)</code></td></tr><tr><td>min&#x2F;max</td><td>根据自定义的<code>Comparator</code>实现，寻找流中最小&#x2F;最大元素</td></tr><tr><td>count</td><td>统计流中元素数量</td></tr><tr><td>anyMatch</td><td>根据用户自定义判断条件，判断流中是否有任意符合元素</td></tr><tr><td>allMatch</td><td>判断流中元素是否全部符合自定义条件</td></tr><tr><td>noneMatch</td><td>判断流中元素是否全部不符合自定义条件</td></tr><tr><td>findFirst</td><td>返回流中第一个元素,<code>parallelStream</code>中将无法保证根据给定顺序确认第一个</td></tr><tr><td>findAny</td><td>返回流中任意一个元素,<code>Stream</code>中始终返回第一个,<code>parallelStream</code>中将会任意返回</td></tr><tr><td>concat</td><td>将两个流合并为一个</td></tr></tbody></table><h5 id="IntStream-x2F-LongStream-x2F-DoubleStream"><a href="#IntStream-x2F-LongStream-x2F-DoubleStream" class="headerlink" title="IntStream&#x2F;LongStream&#x2F;DoubleStream"></a>IntStream&#x2F;LongStream&#x2F;DoubleStream</h5><p>相对比常规Stream，此三种流额外实现几种方法</p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>sum</td><td>将流中元素求和</td></tr><tr><td>average</td><td>求平均值</td></tr><tr><td>min</td><td>最小值(无需提供<code>Comparator</code>实现)</td></tr><tr><td>max</td><td>最大值(无需提供<code>Comparator</code>实现)</td></tr><tr><td>summaryStatistics</td><td>返回统计结果，包含元素个数、总和、最大值、最小值</td></tr></tbody></table><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>reduce</code>操作一般是处理一组数据生成一个值，上文中提及的<code>sum</code>&#x2F;<code>min</code>&#x2F;<code>max</code>&#x2F;<code>count</code>都是<code>reduce</code>操作，因这些方法使用频繁，因此被单独设置一个方法以方便使用</p><h5 id="找最大值"><a href="#找最大值" class="headerlink" title="找最大值"></a>找最大值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; ints = Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional = ints.reduce((i1, i2) -&gt; i1 &gt; i2 ? i1: i2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optional.isPresent()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + optional.get());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;No result could be computed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码中，<code>reduce</code>操作通过用户自定义的规则<code>(i1, i2) -&gt; i1 &gt; i2 ? i1: i2</code>对整个流中数据进行规约(reduce)，最终求得最大值</p><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure><p>其中，入参<code>BinaryOperator&lt;T&gt; accumulator</code>是由用户提供的函数，用于对所有元素进行操作，返回值会作为新元素添加到流中加入后续的规则应用，而该接口待实现的方法入参有两个，分别代表了当前元素与下一个元素，返回值会作为下一轮的当前元素；<br>入参<code>identity</code>是由用户自定义，相当于在流的开头，人工添加一个元素，需注意的是，在<code>parallel</code>模式中，<code>identity</code>极有可能被重复使用，因此需要额外注意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).parallel().reduce(<span class="number">9</span>, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i1=&quot;</span> + i1 + <span class="string">&quot; i2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 * <span class="number">10</span> + i2;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;reduce with identity=&quot;</span> + reduce);</span><br><span class="line"></span><br><span class="line"><span class="comment">// i1=9 i2=1</span></span><br><span class="line"><span class="comment">// i1=9 i2=2</span></span><br><span class="line"><span class="comment">// i1=9 i2=5</span></span><br><span class="line"><span class="comment">// i1=9 i2=3</span></span><br><span class="line"><span class="comment">// i1=9 i2=8</span></span><br><span class="line"><span class="comment">// i1=95 i2=93</span></span><br><span class="line"><span class="comment">// i1=92 i2=98</span></span><br><span class="line"><span class="comment">// i1=91 i2=1043</span></span><br><span class="line"><span class="comment">// i1=1018 i2=1953</span></span><br><span class="line"><span class="comment">// reduce with identity=12133</span></span><br></pre></td></tr></table></figure><p>入参<code>combiner</code>仅在<code>parallel</code>模式中才会生效，非<code>parallel</code>模式的流将不会执行，而<code>combiner</code>的两个入参，分别是两个<code>accumulator</code>的执行结果，并且<code>combiner</code>本身的执行结果也会加入新的<code>combiner</code>中等待执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">reduce1</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).parallel().reduce(<span class="number">7</span>, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i1=&quot;</span> + i1 + <span class="string">&quot; i2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 * <span class="number">10</span> + i2;</span><br><span class="line">&#125;, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a1=&quot;</span> + i1 + <span class="string">&quot; a2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 * <span class="number">10</span> + i2;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;reduce with identity &amp; combiner=&quot;</span> + reduce1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// i1=7 i2=1</span></span><br><span class="line"><span class="comment">// i1=7 i2=2</span></span><br><span class="line"><span class="comment">// i1=7 i2=8</span></span><br><span class="line"><span class="comment">// i1=7 i2=5</span></span><br><span class="line"><span class="comment">// i1=7 i2=3</span></span><br><span class="line"><span class="comment">// a1=72 a2=78</span></span><br><span class="line"><span class="comment">// a1=75 a2=73</span></span><br><span class="line"><span class="comment">// a1=71 a2=823</span></span><br><span class="line"><span class="comment">// a1=798 a2=1533</span></span><br><span class="line"><span class="comment">// reduce with identity &amp; combiner=9513</span></span><br></pre></td></tr></table></figure><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>大多数业务场景都涉及模型的转换，此时，<code>reduce</code>将会力不从心，而<code>collect</code>将会完美的解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; collect = Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>上述代码将<code>int</code>元素通过<code>collect</code>与<code>Collectors</code>转换为<code>&lt;List&gt;</code>集合，<code>collect</code>有重载的两个方法，分别如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line">&lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大多数情况下，我们都是使用<code>Collector</code>，因<code>Collectors</code>已经内置大多数使用频率较高的函数，如<code>toList</code>&#x2F;<code>toSet</code>&#x2F;<code>toCollection</code>&#x2F;<code>toMap</code>等，其中<code>toList</code>&#x2F;<code>toSet</code>最容易理解，即转为<code>List</code>&#x2F;<code>Set</code>，如果想转换为其他的集合，则可以使用<code>toCollection</code>，在调用时，同时声明想要转换的集合即可，如:<code>Collectors.toCollection(ArrayList::new)</code>即是转换为<code>ArrayList</code></p><h5 id="Collectors-toMap"><a href="#Collectors-toMap" class="headerlink" title="Collectors.toMap"></a>Collectors.toMap</h5><p>转换为<code>Map</code>稍微复杂一些，重载一共有以下三个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper, Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper)</span><br><span class="line">Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper, Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)</span><br><span class="line">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper, Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier)</span><br></pre></td></tr></table></figure><p>其中<code>keyMapper</code>与<code>valueMapper</code>，是针对流中对象操作，分别处理出Map中的key与value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;City&gt; cities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">City</span> <span class="variable">city1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;1&quot;</span>, <span class="number">50_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;2&quot;</span>, <span class="number">2_100_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;3&quot;</span>, <span class="number">90_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;4&quot;</span>, <span class="number">130_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;5&quot;</span>, <span class="number">1_000_000</span>);</span><br><span class="line">cities.add(city1);</span><br><span class="line">cities.add(city2);</span><br><span class="line">cities.add(city3);</span><br><span class="line">cities.add(city4);</span><br><span class="line">cities.add(city5);</span><br><span class="line">Map&lt;String, Integer&gt; collect1 = cities.stream().collect(Collectors.toMap(City::getName, City::getPopulation));</span><br><span class="line">collect1.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"></span><br><span class="line"><span class="comment">// key=1 value=50000</span></span><br><span class="line"><span class="comment">// key=2 value=2100000</span></span><br><span class="line"><span class="comment">// key=3 value=90000</span></span><br><span class="line"><span class="comment">// key=4 value=130000</span></span><br><span class="line"><span class="comment">// key=5 value=1000000</span></span><br></pre></td></tr></table></figure><h6 id="Key值冲突"><a href="#Key值冲突" class="headerlink" title="Key值冲突"></a>Key值冲突</h6><p>而在转换为Map的时候，通常会遇到<code>Key</code>值重复的问题，如果此时不加以特殊处理，则会导致旧值被覆盖问题，此时<code>mergeFunction</code>则发挥了重要的作用，入参是两个<code>value</code>，不是<code>key</code>，处理结果将作为新的<code>value</code>插入到Map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cities.add(<span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;1&quot;</span>, <span class="number">5</span>));</span><br><span class="line">Map&lt;String, Integer&gt; collect = cities.stream().collect(Collectors.toMap(City::getName, City::getPopulation, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i1=&quot;</span> + i1 + <span class="string">&quot; i2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 + i2;</span><br><span class="line">&#125;));</span><br><span class="line">collect.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"></span><br><span class="line"><span class="comment">// i1=50000 i2=5</span></span><br><span class="line"><span class="comment">// key=1 value=50005</span></span><br><span class="line"><span class="comment">// key=2 value=2100000</span></span><br><span class="line"><span class="comment">// key=3 value=90000</span></span><br><span class="line"><span class="comment">// key=4 value=130000</span></span><br><span class="line"><span class="comment">// key=5 value=1000000</span></span><br></pre></td></tr></table></figure><h6 id="指定Map类型"><a href="#指定Map类型" class="headerlink" title="指定Map类型"></a>指定Map类型</h6><p>有些场景中，我们需要使用其他<code>Map</code>类型，如<code>HashTable</code>，此时则需要<code>mapSupplier</code>的帮忙了，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他Map类型均可自由指定，但必须实现Map接口</span></span><br><span class="line">Hashtable&lt;String, Integer&gt; collect2 = cities.stream().collect(Collectors.toMap(City::getName, City::getPopulation, Integer::sum, Hashtable::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><h5 id="Collectors其他场景"><a href="#Collectors其他场景" class="headerlink" title="Collectors其他场景"></a>Collectors其他场景</h5><h6 id="Collectors-averagingInt"><a href="#Collectors-averagingInt" class="headerlink" title="Collectors.averagingInt"></a><code>Collectors.averagingInt</code></h6><p>求平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Double</span> <span class="variable">collect4</span> <span class="operator">=</span> cities.stream().collect(Collectors.averagingInt(City::getPopulation));</span><br></pre></td></tr></table></figure><h6 id="Collectors-collectingAndThen"><a href="#Collectors-collectingAndThen" class="headerlink" title="Collectors.collectingAndThen"></a><code>Collectors.collectingAndThen</code></h6><p>先通过第一个入参处理流，然后再通过第二个入参处理上一个处理结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出人口最多的城市</span></span><br><span class="line"><span class="type">String</span> <span class="variable">collect5</span> <span class="operator">=</span> cities.stream().collect(Collectors.collectingAndThen(Collectors.maxBy(Comparator.comparing(City::getPopulation)), e -&gt; e.map(City::getName).orElse(<span class="literal">null</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;largest city = &quot;</span> + collect5);</span><br></pre></td></tr></table></figure><h6 id="Collectors-joining"><a href="#Collectors-joining" class="headerlink" title="Collectors.joining"></a><code>Collectors.joining</code></h6><p>将流中所有字符串拼接为<code>String</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Stream.of(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;3&quot;</span>).collect(Collectors.joining()));</span><br><span class="line">System.out.println(Stream.of(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;3&quot;</span>).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">System.out.println(Stream.of(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;3&quot;</span>).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>)));</span><br><span class="line"><span class="comment">// 28153</span></span><br><span class="line"><span class="comment">// 2,8,1,5,3</span></span><br><span class="line"><span class="comment">// &#123;2,8,1,5,3&#125;</span></span><br></pre></td></tr></table></figure><h6 id="Collectors-groupingBy"><a href="#Collectors-groupingBy" class="headerlink" title="Collectors.groupingBy"></a><code>Collectors.groupingBy</code></h6><p>根据自定义规则对流中数据进行分类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;City&gt;&gt; collect6 = cities.stream().collect(Collectors.groupingBy(City::getName));</span><br><span class="line">collect6.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"><span class="comment">// key=1 value=[City&#123;name=&#x27;1&#x27;, population=50000&#125;, City&#123;name=&#x27;1&#x27;, population=5&#125;]</span></span><br><span class="line"><span class="comment">// key=2 value=[City&#123;name=&#x27;2&#x27;, population=2100000&#125;]</span></span><br><span class="line"><span class="comment">// key=3 value=[City&#123;name=&#x27;3&#x27;, population=90000&#125;]</span></span><br><span class="line"><span class="comment">// key=4 value=[City&#123;name=&#x27;4&#x27;, population=130000&#125;]</span></span><br><span class="line"><span class="comment">// key=5 value=[City&#123;name=&#x27;5&#x27;, population=1000000&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数2</span></span><br><span class="line"><span class="comment">// groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream)</span></span><br><span class="line"><span class="comment">// downstream 是在分组完成后，再执行的处理函数</span></span><br><span class="line">Map&lt;String, Long&gt; collect7 = cities.stream().collect(Collectors.groupingBy(City::getName, Collectors.counting()));</span><br><span class="line">collect7.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数3</span></span><br><span class="line"><span class="comment">// groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream)</span></span><br><span class="line"><span class="comment">// mapFactory 指明一个Map的构造函数即可，将会影响最终返回Map类型</span></span><br><span class="line">Hashtable&lt;String, Long&gt; collect8 = cities.stream().collect(Collectors.groupingBy(City::getName, Hashtable::<span class="keyword">new</span>, Collectors.counting()));</span><br></pre></td></tr></table></figure><h6 id="Collectors-partitioningBy"><a href="#Collectors-partitioningBy" class="headerlink" title="Collectors.partitioningBy"></a><code>Collectors.partitioningBy</code></h6><p>根据自定义判断规则，对流中元素进行分类，仅分为两组，通常在类似与统计及格人数之类场景使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; collect9 = Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.partitioningBy(e -&gt; e &gt; <span class="number">5</span>));</span><br><span class="line">collect9.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"><span class="comment">// key=false value=[2, 1, 5, 3]</span></span><br><span class="line"><span class="comment">// key=true value=[8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数 partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream)</span></span><br><span class="line"><span class="comment">// 新增入参是在分类结束后调用</span></span><br><span class="line">Map&lt;Boolean, Long&gt; collect10 = Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.partitioningBy(e -&gt; e &gt; <span class="number">5</span>, Collectors.counting()));</span><br><span class="line">collect10.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"><span class="comment">// key=false value=4</span></span><br><span class="line"><span class="comment">// key=true value=1</span></span><br></pre></td></tr></table></figure><h6 id="Collectors-summarizingInt"><a href="#Collectors-summarizingInt" class="headerlink" title="Collectors.summarizingInt"></a><code>Collectors.summarizingInt</code></h6><p>类似于<code>Stream</code>中的<code>summaryStatistics</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">collect11</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.summarizingInt(e -&gt; e));</span><br><span class="line">System.out.println(<span class="string">&quot;summarizingInt=&quot;</span> + collect11);</span><br><span class="line"><span class="comment">// summarizingInt=IntSummaryStatistics&#123;count=5, sum=19, min=1, average=3.800000, max=8&#125;</span></span><br></pre></td></tr></table></figure><h6 id="Collectors-summingInt"><a href="#Collectors-summingInt" class="headerlink" title="Collectors.summingInt"></a><code>Collectors.summingInt</code></h6><p>求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">collect12</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.summingInt(e -&gt; e));</span><br><span class="line">System.out.println(<span class="string">&quot;summingInt=&quot;</span> + collect12);</span><br><span class="line"><span class="comment">// summingInt=19</span></span><br></pre></td></tr></table></figure><h3 id="终章"><a href="#终章" class="headerlink" title="终章"></a>终章</h3><h4 id="Stream-1"><a href="#Stream-1" class="headerlink" title="Stream"></a>Stream</h4><h5 id="不存储"><a href="#不存储" class="headerlink" title="不存储"></a>不存储</h5><p><code>Stream</code>不存储任何对象在其中，其本身只充当管道的作用，它可以从各种数据结构、数组、生成器函数或I&#x2F;O流进行数据传输</p><h5 id="天然的函数式"><a href="#天然的函数式" class="headerlink" title="天然的函数式"></a>天然的函数式</h5><p>对流的操作会产生结果，但不会修改其源。例如，过滤从集合中获得的 Stream 会生成一个没有过滤元素的新 Stream，而不是从源集合中删除元素。</p><h5 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h5><p>许多流操作，例如过滤、映射或重复删除，可以延迟实现，从而为优化提供机会。例如，“查找具有三个连续元音的第一个字符串”不需要检查所有输入字符串。<br>流操作分为中间（流产生）操作和终端（产生价值或副作用）操作。中间操作总是懒惰的。</p><h5 id="可能无限"><a href="#可能无限" class="headerlink" title="可能无限"></a>可能无限</h5><p>虽然集合的大小是有限的，但流不需要。诸如 limit(n) 或 findFirst() 之类的短路操作可以允许对无限流的计算在有限时间内完成。</p><h5 id="消耗品"><a href="#消耗品" class="headerlink" title="消耗品"></a>消耗品</h5><p>流的元素在流的生命周期中只被访问一次。像迭代器一样，必须生成一个新流来重新访问源的相同元素。</p><h5 id="中间操作-intermediate"><a href="#中间操作-intermediate" class="headerlink" title="中间操作(intermediate)"></a>中间操作(intermediate)</h5><h6 id="无状态-Stateless"><a href="#无状态-Stateless" class="headerlink" title="无状态(Stateless)"></a>无状态(Stateless)</h6><p>无状态操作，例如filter and map，在处理新元素时不保留先前看到的元素的状态——每个元素都可以独立于对其他元素的操作进行处理.仅包含无状态中间操作的管道可以单次处理，无论是顺序的还是并行的，数据缓冲最少。</p><h6 id="有状态-stateful"><a href="#有状态-stateful" class="headerlink" title="有状态(stateful)"></a>有状态(stateful)</h6><p>有状态的操作，例如 distinct和sorted，在处理新元素时可能会合并来自先前看到的元素的状态。<br>有状态的操作可能需要在产生结果之前处理整个输入。例如，在查看流的所有元素之前，无法通过对流进行排序产生任何结果。因此，在并行计算下，一些包含有状态中间操作的管道可能需要对数据进行多次传递，或者可能需要缓冲重要数据。</p><h6 id="短路操作-short-circuiting"><a href="#短路操作-short-circuiting" class="headerlink" title="短路操作(short-circuiting)"></a>短路操作(short-circuiting)</h6><p>如果在呈现无限输入时，中间操作可能会产生有限流（如<code>limit</code>），则它是短路的。如果一个终端操作在有无限输入时可能会在有限时间内终止，那么它就是短路的。在管道中进行短路操作是无限流处理在有限时间内正常终止的必要条件，但不是充分条件。</p><h4 id="流处理过程"><a href="#流处理过程" class="headerlink" title="流处理过程"></a>流处理过程</h4><h5 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h5><p><img src="http://img.janwarlen.com/blog/StreamAPI.png" alt="Stream类图"></p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用本文最开始案例进行展示</span></span><br><span class="line">sum = cities</span><br><span class="line">        .stream()</span><br><span class="line">        .mapToInt(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;map:&quot;</span> + e.getName());</span><br><span class="line">            <span class="keyword">return</span> e.getPopulation();</span><br><span class="line">        &#125;)</span><br><span class="line">        .filter(population -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;filter:&quot;</span> + population);</span><br><span class="line">            <span class="keyword">return</span> population &gt; <span class="number">100_000</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// sum 内部也是通过reduce实现，此处用reduce是为了输出日志更好地展示过程</span></span><br><span class="line">        .reduce(<span class="number">0</span>, (i1, i2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;reduce:&quot;</span> + i1 + <span class="string">&quot; &quot;</span> + i2);</span><br><span class="line">            <span class="keyword">return</span> i1 + i2;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;Stream Sum = &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:1</span></span><br><span class="line"><span class="comment">// filter:50000</span></span><br><span class="line"><span class="comment">// map:2</span></span><br><span class="line"><span class="comment">// filter:2100000</span></span><br><span class="line"><span class="comment">// reduce:0 2100000</span></span><br><span class="line"><span class="comment">// map:3</span></span><br><span class="line"><span class="comment">// filter:90000</span></span><br><span class="line"><span class="comment">// map:4</span></span><br><span class="line"><span class="comment">// filter:130000</span></span><br><span class="line"><span class="comment">// reduce:2100000 130000</span></span><br><span class="line"><span class="comment">// map:5</span></span><br><span class="line"><span class="comment">// filter:1000000</span></span><br><span class="line"><span class="comment">// reduce:2230000 1000000</span></span><br><span class="line"><span class="comment">// Stream Sum = 3230000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>通过集合<code>cities</code>的函数<code>stream()</code>创建一个新的<code>Stream</code>，临时称作<code>s1</code></li><li><code>s1</code>通过函数<code>mapToInt</code>在自己的基础上创建一个新的<code>Stream</code>,临时称作<code>s2</code>,并将<code>s1</code>设置为<code>s2</code>的上游<code>previousStage</code></li><li><code>s2</code>通过函数<code>filter</code>在自己的基础上创建一个新的<code>Stream</code>，临时称作<code>s3</code>，并将<code>s2</code>设置为<code>s3</code>的上游<code>previousStage</code></li><li><code>s3</code>调用函数<code>reduce</code>触发结算操作，结算过程有两个核心点</li><li><code>java.util.stream.AbstractPipeline#wrapSink</code>通过该函数将结算操作前的所有中间操作逆序遍历(通过<code>previousStage</code>)，生成一个从上到下的新操作链<code>Sink</code></li><li><code>java.util.Spliterator#forEachRemaining</code>通过该函数将遍历数据源，并针对所有元素应用<code>Sink</code>(此时<code>Sink</code>是一条操作链，元素将会按顺序执行，直到结束或被中间操作剔除,如<code>filter</code>)</li><li>最终返回时，在<code>java.util.stream.ReduceOps.ReduceOp#evaluateSequential</code>中，通过对返回结果的<code>get()</code>函数取出最终返回结果</li><li>中间操作的叠加与结算时操作链的生成可以通过<code>装饰者模式</code>去理解，而结算时<code>downstream.accept(mapper.applyAsInt(u));</code>可以看出，先处理自己的操作<code>mapper.applyAsInt(u)</code>，然后再将结果传递给下一个中间操作<code>downstream.accept</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IntStream <span class="title function_">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="built_in">super</span> P_OUT&gt; mapper)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IntPipeline</span>.StatelessOp&lt;P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                            StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;Integer&gt; sink)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, Integer&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    downstream.accept(mapper.applyAsInt(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="parallelStream"><a href="#parallelStream" class="headerlink" title="parallelStream"></a>parallelStream</h4><h5 id="通过-fork-x2F-join-框架执行"><a href="#通过-fork-x2F-join-框架执行" class="headerlink" title="通过 fork&#x2F;join 框架执行"></a>通过 fork&#x2F;join 框架执行</h5><p>Terminal操作会在<code>java.util.stream.AbstractPipeline#evaluate(java.util.stream.TerminalOp&lt;E_OUT,R&gt;)</code>中判断是否是<code>parallel</code>，如果是，则会通过调用<code>ReduceTask</code>的invoke函数执行流处理，下方堆栈是我在生成操作链是通过断点，使用<code>Thread.currentThread().getStackTrace()</code>得出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;StackTraceElement@<span class="number">821</span>&#125; <span class="string">&quot;java.lang.Thread.getStackTrace(Thread.java:1559)&quot;</span></span><br><span class="line"><span class="number">1</span> = &#123;StackTraceElement@<span class="number">822</span>&#125; <span class="string">&quot;java.util.stream.AbstractPipeline.wrapSink(AbstractPipeline.java:517)&quot;</span></span><br><span class="line"><span class="number">2</span> = &#123;StackTraceElement@<span class="number">823</span>&#125; <span class="string">&quot;java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)&quot;</span></span><br><span class="line"><span class="number">3</span> = &#123;StackTraceElement@<span class="number">824</span>&#125; <span class="string">&quot;java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:747)&quot;</span></span><br><span class="line"><span class="number">4</span> = &#123;StackTraceElement@<span class="number">825</span>&#125; <span class="string">&quot;java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:721)&quot;</span></span><br><span class="line"><span class="number">5</span> = &#123;StackTraceElement@<span class="number">826</span>&#125; <span class="string">&quot;java.util.stream.AbstractTask.compute(AbstractTask.java:316)&quot;</span></span><br><span class="line"><span class="number">6</span> = &#123;StackTraceElement@<span class="number">827</span>&#125; <span class="string">&quot;java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731)&quot;</span></span><br><span class="line"><span class="number">7</span> = &#123;StackTraceElement@<span class="number">828</span>&#125; <span class="string">&quot;java.util.concurrent.ForkJoinTask.doExec$$$capture(ForkJoinTask.java:289)&quot;</span></span><br><span class="line"><span class="number">8</span> = &#123;StackTraceElement@<span class="number">829</span>&#125; <span class="string">&quot;java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java)&quot;</span></span><br><span class="line"><span class="number">9</span> = &#123;StackTraceElement@<span class="number">830</span>&#125; <span class="string">&quot;java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:401)&quot;</span></span><br><span class="line"><span class="number">10</span> = &#123;StackTraceElement@<span class="number">831</span>&#125; <span class="string">&quot;java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:734)&quot;</span></span><br><span class="line"><span class="number">11</span> = &#123;StackTraceElement@<span class="number">832</span>&#125; <span class="string">&quot;java.util.stream.ReduceOps$ReduceOp.evaluateParallel(ReduceOps.java:714)&quot;</span></span><br><span class="line"><span class="number">12</span> = &#123;StackTraceElement@<span class="number">833</span>&#125; <span class="string">&quot;java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:233)&quot;</span></span><br><span class="line"><span class="number">13</span> = &#123;StackTraceElement@<span class="number">834</span>&#125; <span class="string">&quot;java.util.stream.IntPipeline.reduce(IntPipeline.java:457)&quot;</span></span><br><span class="line"><span class="number">14</span> = &#123;StackTraceElement@<span class="number">835</span>&#125; <span class="string">&quot;com.janwarlen.jdk8.stream.StreamCasesCityPopulationSum.main(StreamCasesCityPopulationSum.java:29)&quot;</span></span><br></pre></td></tr></table></figure><h5 id="Task类继承UML"><a href="#Task类继承UML" class="headerlink" title="Task类继承UML"></a>Task类继承UML</h5><p>注意：并非所有<code>parallel</code>都是调用<code>ReduceTask</code>，其他类还有<code>FindTask</code>、<code>ForEachOrderedTask</code>、<code>ForEachTask</code>和<code>MatchTask</code><br><img src="http://img.janwarlen.com/blog/parallelStreamTaskUML.png" alt="最终任务执行类UML"></p><h5 id="自定义ForkJoinPool"><a href="#自定义ForkJoinPool" class="headerlink" title="自定义ForkJoinPool"></a>自定义ForkJoinPool</h5><p><code>ParallelStreams</code> 默认使用 <code>ForkJoinPool.commonPool()</code>线程池。如果需要指定线程池，可参照如下操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">customThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">actualTotal</span> <span class="operator">=</span> customThreadPool.submit(() -&gt; roster.parallelStream().reduce(<span class="number">0</span>, Integer::sum)).get();</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>不建议将stream流操作分割为一步一步操作，这将会产生stream的临时变量，而stream对象是仅可操作一次的，这存在反复操作风险，同理也不建议作为方法函数的入参<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;City&gt; cities = StreamCasesCityPopulationSum.getCities();</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">mapped</span> <span class="operator">=</span> cities.stream().mapToInt(City::getPopulation);</span><br><span class="line"><span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> mapped.sum();</span><br><span class="line">System.out.println(<span class="string">&quot;all=&quot;</span> + all);</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">filted</span> <span class="operator">=</span> mapped.filter(population -&gt; population &gt; <span class="number">100_000</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> filted.sum();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台将会输出</span></span><br><span class="line"></span><br><span class="line">all=<span class="number">3370000</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">at java.util.stream.AbstractPipeline.&lt;init&gt;(AbstractPipeline.java:<span class="number">203</span>)</span><br><span class="line">at java.util.stream.IntPipeline.&lt;init&gt;(IntPipeline.java:<span class="number">91</span>)</span><br><span class="line">at java.util.stream.IntPipeline$StatelessOp.&lt;init&gt;(IntPipeline.java:<span class="number">594</span>)</span><br><span class="line">at java.util.stream.IntPipeline$<span class="number">9.</span>&lt;init&gt;(IntPipeline.java:<span class="number">333</span>)</span><br><span class="line">at java.util.stream.IntPipeline.filter(IntPipeline.java:<span class="number">332</span>)</span><br><span class="line">at com.janwarlen.jdk8.stream.StreamAttention.main(StreamAttention.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure></li><li>Stream流拆分或使用非线程安全的共享变量，则会存在数据在流处理过程中变更风险</li><li>在流处理中，尽量避免对元素的状态操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; seen = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">stream.parallel().map(e -&gt; &#123; <span class="keyword">if</span> (seen.add(e)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">return</span> e; &#125;)</span><br></pre></td></tr></table></figure></li><li>尽量避免<code>Side-effects</code>操作，如forEach&#x2F;peek等，尤其是<code>parallel</code>模式下，可能会导致线程不安全等问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">    .forEach(s -&gt; results.add(s));  <span class="comment">// Unnecessary use of side-effects!</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt;results =</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">    .collect(Collectors.toList());  <span class="comment">// No side-effects!</span></span><br></pre></td></tr></table></figure></li><li>对顺序不敏感的流处理，可使用<code>unordered()</code>提高部分有状态或终端操作的并行性</li><li>仅在对顺序无感的流处理中使用<code>parallel</code>模式</li><li><code>parallel</code>模式默认情况下公用一个线程池，因此需要避免I&#x2F;O操作，以免阻塞其他并行流，或自定义一个线程池，单独提交并行流</li><li>并行流中Map操作推荐使用<code>Concurrent</code>，如<code>groupingByConcurrent</code>替换<code>groupingBy</code>、<code>ConcurrentMap</code>替换<code>Map</code>、<code>Collectors.toConcurrentMap</code>替换<code>Collectors.toMap</code>等等，理由是在并行流中<code>Concurrent</code>在性能消耗方面要好很多</li><li>并行模式下避免使用有状态的lambda表达式，如下所示，与<em>注意事项4</em>相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; parallelStorage = Collections.synchronizedList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).parallel()</span><br><span class="line">        <span class="comment">// Don&#x27;t do this! It uses a stateful lambda expression.</span></span><br><span class="line">        .map(e -&gt; &#123; parallelStorage.add(e); <span class="keyword">return</span> e; &#125;)</span><br><span class="line">        .forEachOrdered(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(parallelStorage);</span><br><span class="line"><span class="comment">// 每次运行，parallelStorage中存储顺序均不相同</span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 [1, 3, 4, 2, 5]</span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 [1, 3, 2, 5, 4]</span></span><br><span class="line"><span class="comment">// 推荐使用collect</span></span><br><span class="line">List&lt;Integer&gt; collect13 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).parallel().collect(Collectors.toList());</span><br><span class="line">System.out.println(collect13);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 每次运行结果不变</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.java/learn/the-stream-api/&quot;&gt;Java官方学习手册-Stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CarpenterLee/JavaLambdaInternals&quot;&gt;GitHub-CarpenterLee-JavaLambdaInternals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html&quot;&gt;Oracle关于parallelism官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description&quot;&gt;Oracle关于Stream包官方描述文档&lt;/a&gt;</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK8" scheme="http://janwarlen.com/tags/JDK8/"/>
    
    <category term="StreamAPI" scheme="http://janwarlen.com/tags/StreamAPI/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-Lambda</title>
    <link href="http://janwarlen.com/2022/06/07/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-Lambda/"/>
    <id>http://janwarlen.com/2022/06/07/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-Lambda/</id>
    <published>2022-06-07T10:05:32.000Z</published>
    <updated>2022-06-21T15:50:12.419Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h4><ol><li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27">Oracle官方Lambda文档</a></li><li><a href="https://github.com/CarpenterLee/JavaLambdaInternals">GitHub-CarpenterLee-JavaLambdaInternals</a><span id="more"></span><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3></li></ol><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LambdaParameters -&gt; LambdaBody</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="无入参案例"><a href="#无入参案例" class="headerlink" title="无入参案例"></a>无入参案例</h5><h6 id="JDK7匿名内部类版本"><a href="#JDK7匿名内部类版本" class="headerlink" title="JDK7匿名内部类版本:"></a>JDK7匿名内部类版本:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h6 id="JDK8-Lambda版本"><a href="#JDK8-Lambda版本" class="headerlink" title="JDK8 Lambda版本:"></a>JDK8 Lambda版本:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;起飞&quot;</span>)).start();</span><br></pre></td></tr></table></figure><h5 id="一个入参案例"><a href="#一个入参案例" class="headerlink" title="一个入参案例"></a>一个入参案例</h5><h6 id="自定义接口类"><a href="#自定义接口类" class="headerlink" title="自定义接口类"></a>自定义接口类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaSingleParam</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="自定义调用类"><a href="#自定义调用类" class="headerlink" title="自定义调用类"></a>自定义调用类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaFuncAccepter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">(LambdaSingleParam lambda)</span> &#123;</span><br><span class="line">        lambda.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="JDK7-匿名类版本"><a href="#JDK7-匿名类版本" class="headerlink" title="JDK7 匿名类版本"></a>JDK7 匿名类版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc(<span class="keyword">new</span> <span class="title class_">LambdaSingleParam</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="JDK8-Lambda版本-1"><a href="#JDK8-Lambda版本-1" class="headerlink" title="JDK8 Lambda版本"></a>JDK8 Lambda版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc((LambdaSingleParam) System.out::println);</span><br><span class="line"><span class="comment">// 当接收lambda表达式的类存在重载时，才需要显示的强转辅助编译器确认调用函数</span></span><br><span class="line"><span class="comment">// 当不存在重载时，直接可以使用  LambdaFuncAccepter.testFunc(System.out::println);</span></span><br><span class="line"><span class="comment">// 单个参数场景下的 System.out.println(i); 可以简写为 System.out::println </span></span><br><span class="line"><span class="comment">// 一般情况下，表达式类似于  a -&gt; System.out.println(a); 参数的() 可以省略</span></span><br></pre></td></tr></table></figure><h5 id="多入参案例"><a href="#多入参案例" class="headerlink" title="多入参案例"></a>多入参案例</h5><h6 id="自定义接口类-1"><a href="#自定义接口类-1" class="headerlink" title="自定义接口类"></a>自定义接口类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaMultipleParams</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="自定义调用类-1"><a href="#自定义调用类-1" class="headerlink" title="自定义调用类"></a>自定义调用类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaFuncAccepter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">(LambdaMultipleParams lambda)</span> &#123;</span><br><span class="line">        lambda.test(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="JDK7-匿名类版本-1"><a href="#JDK7-匿名类版本-1" class="headerlink" title="JDK7 匿名类版本"></a>JDK7 匿名类版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc(<span class="keyword">new</span> <span class="title class_">LambdaMultipleParams</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(x + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="JDK8-Lambda版本-2"><a href="#JDK8-Lambda版本-2" class="headerlink" title="JDK8 Lambda版本"></a>JDK8 Lambda版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc((a, b) -&gt; System.out.println(a + b));</span><br><span class="line"><span class="comment">// 多参数场景下，入参的 &#x27;()&#x27; 必须存在</span></span><br></pre></td></tr></table></figure><h4 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h4><h5 id="单条执行语句"><a href="#单条执行语句" class="headerlink" title="单条执行语句"></a>单条执行语句</h5><h6 id="无return案例"><a href="#无return案例" class="headerlink" title="无return案例"></a>无return案例</h6><p><a href="#%E6%97%A0%E5%85%A5%E5%8F%82%E6%A1%88%E4%BE%8B">同无入参案例</a></p><h6 id="有return案例"><a href="#有return案例" class="headerlink" title="有return案例"></a>有return案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaWIthReturnNoParam</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// () -&gt; 233 ,其中return可以省略</span></span><br><span class="line"><span class="type">LambdaWIthReturnNoParam</span> <span class="variable">lambdaWIthReturnNoParam</span> <span class="operator">=</span> () -&gt; <span class="number">233</span>;</span><br><span class="line">System.out.println(lambdaWIthReturnNoParam.test());</span><br></pre></td></tr></table></figure><h5 id="多条执行语句"><a href="#多条执行语句" class="headerlink" title="多条执行语句"></a>多条执行语句</h5><h6 id="无return案例-1"><a href="#无return案例-1" class="headerlink" title="无return案例"></a>无return案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用runable接口</span></span><br><span class="line"><span class="comment">// 多条执行语句的方法体必须使用 &#123; &#125; 包裹</span></span><br><span class="line"><span class="comment">// 语法规则基本与正常函数方法体一致</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;line1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;line2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h6 id="有return案例-1"><a href="#有return案例-1" class="headerlink" title="有return案例"></a>有return案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 LambdaWIthReturnNoParam 接口</span></span><br><span class="line"><span class="comment">// return 也属于执行语句</span></span><br><span class="line"><span class="comment">// 多条语句场景 return 不可省略</span></span><br><span class="line"><span class="type">LambdaWIthReturnNoParam</span> <span class="variable">lambdaWIthReturnNoParam</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;line1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2022</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(lambdaWIthReturnNoParam.test());</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>lambda表达式的使用必须要有对应的函数接口，并且该接口有且仅有一个无默认实现的函数(当接口的其他函数均由默认实现时，该接口也可使用lambda，如<code>Comparator</code>)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Arrays.sort(a, (o1, o2) -&gt; o2 - o1);</span><br><span class="line"><span class="comment">// 也可写成，不过Integer内置是固定升序的，无法修改</span></span><br><span class="line">Arrays.sort(a, Integer::compare);</span><br></pre></td></tr></table></figure></li><li>多参数场景下，要么都声明入参类型，要么都不声明，不允许一部分声明，一部分隐藏<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc((a, <span class="type">int</span> b) -&gt; System.out.println(a + b));</span><br><span class="line"><span class="comment">// 此时编译器会报错</span></span><br></pre></td></tr></table></figure></li><li>final 不能修饰推断类型入参，如需使用final，需要将入参显示设置类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器会提示异常</span></span><br><span class="line">LambdaFuncAccepter.testFunc((a, <span class="keyword">final</span> b) -&gt; System.out.println(a + b));</span><br><span class="line"><span class="comment">// 需调整为如下所示:</span></span><br><span class="line">LambdaFuncAccepter.testFunc((<span class="type">int</span> a, <span class="keyword">final</span> <span class="type">int</span> b) -&gt; System.out.println(a + b));</span><br></pre></td></tr></table></figure></li><li>lambda方法体使用外部变量时，必须遵守声明时赋值后续不可赋值规则(同final修饰规则)，但调用对象函数修改对象内部状态合法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">    <span class="comment">// 虽然sb没有被final声明，但是在lambda内部存在隐形的final限制</span></span><br><span class="line">    <span class="comment">// sb = new StringBuilder();</span></span><br><span class="line">    sb.append(<span class="number">111</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;line1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 即便是在外部在初始化后再修改赋值，此时已经破坏final规则</span></span><br><span class="line">y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">    System.out.println(y);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li><li>使用数组一类时，需要注意下标的使用，如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">        <span class="comment">// 此时 i 不是遵守final规则的变量</span></span><br><span class="line">        System.out.println(b[i]);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以修改调整如下所示:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : b) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 此时变量i作为临时变量还尚未经历再一次的赋值修改，因此还遵守 effectively final 规则</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>lambda方法体使用外部变量时，必须确保所有外部变量均以完成初始化(仅声明不行，如分支，必须确保变量初始化)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">if</span> (sb.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Variable &#x27;x&#x27; might not have been initialized</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27&quot;&gt;Oracle官方Lambda文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CarpenterLee/JavaLambdaInternals&quot;&gt;GitHub-CarpenterLee-JavaLambdaInternals&lt;/a&gt;</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="Lambda" scheme="http://janwarlen.com/tags/Lambda/"/>
    
    <category term="JDK8" scheme="http://janwarlen.com/tags/JDK8/"/>
    
  </entry>
  
  <entry>
    <title>一书一图-Head First设计模式</title>
    <link href="http://janwarlen.com/2022/06/05/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-Head%20First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://janwarlen.com/2022/06/05/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-Head%20First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-04T16:01:49.000Z</published>
    <updated>2022-06-04T16:15:54.240Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h4><ol><li>本书适合刚学习编程，并对编程十分感兴趣的同学，此书无法立刻提升编码能力，仅仅只能提供认知拓展；</li><li>设计模式是一种经验总结，并非发明创造，因此不能刻版的使用，需要因地制宜，甚至有些场景下，不适用任何设计模式解决问题反而会是最佳方案；</li><li>有一定的项目编码经验的同学更适合其他学习方式，如文字版的网页菜鸟教程或者视频类其他知识分享者上传的视频教程，本人更推荐文字版的，比较方便，更能快速的了解；</li><li>学习设计模式主要核心是弄清楚要解决的问题即使用场景，最好是能根据教材&#x2F;教程的案例，自己手敲一遍代码并运行去理解，仅仅靠定义去了解是远远不够的；</li><li>还想更进一步了解使用场景的同学可以去阅读各大开源项目的代码，尤其是中间件一类，因为更多会考虑性能和拓展问题，设计模式使用频率会远高于一般的业务项目；</li><li>思维导图中的一些优点缺点是结合部分网络教程的观点罗列而来，并非标准答案；</li><li>本文的思维导图仅是本人的读书笔记，不可作为权威版本去学习参考，可以简单浏览，如果感兴趣可以购买正版书籍学习；<span id="more"></span></li></ol><p><img src="http://img.janwarlen.com/blog/Head%20First%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="Head First设计模式"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;本书适合刚学习编程，并对编程十分感兴趣的同学，此书无法立刻提升编码能力，仅仅只能提供认知拓展；&lt;/li&gt;
&lt;li&gt;设计模式是一种经验总结，并非发明创造，因此不能刻版的使用，需要因地制宜，甚至有些场景下，不适用任何设计模式解决问题反而会是最佳方案；&lt;/li&gt;
&lt;li&gt;有一定的项目编码经验的同学更适合其他学习方式，如文字版的网页菜鸟教程或者视频类其他知识分享者上传的视频教程，本人更推荐文字版的，比较方便，更能快速的了解；&lt;/li&gt;
&lt;li&gt;学习设计模式主要核心是弄清楚要解决的问题即使用场景，最好是能根据教材&amp;#x2F;教程的案例，自己手敲一遍代码并运行去理解，仅仅靠定义去了解是远远不够的；&lt;/li&gt;
&lt;li&gt;还想更进一步了解使用场景的同学可以去阅读各大开源项目的代码，尤其是中间件一类，因为更多会考虑性能和拓展问题，设计模式使用频率会远高于一般的业务项目；&lt;/li&gt;
&lt;li&gt;思维导图中的一些优点缺点是结合部分网络教程的观点罗列而来，并非标准答案；&lt;/li&gt;
&lt;li&gt;本文的思维导图仅是本人的读书笔记，不可作为权威版本去学习参考，可以简单浏览，如果感兴趣可以购买正版书籍学习；</summary>
    
    
    
    <category term="设计模式" scheme="http://janwarlen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://janwarlen.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="读书笔记" scheme="http://janwarlen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一书一图-深入理解Java虚拟机</title>
    <link href="http://janwarlen.com/2022/06/01/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://janwarlen.com/2022/06/01/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2022-06-01T02:53:49.000Z</published>
    <updated>2022-05-31T21:17:34.206Z</updated>
    
    <content type="html"><![CDATA[<p>Tips：  </p><ol><li>本书推荐按章节顺序读取，但是不同篇章需要不同程度的深入了解；</li><li>对于Java开发人员，本书最重要的篇章就是自动内存管理机制部分(第2章-第5章)，可以在日常的OOM和StackOverflow场景中提供巨大帮助，尤其其中提供的几个案例，更能帮助读者更好的理解内存管理；</li><li>其次就是高效并发篇章，该篇章可以帮助读者更深入的理解并发竞争的模型，理解为什么死锁，不过部分内容除了需要本书的其他篇章内容支撑外i，还需要额外了解操作系统知识(信号量)，并且无死锁场景的排查案例，因此需要读者需要额外通过其他方式学习如何在死锁时定位；</li><li>其他篇章内容对于Java开发人员基本只需要阅读产生印象即可，无需更深入了解(对大部分常规日常工作无明显帮助)；</li><li>平台(中间件)开发人员，需要额外深入阅读虚拟机执行子系统篇章，尤其是类加载内容，其中的双亲委派模型尤为重要；</li><li>思维导图不适合作为学习材料，可以简单一阅，建议购买正版书籍。<span id="more"></span></li></ol><p><img src="http://img.janwarlen.com/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="深入理解Java虚拟机"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Tips：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本书推荐按章节顺序读取，但是不同篇章需要不同程度的深入了解；&lt;/li&gt;
&lt;li&gt;对于Java开发人员，本书最重要的篇章就是自动内存管理机制部分(第2章-第5章)，可以在日常的OOM和StackOverflow场景中提供巨大帮助，尤其其中提供的几个案例，更能帮助读者更好的理解内存管理；&lt;/li&gt;
&lt;li&gt;其次就是高效并发篇章，该篇章可以帮助读者更深入的理解并发竞争的模型，理解为什么死锁，不过部分内容除了需要本书的其他篇章内容支撑外i，还需要额外了解操作系统知识(信号量)，并且无死锁场景的排查案例，因此需要读者需要额外通过其他方式学习如何在死锁时定位；&lt;/li&gt;
&lt;li&gt;其他篇章内容对于Java开发人员基本只需要阅读产生印象即可，无需更深入了解(对大部分常规日常工作无明显帮助)；&lt;/li&gt;
&lt;li&gt;平台(中间件)开发人员，需要额外深入阅读虚拟机执行子系统篇章，尤其是类加载内容，其中的双亲委派模型尤为重要；&lt;/li&gt;
&lt;li&gt;思维导图不适合作为学习材料，可以简单一阅，建议购买正版书籍。</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="读书笔记" scheme="http://janwarlen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JVM" scheme="http://janwarlen.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读-HashMap</title>
    <link href="http://janwarlen.com/2018/08/16/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-HashMap/"/>
    <id>http://janwarlen.com/2018/08/16/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-HashMap/</id>
    <published>2018-08-15T16:34:42.000Z</published>
    <updated>2022-05-31T18:26:48.313Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h4><ol><li>扩容是一个特别耗性能的操作，因此建议使用HashMap时，尽量指定一定大小的初始容量</li><li><code>HashMap</code>是线程不安全的，并发环境中建议使用<code>ConcurrentHashMap</code></li><li>JDK8中引入的红黑树优化了大量hash碰撞时的性能</li><li>HashMap中的红黑树代码作者实在没力气看了，因此这篇文章不涉及内部红黑树分析</li><li>该篇文章纯粹是作者个人观点，并非官方权威，阅读请勿迷信<span id="more"></span><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><code>hashmap</code>使用数组+链表（红黑树）作为整体结构<h5 id="节点数据结构"><a href="#节点数据结构" class="headerlink" title="节点数据结构"></a>节点数据结构</h5>一般情况下，节点会使用如下代码构建结构,该结构为<a href="https://baike.baidu.com/item/%E5%8D%95%E9%93%BE%E8%A1%A8">单链表</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>JDK8中增加特性：当链表长度超过8时（等于也会触发），会转换为红黑树结构。红黑树需要了解的小伙伴可以看下这篇文章：<a href="http://janwarlen.com/2018/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/">一步一步数据结构-红黑树</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5>图片来源美团技术博客：<a href="https://tech.meituan.com/java_hashmap.html">Java 8系列之重新认识HashMap</a>  <img src="https://tech.meituan.com/img/java-hashmap/hashMap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="hashMap内存结构图" heigth="280" width="470">  本质上，在一般情况下的HashMap就是一维数组+单链表，其中一维数组在这里的作用个人感觉更像是指针，当用户通过`get`获取值的时候，先通过hash找到对应数组位置，再通过数组找到对应的链表，再进行链表遍历找到完全符合的**键值节点**</li></ol><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>在初步了解HashMap长相之后，我们可以通过基本操作来了解它的工作过程。</p><h5 id="hash与索引计算"><a href="#hash与索引计算" class="headerlink" title="hash与索引计算"></a>hash与索引计算</h5><p>HashMap通过Key的hash值找到数组的对应位置，因此我们需要先行了解hash的运算规则，因使用的是key对应对象的<code>hashCode()</code>函数，因此在使用自定义对象作为key时，需格外注意。<br>运算符相关介绍：<br><a href="https://baike.baidu.com/item/%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6">&gt;&gt;&gt; 右移运算符</a><br><a href="https://jingyan.baidu.com/article/fec4bce2759713f2618d8b98.html">^ 按位异或运算符</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引计算通过<code>(n - 1) &amp; hash</code>，引用美团技术博客中原文(n即length)：</p><blockquote><p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p></blockquote><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><p><a href="https://zhidao.baidu.com/question/321019160.html">&amp;</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 此处是对HashMap容量判断，属于边界异常判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 需注意的是，上一小节是介绍hash的运算过程，转换为数组索引是`(n - 1) &amp; hash`</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 索引位置链表为空，直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 此处判断的是对应索引位置单链表的头结点，需注意(k = p.key) == key || (key != null &amp;&amp; key.equals(k)))</span></span><br><span class="line">        <span class="comment">// 因key可以为任意对象，因此==在某些时候不能作为判断相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果索引对应链表已经是红黑树，交由红黑树处理</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当头结点并非所寻节点，则遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 无相同key节点，直接尾插法插入新节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 当链表达到阈值，则进行转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 相同key情况在此处处理，直接进行值覆盖（相当于修改）</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 数组阈值判断，如果达到阈值，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 意义不明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 避免数组为空（即HashMap为空），数组索引对应链表为空</span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash   已经计算索引位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 找对应节点</span></span><br><span class="line">        <span class="comment">// 判断索引对应链表头结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 添加if判断，避免边界问题（个人猜测主要是避免红黑树的情况）</span></span><br><span class="line">        <span class="comment">// 因为单链表的边界避免可以通过循环条件控制，此处使用的是do&#123;&#125;while循环，可以使用while改变条件判断时机</span></span><br><span class="line">        <span class="comment">// 此处都是个人猜测，极具争议性，非正规解释</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 红黑树节点交由红黑树内部方法定位所寻找节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到节点后进行删除操作，判断条件避免不存在节点情况和需要严格匹配值情况</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 红黑树交由内部处理</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">// 此处情况是，链表头结点就是所寻节点，因此node与p相等</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 单链表删除操作</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);<span class="comment">// 意义不明</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 避免为空条件三连</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 链表头结点判断</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 当链表不仅仅只有头节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 红黑树交由内部处理</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历链表寻找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>所有操作在需要对链表进行判断的情况下，在JDK8中，都是先判断头结点，再判断是否存在后续节点，然后红黑树交由红黑树内部方法处理，单链表遍历通过do{}while进行循环遍历。对比JDK1.7我们可以看出代码变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="type">return</span> <span class="variable">null</span> <span class="operator">=</span>= entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">getForNullKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK7中，因为没有引入红黑树优化，因此链表都为单链表，因此遍历都是通过for循环，后续节点非空判断也在for循环的判断条件中。因此，此处<strong>个人</strong>大胆总结，该变化由红黑树引起。可能由于<code>instanceof</code>存在一定程度的性能损耗，因此，先进行首节点判断以尽可能的避免首节点就是所寻节点从而不用使用<code>instanceof</code>可以提升一定程度的性能（存在争议）。</p><h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><h5 id="HashMap的创建"><a href="#HashMap的创建" class="headerlink" title="HashMap的创建"></a>HashMap的创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可自定义初始容量和加载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅指定初始容量，使用默认的加载因子0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认的加载因子初始化，未指定初始容量，将会使用默认初始容量16</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据已有map导入至新的hashmap中，使用默认加载因子0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上创建HashMap的方式中，需要注意指定初始容量的函数，两者都会执行<code>this.threshold = tableSizeFor(initialCapacity);</code>这段代码将会将使用者指定的容量转化为2的整数次方数，举例说明<code>tableSizeFor(11)</code>将会返回<code>16</code>,<code>tableSizeFor(17)</code>将会返回<code>32</code>。其内部实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhidao.baidu.com/question/291266003.html">他人解释</a>，根据该解释，再加上程序语言一般情况下<code>int</code>最大值为<code>2147483647</code>，转化为二进制是32位，而<code>1+2+4+8+16=31</code>，因此基本可以认定只要传入<code>int</code>不是非法，都会被该函数运算处理，此时需要注意<code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>该函数限定了最大值。<br>一般情况下，我们使用HashMap并不会指定初始容量与加载因子，会使用默认的无参构造（即将会创建初始容量为16，加载因子为0.75的一个HashMap），那么很容易会碰到容量达到阈值（总容量*加载因子）从而触发自动扩容。因为底层就是创建新数组，然后数据内容从旧数组中转移至新的，因此我们先看下数据的新增定位过程。</p><h5 id="HashMap的索引计算"><a href="#HashMap的索引计算" class="headerlink" title="HashMap的索引计算"></a>HashMap的索引计算</h5><p>之前查看<code>put</code>源码时，很容易看出索引位置由<code>(n - 1) &amp; hash</code>算出，其中<code>n</code>为当前数组容量长度。<code>&amp;</code>是按位与运算，我简易模拟下hash为48和1568时的运算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  48-&gt; 0000 0000 0000 0000 0000 0000 0011 0000</span><br><span class="line">  15-&gt; 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">&amp;</span><br><span class="line">       0000 0000 0000 0000 0000 0000 0000 0000 -&gt; 0</span><br><span class="line"></span><br><span class="line">1568-&gt; 0000 0000 0000 0000 0000 0110 0010 0000</span><br><span class="line">  15-&gt; 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">&amp;</span><br><span class="line">       0000 0000 0000 0000 0000 0000 0000 0000 -&gt; 0</span><br><span class="line">Tips:48为字符串&quot;0&quot;的hash值，1568为字符串&quot;11&quot;的hash值</span><br><span class="line">因为&amp;运算的特性，仅有1&amp;1的结果才为1，因此n-1的值限定了计算&amp;的长度</span><br><span class="line">当前例子中仅仅计算最后四位，因为前面的所有都是0，无需考虑</span><br></pre></td></tr></table></figure><h5 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h5><p>扩容由<code>++size &gt; threshold</code>触发，因此我使用如下代码进行简易的触发扩容，并且确保至少有一条单链表存在一个以上的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; test = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 0 与 11 索引位置相同，索引为0</span></span><br><span class="line">    <span class="comment">// 1 与 12 索引位置相同，索引为1</span></span><br><span class="line">    test.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.janwarlen.com/18-8-15/52850757.jpg" alt="简易数据"><br>从图中可以轻易看出数组已经存在<strong>11</strong>个数据，因此当前<code>size</code>为11，此时满足<code>++size &gt; threshold</code>条件，触发扩容，容量会由<code>newThr = oldThr &lt;&lt; 1; // double threshold</code>扩大一倍（即原来的两倍），因为容量的扩大，计算索引时的公式<code>(n - 1) &amp; hash</code>，此时<code>n-1</code>的二进制肯定比之前多一位，因此节点的位置需要重新计算。而根据函数<code>tableSizeFor</code>我们可知，基本上所有的HashMap的容量都是<code>2</code>的整数次方数。因此可以看如下过程（以初始容量为16举例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始内容    hash值   hash值的二进制                               与<span class="number">15</span>&amp;结果  与<span class="number">31</span>&amp;结果</span><br><span class="line"><span class="number">0</span>           <span class="number">48</span>      <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> <span class="number">0000</span>     <span class="number">0</span>           <span class="number">16</span></span><br><span class="line"><span class="number">11</span>          <span class="number">1568</span>    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0110</span> <span class="number">0010</span> <span class="number">0000</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">n-<span class="number">1</span>=<span class="number">15</span>(非hash值!)   <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line">n^<span class="number">2</span>-<span class="number">1</span>=<span class="number">31</span>            <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1111</span></span><br><span class="line">Tip：对不齐我也没办法，我也很难受，将就看吧</span><br></pre></td></tr></table></figure><p>可以轻易看出，元素是否需要转移位置取决于新增的那一位是1还是0，因此和<code>n</code>进行<code>&amp;</code>运算即可得知，为0即保留位置无需移动，为1则代表需要移动<code>n</code>个位置。<br>先看下源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我挑出两部分着重看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 此处意味着当前索引的链表仅有头结点</span></span><br><span class="line">    <span class="comment">// 因此直接重新计算索引</span></span><br><span class="line">    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 保留原位</span></span><br><span class="line">    <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">        loHead = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        loTail.next = e;</span><br><span class="line">    loTail = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 移动原数组容量位置</span></span><br><span class="line">    <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">        hiHead = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hiTail.next = e;</span><br><span class="line">    hiTail = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两段代码可以清晰看出无论当前索引位置的链表仅有一个节点还是多个，都会进行<code>&amp;</code>计算，因此美团关于<a href="https://tech.meituan.com/java_hashmap.html">HashMap</a>的文章中有这么一段</p><blockquote><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:  </p></blockquote><p>同时我们对比JDK7中扩容迁移的源码来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们观察源码得知，的确省去重新计算hash值的时间，不过链表元素会产生倒置是因为JDK7中<code>put</code>使用的是头插法。因此，个人在此猜测，当链表超过一个节点时不直接使用<code>newTab[e.hash &amp; (newCap - 1)] = e;</code>是为了避免索引一致时的尾插法的链表遍历（链表插入删除操作快，查询满；而数组查询快，删除插入操作稍慢），使用第二段代码明显可以减少一次单链表的遍历。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;扩容是一个特别耗性能的操作，因此建议使用HashMap时，尽量指定一定大小的初始容量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt;是线程不安全的，并发环境中建议使用&lt;code&gt;ConcurrentHashMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JDK8中引入的红黑树优化了大量hash碰撞时的性能&lt;/li&gt;
&lt;li&gt;HashMap中的红黑树代码作者实在没力气看了，因此这篇文章不涉及内部红黑树分析&lt;/li&gt;
&lt;li&gt;该篇文章纯粹是作者个人观点，并非官方权威，阅读请勿迷信</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="SourceCode" scheme="http://janwarlen.com/tags/SourceCode/"/>
    
    <category term="源码阅读" scheme="http://janwarlen.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="HashMap" scheme="http://janwarlen.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>一步一步数据结构-红黑树</title>
    <link href="http://janwarlen.com/2018/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://janwarlen.com/2018/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2018-07-12T01:31:39.000Z</published>
    <updated>2022-05-31T18:26:48.310Z</updated>
    
    <content type="html"><![CDATA[<p>Tips:  </p><ol><li>红黑树是搜索二叉树的变种，可以先行理解<a href="http://janwarlen.com/2018/04/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVLTree/">AVLTree</a>  </li><li>根据多方资料查找，很多人说2-3树和2-3-4树有助于理解红黑树（个人未进行深入了解，有兴趣可以自行搜索相关资料，或者等我再一次诈尸） <code>红黑树是2-3-4树的一种等同。换句话说，对于每个2-3-4树，都存在至少一个数据元素是同样次序的红黑树。在2-3-4树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得2-3-4树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍2-3-4树的原因，尽管2-3-4树在实践中不经常使用。 (wiki)</code>  </li><li>红黑树与AVL树不同，不具备部分AVL树的特性，如：每个节点的左右节点的高度差值不超过1</li><li>关于为什么新增节点一定是红色，个人未找到合理解释（目前仅理解为红色可以避免部分需要修复的情况），可能会在2-3-4树中找到原因</li></ol><p><a href="https://github.com/JanWarlen/DemoList/blob/master/DataStructDemo/src/main/java/com/janwarlen/btree/RBTree.java">demo代码</a><br><code>主要参考于TreeMap</code></p><span id="more"></span><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><h4 id="节点颜色修复"><a href="#节点颜色修复" class="headerlink" title="节点颜色修复"></a>节点颜色修复</h4><blockquote><p>旋转可以参考AVLTree中的介绍，但需注意在AVLTree中介绍的左旋与右旋的定义，本文中以方向定左右，上文以子树位置定左右。</p></blockquote><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>wiki百科中详细罗列了几种情况，此处我将会直接搬运，并且稍加个人理解，各位读者阅读时，请捎带“眼镜”以防被我的漏洞所误导。</p><ul><li>性质1和性质3总是保持着。</li><li>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</li><li>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</li></ul><p>关于这三点的理解，除了第一点外，剩余两点十分抽象，如果仅靠这个去尝试理解，需要自己手动模拟红黑树的插入。<br>下面我将由wiki列出的5中情况代入，去阐述插入所遇到的问题。</p><p><strong>注意：</strong>新增节点的插入，一定是叶子节点（在树的调整修复前，读者可以手动尝试，我将举简单例子）<br>插入： 1,5,2,7,4,6,9,3<br><img src="http://img.janwarlen.com/18-6-25/33467818.jpg" alt="红黑树例1"></p><blockquote><p>情形1:新节点N位于树的根上，没有父节点。在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑节点数目增加一，性质5匹配。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此处是指插入的新节点是树的根，因此只需要保证性质2`根是黑色`即可满足条件</span><br></pre></td></tr></table></figure><blockquote><p>情形2:新节点的父节点P是黑色，所以性质4没有失效（新节点是红色的）。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为插入节点都是红色，因此并未破坏性质。</span><br></pre></td></tr></table></figure><blockquote><p>情形3:如果父节点P和叔父节点U二者都是红色，（此时新插入节点N做为P的左子节点或右子节点都属于情形3，这里右图仅显示N做为P左子的情形）则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行情形1的整个过程。（把G当成是新加入的节点进行各种情形的检查）</p></blockquote><p><img src="http://img.janwarlen.com/18-6-21/94370219.jpg" alt="情形3"><br><strong>注意：</strong><code>在余下的情形下，我们假定父节点P是其父亲G的左子节点。如果它是右子节点，情形4和情形5中的左和右应当对调。</code></p><blockquote><p>情形4:父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色;接着，我们按情形5处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。</p></blockquote><p><img src="http://img.janwarlen.com/18-6-25/46564427.jpg" alt="情形4"></p><blockquote><p>情形5：父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。</p></blockquote><p><img src="http://img.janwarlen.com/18-6-25/24676155.jpg" alt="情形5"></p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>节点删除我们只需要考虑被删除的节点有一个子节点或者本身为叶子节点（叶子节点也可看做只有一个子节点），因被删除节点有两个子节点时，删除方案是使用前驱节点（左子树最大）或者后继节点（右子树最小）进行替换，然后删除替换节点（替换节点要么只有一个子节点，要么是叶子节点）。<br>情况一：删除红色节点，父节点、子节点都为黑色。不会破坏性质。<br><img src="http://img.janwarlen.com/18-6-25/5931354.jpg" alt="情况一"><br>情况二：删除黑色节点，子节点为红色。子节点提升，颜色修复红转黑，满足红黑树性质。<br><img src="http://img.janwarlen.com/18-6-25/71572459.jpg" alt="情况二"><br>情况三（四）：删除黑色节点，子节点也为黑色（需要注意双子节点情况，删除节点为替换节点）<br>不再单独列出情况四<br><img src="http://img.janwarlen.com/18-7-16/98551352.jpg" alt="例2"><br>需注意，删除中的例子<strong>无节点52</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">private void remove(Node&lt;T&gt; d) &#123;</span><br><span class="line"></span><br><span class="line">    //该if判断即是将双子节点情况转为单子节点情况</span><br><span class="line">    if (d.left != null &amp;&amp; d.right != null) &#123;</span><br><span class="line">        // 左右节点皆不为空，将待删除节点元素赋值为后继节点元素</span><br><span class="line">        // 注意，此时未带来节点颜色</span><br><span class="line">        Node&lt;T&gt; s = successor(d);</span><br><span class="line">        d.element = s.element;</span><br><span class="line">        // 待删除节点指针指向后继节点</span><br><span class="line">        d = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node&lt;T&gt; replacement = (d.left != null ? d.left : d.right);</span><br><span class="line"></span><br><span class="line">    if (replacement != null) &#123;</span><br><span class="line">        // 左右节点至少有一个节点不为空</span><br><span class="line">        replacement.parent = d.parent;</span><br><span class="line">        if (d.parent == null) &#123;</span><br><span class="line">            // 树仅有两个节点,d为根结点</span><br><span class="line">            root = replacement;</span><br><span class="line">        &#125; else if (d == d.parent.left) &#123;</span><br><span class="line">            // 待删除节点为父节点的左节点</span><br><span class="line">            d.parent.left = replacement;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 待删除节点为父节点的右节点</span><br><span class="line">            d.parent.right = replacement;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 断开待删除节点的所有链接</span><br><span class="line">        // 当待删除节点左右节点皆不为空时，此时d指向后继节点</span><br><span class="line">        d.left = d.right = d.parent = null;</span><br><span class="line"></span><br><span class="line">        // Fix replacement</span><br><span class="line">        // 当待删除节点为红色时，无需调整节点颜色</span><br><span class="line">        if (d.color == BLACK) &#123;</span><br><span class="line">            // 此时原节点已被删除，replacement是替换后节点</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (null == d.parent) &#123;</span><br><span class="line">        // 当前树仅有根结点</span><br><span class="line">        root = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (d.color == BLACK)</span><br><span class="line">            // 待删除节点为叶子节点</span><br><span class="line">            fixAfterDeletion(d);</span><br><span class="line"></span><br><span class="line">        if (d.parent != null) &#123;</span><br><span class="line">            // 针对删除节点为叶子节点情况</span><br><span class="line">            if (d == d.parent.left)</span><br><span class="line">                d.parent.left = null;</span><br><span class="line">            else if (d == d.parent.right)</span><br><span class="line">                d.parent.right = null;</span><br><span class="line">            d.parent = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 待删除节点已被删除替换后，进行颜色修复</span><br><span class="line">private void fixAfterDeletion(Node&lt;T&gt; x) &#123;</span><br><span class="line">    //  只有节点为黑色才需要修复</span><br><span class="line">    while (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        // 左节点</span><br><span class="line">        if (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Node&lt;T&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            // 兄弟节点为红色，自己是黑色,设定为情况1</span><br><span class="line">            if (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                    colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                // 兄弟节点的子节点都为黑色,设定为情况2</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    // 兄弟节点的子节点只有右节点为黑色，设定为情况3</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                // 兄弟节点的右节点为红色,设定为情况4</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // symmetric</span><br><span class="line">            // 镜像对称</span><br><span class="line">            Node&lt;T&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            if (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                    colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.janwarlen.com/18-7-16/52797124.jpg" alt="情况三/四"><br>放在代码后是希望能先阅读代码再看过程，能更易理解</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Tips:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;红黑树是搜索二叉树的变种，可以先行理解&lt;a href=&quot;http://janwarlen.com/2018/04/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVLTree/&quot;&gt;AVLTree&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;根据多方资料查找，很多人说2-3树和2-3-4树有助于理解红黑树（个人未进行深入了解，有兴趣可以自行搜索相关资料，或者等我再一次诈尸） &lt;code&gt;红黑树是2-3-4树的一种等同。换句话说，对于每个2-3-4树，都存在至少一个数据元素是同样次序的红黑树。在2-3-4树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得2-3-4树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍2-3-4树的原因，尽管2-3-4树在实践中不经常使用。 (wiki)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;红黑树与AVL树不同，不具备部分AVL树的特性，如：每个节点的左右节点的高度差值不超过1&lt;/li&gt;
&lt;li&gt;关于为什么新增节点一定是红色，个人未找到合理解释（目前仅理解为红色可以避免部分需要修复的情况），可能会在2-3-4树中找到原因&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JanWarlen/DemoList/blob/master/DataStructDemo/src/main/java/com/janwarlen/btree/RBTree.java&quot;&gt;demo代码&lt;/a&gt;&lt;br&gt;&lt;code&gt;主要参考于TreeMap&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="数据结构" scheme="http://janwarlen.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="一步一步数据结构" scheme="http://janwarlen.com/tags/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="红黑树" scheme="http://janwarlen.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>一步一步数据结构-AVLTree</title>
    <link href="http://janwarlen.com/2018/04/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVLTree/"/>
    <id>http://janwarlen.com/2018/04/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVLTree/</id>
    <published>2018-04-12T01:31:39.000Z</published>
    <updated>2022-05-31T18:26:48.315Z</updated>
    
    <content type="html"><![CDATA[<p>Tips：</p><ol><li>AVLTree是二叉搜索树的进一步变种</li><li>使用在AVLTree中的类需要实现Compareable接口</li><li>建议先理解链表与二叉树相关知识</li></ol><p><a href="https://github.com/JanWarlen/DemoList/blob/master/DataStructDemo/src/main/java/com/janwarlen/btree/AVLTree.java">demo代码</a></p><span id="more"></span><h4 id="理论背景"><a href="#理论背景" class="headerlink" title="理论背景"></a>理论背景</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>AVLTree首先是二叉搜索树</li><li>带有平衡条件：每个节点的左右节点的高度差值不超过1（左子数，右子树）</li><li>每个节点的左子树与右子树都是AVLTree</li></ul><center>![AVLTree](http://img.janwarlen.com/18-4-16/94024279.jpg)</center>  <center>图1(AVLTree)</center>  <center>![二叉树](http://img.janwarlen.com/18-4-16/91461504.jpg)</center>  <center>图2(非AVLTree)</center><h5 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h5><p>节点的插入与删除都有可能会造成操作节点至根节点的所有节点的平衡信息，因此在执行插入和删除节点（单节点操作，非批量）后需要对树进行简单的修正来恢复平衡，这种操作就是旋转。<br>旋转一共适应四种情况：</p><ul><li>对节点x的左节点的左子树进行了一次插入  </li><li>对节点x的左节点的右子树进行了一次插入  </li><li>对节点x的右节点的左子树进行了一次插入  </li><li>对节点x的右节点的右子树进行了一次插入  <h5 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h5><img src="http://img.janwarlen.com/18-4-16/89314830.jpg" alt="单旋转示意图"><br>该示意图展示了第一个情况下的单旋转过程，图中节点a即情况中的节点x，<code>L1</code>即为左子树，至于插入的节点是<code>L1</code>中的哪一个则无关紧要，因为都是导致<code>L1</code>高度增加。因<code>L1</code>的高度增加，则对于节点a来说，左子树与右子树的高度差大于1，因此满足了旋转操作条件；<br>为了将树恢复平衡，我们需要将<code>L1</code>上移一层，并且将右子树<code>R1</code>下移一层，因此将节点b提升到根节点，此时右节点存在多个，因此根据二叉查询树的性质，子树R2是小于节点a的，因此断开节点b与子树R2的链接，将子树R2作为节点a的左子树。<h5 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h5><img src="http://img.janwarlen.com/18-4-17/89508273.jpg" alt="双旋转示意图"><br>该示意图展示了双旋转解决的一种情况，实际操作中b&#x2F;c仅会存在一个，因为插入b或者c时就会触发旋转操作。在示意图中，初始树无论是左单旋转还是右单旋转都无法一次平衡，因此，先进行局部旋转，待一次局部旋转后，二叉树将会转化为可单旋转的结构，此时再进行相应单旋转即可平衡二叉树。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h5><p>首先，因为AVLTree的特性是每个节点的左右子节点的高度差不大于1（另有说法为平衡因子），因此节点除了含有常规二叉树元素还需一个元素记录改节点高度，最终设计节点结构如下：<br><img src="http://img.janwarlen.com/18-4-17/78737741.jpg" alt="AVLTree 节点结构"><br>根据结构图设计节点代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(element, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T element, Node&lt;T&gt; l, Node&lt;T&gt; r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.element = element;</span><br><span class="line">        <span class="built_in">this</span>.left = l;</span><br><span class="line">        <span class="built_in">this</span>.right = r;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T element;</span><br><span class="line">    Node&lt;T&gt; left;</span><br><span class="line">    Node&lt;T&gt; right;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h5><h6 id="左单旋转"><a href="#左单旋转" class="headerlink" title="左单旋转"></a>左单旋转</h6><p>此处的左单旋转不是向左转，而是左子树进行旋转操作<br><img src="http://img.janwarlen.com/18-4-17/81615402.jpg" alt="左单旋转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左单旋转</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">rotateWithLeftChild</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    Node&lt;T&gt; left = ele.left;</span><br><span class="line">    ele.left = left.right;</span><br><span class="line">    left.right = ele;</span><br><span class="line">    ele.height = Math.max(height(ele.left), height(ele.right)) + <span class="number">1</span>;</span><br><span class="line">    left.height = Math.max(height(left.left), height(left.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="右单旋转"><a href="#右单旋转" class="headerlink" title="右单旋转"></a>右单旋转</h6><p><img src="http://img.janwarlen.com/18-4-17/15092152.jpg" alt="右单旋转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右单旋转</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">rotateWithRightChild</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    Node&lt;T&gt; right = ele.right;</span><br><span class="line">    ele.right = right.left;</span><br><span class="line">    right.left = ele;</span><br><span class="line">    ele.height = Math.max(height(ele.left), height(ele.right)) + <span class="number">1</span>;</span><br><span class="line">    right.height = Math.max(height(right.left), height(right.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="左双旋转"><a href="#左双旋转" class="headerlink" title="左双旋转"></a>左双旋转</h6><p><img src="http://img.janwarlen.com/18-4-17/60894239.jpg" alt="左双旋转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左双旋转</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">doubleWithLeftChild</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    ele.left = rotateWithRightChild(ele.left);</span><br><span class="line">    <span class="keyword">return</span> rotateWithLeftChild(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="右双旋转"><a href="#右双旋转" class="headerlink" title="右双旋转"></a>右双旋转</h6><p><img src="http://img.janwarlen.com/18-4-17/80162235.jpg" alt="右双旋转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右双旋转</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">doubleWithRightChild</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    ele.right = rotateWithLeftChild(ele.right);</span><br><span class="line">    <span class="keyword">return</span> rotateWithRightChild(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">balance</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == ele) &#123;</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左子树高于右子树</span></span><br><span class="line">    <span class="keyword">if</span> (height(ele.left) - height(ele.right) &gt; ALLOWED_IMBALANCE) &#123;</span><br><span class="line">        <span class="comment">//判断需要单旋转还是双旋转</span></span><br><span class="line">        <span class="keyword">if</span> (height(ele.left.left) &gt;= height(ele.left.right)) &#123;</span><br><span class="line">            <span class="comment">//左单旋转</span></span><br><span class="line">            ele = rotateWithLeftChild(ele);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//左双旋转</span></span><br><span class="line">            ele = doubleWithLeftChild(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右子树高于左子树</span></span><br><span class="line">    <span class="keyword">if</span> (height(ele.right) - height(ele.left) &gt; ALLOWED_IMBALANCE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height(ele.right.right) &gt;= height(ele.right.left)) &#123;</span><br><span class="line">            <span class="comment">//右单旋转</span></span><br><span class="line">            ele = rotateWithRightChild(ele);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//右双旋转</span></span><br><span class="line">            ele = doubleWithRightChild(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新计算节点高度</span></span><br><span class="line">    ele.height = Math.max(height(ele.left), height(ele.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ele;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>下图示例从1-9的插入过程，涵盖需要旋转情况并不全面<br><img src="http://img.janwarlen.com/18-4-18/22401721.jpg" alt="插入示例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node&lt;T&gt; <span class="title function_">insert</span><span class="params">(T element, Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == ele) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;T&gt;(element);</span><br><span class="line">    &#125;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; comparableEle = (Comparable&lt;? <span class="built_in">super</span> T&gt;) element;</span><br><span class="line">    <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> comparableEle.compareTo(ele.element);</span><br><span class="line">    <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        ele.left = insert(element, ele.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareRes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        ele.right = insert(element, ele.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//duplicate</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逐层平衡</span></span><br><span class="line">    <span class="keyword">return</span> balance(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>下图示例元素6（右子树找最小）与元素5的删除过程。<br><img src="http://img.janwarlen.com/18-4-18/60876473.jpg" alt="删除 示例"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; <span class="title function_">remove</span><span class="params">(T element, Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == ele) &#123;</span><br><span class="line">            <span class="keyword">return</span> ele;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; comparableEle = (Comparable&lt;? <span class="built_in">super</span> T&gt;) element;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> comparableEle.compareTo(ele.element);</span><br><span class="line">        <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ele.left = remove(element, ele.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareRes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ele.right = remove(element, ele.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != ele.left &amp;&amp; <span class="literal">null</span> != ele.right) &#123;</span><br><span class="line">                ele.element = findMax(ele.left).element;</span><br><span class="line">                ele.left = remove(ele.element, ele.left);</span><br><span class="line">            <span class="comment">//此处理论从左子树找最大和右子树找最小并无明显区别，因为最后都会经balance进行平衡</span></span><br><span class="line"><span class="comment">//            ele.element = findMin(ele.right).element;</span></span><br><span class="line"><span class="comment">//            ele.right = remove(ele.element, ele.right);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ele = (<span class="literal">null</span> != ele.left) ? ele.left : ele.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐层平衡</span></span><br><span class="line">        <span class="keyword">return</span> balance(ele);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Tips：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AVLTree是二叉搜索树的进一步变种&lt;/li&gt;
&lt;li&gt;使用在AVLTree中的类需要实现Compareable接口&lt;/li&gt;
&lt;li&gt;建议先理解链表与二叉树相关知识&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JanWarlen/DemoList/blob/master/DataStructDemo/src/main/java/com/janwarlen/btree/AVLTree.java&quot;&gt;demo代码&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="数据结构" scheme="http://janwarlen.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="AVLTree" scheme="http://janwarlen.com/tags/AVLTree/"/>
    
    <category term="二叉树" scheme="http://janwarlen.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="一步一步数据结构" scheme="http://janwarlen.com/tags/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读-LinkedList</title>
    <link href="http://janwarlen.com/2018/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-LinkedList/"/>
    <id>http://janwarlen.com/2018/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-LinkedList/</id>
    <published>2018-03-25T02:53:49.000Z</published>
    <updated>2022-05-31T18:26:48.314Z</updated>
    
    <content type="html"><![CDATA[<p>Tips：  </p><ol><li>如果要在集合中使用自定义类，建议重写equals函数  </li><li>如果集合内元素较多，使用结束后建议清空（GC）  </li><li>LinkedList所提供的原生函数无批处理，所以会有线程安全的假象，但是它并非线程安全，并且因为不想ArrayList提供批处理函数（函数内针对线程安全做了一定的处理），所以在使用LinkedList时需要格外注意  </li><li>链表核心在于指针（即引用），可以先行了解这部分  </li><li>本次未像ArrayList提供基础代码调用实现  <span id="more"></span></li></ol><h4 id="继承实现关系图"><a href="#继承实现关系图" class="headerlink" title="继承实现关系图"></a>继承实现关系图</h4><p><img src="http://img.janwarlen.com/18-3-20/39848976.jpg" alt="LinkedList"><br><strong>蓝色实线为继承，色虚线为实现,红色为内部类</strong></p><h4 id="链表简单结构示意图"><a href="#链表简单结构示意图" class="headerlink" title="链表简单结构示意图"></a>链表简单结构示意图</h4><p><img src="http://img.janwarlen.com/18-3-20/19679659.jpg" alt="LinkedList_Node"><br><strong>此为LinkedList的节点结构与队列模拟展示，属于数据结构中的双向链表</strong></p><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h4><table><thead><tr><th>参数</th><th>释义</th></tr></thead><tbody><tr><td>size</td><td>链表节点数目</td></tr><tr><td>first</td><td>链表头节点指针</td></tr><tr><td>last</td><td>链表尾节点指针</td></tr></tbody></table><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">       E item;<span class="comment">//节点内存储值</span></span><br><span class="line">       Node&lt;E&gt; next;<span class="comment">//指针，指向后一个节点</span></span><br><span class="line">       Node&lt;E&gt; prev;<span class="comment">//指针，指向前一个节点</span></span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           <span class="built_in">this</span>.item = element;</span><br><span class="line">           <span class="built_in">this</span>.next = next;</span><br><span class="line">           <span class="built_in">this</span>.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据集合创建链表</span></span><br><span class="line"><span class="comment">//实际是先创建空链表，再遍历集合加入链表</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>();</span><br><span class="line">       addAll(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h4><h5 id="头部增加节点"><a href="#头部增加节点" class="headerlink" title="头部增加节点"></a>头部增加节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       linkFirst(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//@since 1.6</span></span><br><span class="line">   <span class="comment">//个人认为就是为了修改方法名而存在的方法</span></span><br><span class="line">   <span class="comment">//push和pop应该算是链表的标准操作</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       addFirst(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   <span class="comment">// 创建指针指向头指针指向地址</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="comment">//创建节点，该节点next指针使用刚刚创建的指针f</span></span><br><span class="line">       <span class="comment">//即将新节点的后节点指向头结点</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">       <span class="comment">//first指针指向刚创建的节点</span></span><br><span class="line">       first = newNode;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">       <span class="comment">//如果当前链表为空，则f将会指向null</span></span><br><span class="line">       <span class="comment">//则新节点不仅是头结点也是尾节点</span></span><br><span class="line">           last = newNode;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       <span class="comment">//因为f指向的是之前的头节点，目前的第二节点</span></span><br><span class="line">       <span class="comment">//因此需要将节点的prev指针指向现在的头结点，完成结构搭建</span></span><br><span class="line">           f.prev = newNode;</span><br><span class="line">       <span class="comment">//节点数目+1</span></span><br><span class="line">       size++;</span><br><span class="line">       <span class="comment">//修改次数+1</span></span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="尾部增加节点"><a href="#尾部增加节点" class="headerlink" title="尾部增加节点"></a>尾部增加节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       linkLast(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   <span class="comment">//创建指针指向尾指针指向地址</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="comment">//创建新节点，新节点的前指针指向尾指针(l)指向地址</span></span><br><span class="line">       <span class="comment">//后指针指向null</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">       <span class="comment">//链表尾指针指向新节点</span></span><br><span class="line">       last = newNode;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">       <span class="comment">//如果原链表为空，则新节点同时也是头结点</span></span><br><span class="line">           first = newNode;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       <span class="comment">//l原本指向尾节点，现在是倒数第二</span></span><br><span class="line">       <span class="comment">//因此l指向的节点的后指针应指向新节点完成结构搭建</span></span><br><span class="line">           l.next = newNode;</span><br><span class="line">       <span class="comment">//节点数目+1</span></span><br><span class="line">       size++;</span><br><span class="line">       <span class="comment">//修改次数+1</span></span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="增加一个节点"><a href="#增加一个节点" class="headerlink" title="增加一个节点"></a>增加一个节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"><span class="comment">//使用尾部添加方式</span></span><br><span class="line">       linkLast(e);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       addFirst(e);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       addLast(e);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       addFirst(e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="指定位置添加一个节点"><a href="#指定位置添加一个节点" class="headerlink" title="指定位置添加一个节点"></a>指定位置添加一个节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//索引位置校验</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">//尾部追加方式</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//指定index插入方式</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//创建新节点，前指针指向的原节点的前指针指向节点</span></span><br><span class="line">    <span class="comment">//尾指针指向原节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//断开原节点的前指针，指向新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//原节点的前指针为空则说明插入位置为链表头部</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//将前一个节点的后指针断开，指向新节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">//节点数目+1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="指定位置通过集合添加节点"><a href="#指定位置通过集合添加节点" class="headerlink" title="指定位置通过集合添加节点"></a>指定位置通过集合添加节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line"><span class="comment">//检查索引位置是否合法[0,size]</span></span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用collection函数，将集合元素抽取为数组</span></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">       <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">       <span class="comment">//如果集合为空，则直接返回</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明前指针，后指针</span></span><br><span class="line">       Node&lt;E&gt; pred, succ;</span><br><span class="line">       <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">       <span class="comment">//如果插入位置与数量size相等</span></span><br><span class="line">       <span class="comment">//则是尾部追加</span></span><br><span class="line">           succ = <span class="literal">null</span>;</span><br><span class="line">           pred = last;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//将后指针指向指定位置节点</span></span><br><span class="line">           succ = node(index);</span><br><span class="line"><span class="comment">//将前指针指向指定位置节点的前一个节点</span></span><br><span class="line">           pred = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">       <span class="comment">//使用pred作为前指针，创建只有前指针的节点</span></span><br><span class="line">           <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">           Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">               <span class="comment">//前指针为空意味着链表为空，当前创建节点为链表头结点</span></span><br><span class="line">               <span class="comment">//需要将首指针指向该节点</span></span><br><span class="line">               first = newNode;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">//链表不为空，则需要将前面的节点的后指针指向创建节点</span></span><br><span class="line">               pred.next = newNode;</span><br><span class="line">           <span class="comment">//pred指针后移</span></span><br><span class="line">           pred = newNode;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//succ指向原本位置在index的节点</span></span><br><span class="line">       <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//succ为空，则至少说明是尾部追加</span></span><br><span class="line">           <span class="comment">//需要将尾指针指向该节点</span></span><br><span class="line">           last = pred;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//将创建的最后一个节点的后指针指向原本位于index的节点</span></span><br><span class="line">           <span class="comment">//将原节点的前指针指向创建的最后一个节点</span></span><br><span class="line">           <span class="comment">//完成最后的连接构建</span></span><br><span class="line">           pred.next = succ;</span><br><span class="line">           succ.prev = pred;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//刷新链表大小</span></span><br><span class="line">       size += numNew;</span><br><span class="line">       <span class="comment">//修改次数+1</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引找到节点</span></span><br><span class="line">   Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">       <span class="comment">//如果索引在前半部，则使用头结点正向遍历查找</span></span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//如果索引在后半部，则使用尾节点反向遍历查找</span></span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="尾部添加集合"><a href="#尾部添加集合" class="headerlink" title="尾部添加集合"></a>尾部添加集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">       <span class="comment">//直接传入size</span></span><br><span class="line">       <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><h5 id="删除头节点"><a href="#删除头节点" class="headerlink" title="删除头节点"></a>删除头节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//防止链表为空</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法与上一个方法的区别就是健壮性</span></span><br><span class="line"><span class="comment">//当链表为空时，不会抛出异常，而是null</span></span><br><span class="line"><span class="comment">//@since 1.5</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@since 1.6</span></span><br><span class="line"><span class="comment">//只改了 一个方法名称，之所以保留上一个方法</span></span><br><span class="line"><span class="comment">//应该是出于兼容问题考虑，防止有的用户升级了jdk版本</span></span><br><span class="line"><span class="comment">//但是没有完全的修改好已经使用的方法</span></span><br><span class="line"><span class="comment">//也怀疑是方便推广</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@since 1.6</span></span><br><span class="line"><span class="comment">//同考虑为只是修改方法名，或者说降低使用难度（针对英语为母语）</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//个人认为该方法只是为了重载，无明显含义</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="comment">//保留下头结点内部value</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">    <span class="comment">//新指针指向第二个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">//释放第一节点值域</span></span><br><span class="line">    f.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//断开头结点与第二节点连接</span></span><br><span class="line">    f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//头指针指向第二节点</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//防止头结点被移除后，链表为空</span></span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//第二节点与原头结点连接断开</span></span><br><span class="line">        next.prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//链表节点数目-1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//返回原头结点保存的值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除尾节点"><a href="#删除尾节点" class="headerlink" title="删除尾节点"></a>删除尾节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//防止链表为空</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@since 1.6</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="comment">//保留一份尾节点值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">    <span class="comment">//新指针指向倒数第二个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">//释放尾节点值域</span></span><br><span class="line">    l.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//断开尾节点与倒数第二节点连接</span></span><br><span class="line">    l.prev = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//尾指针指向倒数第二节点</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//若原链表仅有一个节点，则移除后需要处理头指针</span></span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//断开倒数第二节点与尾节点的连接</span></span><br><span class="line">        prev.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//刷新链表大小-1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//返回原尾结点保存的值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="根据内容删除节点"><a href="#根据内容删除节点" class="headerlink" title="根据内容删除节点"></a>根据内容删除节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@since 1.6</span></span><br><span class="line"><span class="comment">//来自语言的满满恶意</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//区分null是因为空无法使用equals函数比较</span></span><br><span class="line">        <span class="comment">//从头结点开始，正向遍历查找</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">//因为使用的是传入对象的equals方法进行对比，因此</span></span><br><span class="line">            <span class="comment">//使用自定义对象的时候，建议重写equals方法</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@since 1.6</span></span><br><span class="line"><span class="comment">//来自语言的满满恶意</span></span><br><span class="line"><span class="comment">//此方法有些许不同，它是删除最后一个出现的，即反向查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">//将待移除节点值域、指针保留，一份副本</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//前指针为空，则该节点为头结点</span></span><br><span class="line">        <span class="comment">//需要将头指针后移</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//修改前一个节点的后指针指向该节点的后指针指向地址</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">//断开该节点与前一个节点的连接</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//后指针为空，则该节点是尾节点</span></span><br><span class="line">        <span class="comment">//需要将尾指针前移</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//修改后一个节点的前指针指向该节点的前指针指向地址</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">//断开该节点与后一个节点的连接</span></span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//置空该节点值域</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//节点数目-1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    返回被移除节点保存内容</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除指定位置节点"><a href="#删除指定位置节点" class="headerlink" title="删除指定位置节点"></a>删除指定位置节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//校验index合法</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="节点清空"><a href="#节点清空" class="headerlink" title="节点清空"></a>节点清空</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="comment">//理论上不用清除每一个节点的指针连接，但是这能帮助减少GC压力，因为</span></span><br><span class="line">    <span class="comment">//丢弃的节点依然会存在内存中互相引用</span></span><br><span class="line">    <span class="comment">//正向遍历清空每一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="literal">null</span>;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//刷新头指针与尾指针</span></span><br><span class="line">    first = last = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//刷新链表大小</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h4><h5 id="修改指定索引节点"><a href="#修改指定索引节点" class="headerlink" title="修改指定索引节点"></a>修改指定索引节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法虽然修改了节点</span></span><br><span class="line"><span class="comment">//但是并没有修改modCount</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//校验index合法</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//找出指定位置节点</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">//保留一份值的副本</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="comment">//修改节点的值</span></span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="comment">//返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><h5 id="获取头结点"><a href="#获取头结点" class="headerlink" title="获取头结点"></a>获取头结点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的是节点的值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@since 1.5</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@since 1.5</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@since 1.6</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取尾节点"><a href="#获取尾节点" class="headerlink" title="获取尾节点"></a>获取尾节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回节点值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断是否含有节点"><a href="#判断是否含有节点" class="headerlink" title="判断是否含有节点"></a>判断是否含有节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过值判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询节点索引位置"><a href="#查询节点索引位置" class="headerlink" title="查询节点索引位置"></a>查询节点索引位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正向，返回第一次出现的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反向，返回第一次出现的索引</span></span><br><span class="line"><span class="comment">//因为是反向查找，所以结果对于正向来说是最后一次出现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询指定索引节点"><a href="#查询指定索引节点" class="headerlink" title="查询指定索引节点"></a>查询指定索引节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Tips：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果要在集合中使用自定义类，建议重写equals函数  &lt;/li&gt;
&lt;li&gt;如果集合内元素较多，使用结束后建议清空（GC）  &lt;/li&gt;
&lt;li&gt;LinkedList所提供的原生函数无批处理，所以会有线程安全的假象，但是它并非线程安全，并且因为不想ArrayList提供批处理函数（函数内针对线程安全做了一定的处理），所以在使用LinkedList时需要格外注意  &lt;/li&gt;
&lt;li&gt;链表核心在于指针（即引用），可以先行了解这部分  &lt;/li&gt;
&lt;li&gt;本次未像ArrayList提供基础代码调用实现</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="集合" scheme="http://janwarlen.com/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="SourceCode" scheme="http://janwarlen.com/tags/SourceCode/"/>
    
    <category term="源码阅读" scheme="http://janwarlen.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
