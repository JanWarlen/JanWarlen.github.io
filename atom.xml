<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一帆磨砺</title>
  
  <subtitle>生活所迫，一叶孤舟</subtitle>
  <link href="http://janwarlen.com/atom.xml" rel="self"/>
  
  <link href="http://janwarlen.com/"/>
  <updated>2022-06-13T14:34:02.110Z</updated>
  <id>http://janwarlen.com/</id>
  
  <author>
    <name>Jan Warlen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java版本特性-JDK9</title>
    <link href="http://janwarlen.com/2022/06/11/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK9/"/>
    <id>http://janwarlen.com/2022/06/11/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK9/</id>
    <published>2022-06-11T10:05:32.000Z</published>
    <updated>2022-06-13T14:34:02.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol><li><a href="https://docs.oracle.com/javase/9/">Oracle Java9官方文档</a></li><li><a href="https://www.oracle.com/java/technologies/javase/9-relnotes.html">JDK 9 Release Notes</a></li><li><a href="http://openjdk.java.net/projects/jigsaw/quick-start">Module System Quick-Start Guide</a></li><li><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-7744EF96-5899-4FB2-B34E-86D49B2E89B6">JDK9迁移指南</a></li><li><a href="http://openjdk.java.net/jeps/213">Milling Project Coin</a></li><li><a href="http://openjdk.java.net/jeps/282">jlink: The Java Linker</a></li><li><a href="http://openjdk.java.net/jeps/222">The Java Shell</a></li></ol><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol><li>本文仅涉及部分JDK9变更，完整可查看官方文档<a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm">Standard Edition What’s New in Oracle JDK 9</a></li><li>除了模块化，其他改动对日常开发影响不多，可以着重关注模块化和接口私有函数</li></ol><span id="more"></span><h1 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="ModularDemo"><a href="#ModularDemo" class="headerlink" title="ModularDemo"></a><a href="https://github.com/JanWarlen/ModularDemo">ModularDemo</a></h3><p>因目前Oracle开放的JDK下载版本仅有8&#x2F;11&#x2F;17&#x2F;18，因此该项目通过JDK18编译JDK9(Project language level设置为9)模拟</p><h4 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h4><p><img src="http://img.janwarlen.com/blog/Modular-%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="Modular"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><code>common</code>与<code>service</code>是在 Maven 层面上的子模块,JDK9的模块化主要通过类<code>module-info.java</code></li><li>每个工程(模块)仅可有一个<code>module-info.java</code></li><li>对外开放的最小粒度是<code>package</code>，无法以类作为最小单位，如果有类不愿对外开放，建议迁移到单独的包中</li><li>打包后，虽然<code>common</code>没有开放<code>intern</code>包，但是最终common.jar中还是会有<code>intern</code>中的类</li><li>如果类不惜那个对外开放，但是其中部分功能还需要对外使用，可以单独在对外开放的包中新建一个类，作为转发调用</li><li>从初步的使用感觉，目前仅在权限控制方面有明显的作用</li><li><code>maven-compiler-plugin</code>仅在<code>3.8.0+</code>才支持<code>module</code>(可查看<code>ModularDemo/pom.xml</code>)</li></ol><h1 id="jlink"><a href="#jlink" class="headerlink" title="jlink"></a>jlink</h1><p>可以自定义Java程序运行时的JRE环境</p><h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jlink --module-path &lt;modulepath&gt; --add-modules &lt;modules&gt; --limit-modules &lt;modules&gt; --output &lt;path&gt;</span><br><span class="line">module-path: 指的是你自定义的JRE环境所有需要的module所处的路径</span><br><span class="line">add-modules: 在 module-path 中，你需要那些module</span><br><span class="line">limit-modules: 根据module名称限制搜寻范围</span><br><span class="line">output: 自定义JRE的输出路径</span><br><span class="line"></span><br><span class="line">jlink --output service/src/main/resources/jre --module-path &quot;service/src/main/resources&quot; --add-modules common</span><br><span class="line">我将入门案例中的common的jar包拷贝到service/src/main/resources中，因此 module-path 就是 &quot;service/src/main/resources&quot;，而因 service 仅需要 common 一个模块，因此我只添加了 common</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ol><li>自定义的JRE环境没有无关的jar包，因此启动内存消耗会少<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;totalMemory:&quot;</span> + Runtime.getRuntime().totalMemory()/ (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;freeMemory:&quot;</span> + Runtime.getRuntime().freeMemory()/ (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;maxMemory:&quot;</span> + Runtime.getRuntime().maxMemory()/ (<span class="number">1024</span> * <span class="number">1024</span>));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(base) MacBook-Pro ModularDemo % ./service/src/main/resources/jre/bin/java -jar service/target/service-1.0-SNAPSHOT.jar</span><br><span class="line">hello</span><br><span class="line">this is private class.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">false</span><br><span class="line">totalMemory:512</span><br><span class="line">freeMemory:510</span><br><span class="line">maxMemory:8192</span><br><span class="line">(base) MacBook-Pro ModularDemo % java -jar service/target/service-1.0-SNAPSHOT.jar </span><br><span class="line">hello</span><br><span class="line">this is private class.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">false</span><br><span class="line">totalMemory:520</span><br><span class="line">freeMemory:514</span><br><span class="line">maxMemory:8192</span><br></pre></td></tr></table></figure></li><li>可以根据应用自定义不同的JRE，而不用将所有 module 对全部应用开放</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>初步感受，该功能在嵌入式领域可以发挥非常重要的作用，在服务器端程序，作用可能没有那么明显</li><li>最好可以搭配<a href="http://openjdk.java.net/jeps/200">The Modular JDK</a>、<a href="http://openjdk.java.net/jeps/201">Modular Source Code</a>、<a href="http://openjdk.java.net/jeps/220">Modular Run-Time Images</a>一起使用，效果更佳(此处埋坑，以后有时间再回头来研究这三个)</li></ol><h1 id="正则-调整作用范围"><a href="#正则-调整作用范围" class="headerlink" title="正则^调整作用范围"></a>正则<code>^</code>调整作用范围</h1><p>将作用到整个表达式，而不是第一个group</p><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[^a-b[c-d]e-f]&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">a</span> <span class="operator">=</span> compile.matcher(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">c</span> <span class="operator">=</span> compile.matcher(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// JDK8 false JDK9 false</span></span><br><span class="line">System.out.println(a.matches());</span><br><span class="line"><span class="comment">// JDK8 true JDK9 false</span></span><br><span class="line">System.out.println(c.matches());</span><br></pre></td></tr></table></figure><h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><p>可以在try外部声明变量，将变量名放在try中即可，但是该变量受<code>final or effectively final</code>规则限制，即在初始化完成后不可再次进行赋值操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Files.newInputStream(Paths.get(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> (in) &#123;</span><br><span class="line">    <span class="comment">// JDK8中该用法会有以下异常提示</span></span><br><span class="line">    <span class="comment">// Resource references are not supported at language level &#x27;8&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名类的泛型推断"><a href="#匿名类的泛型推断" class="headerlink" title="匿名类的泛型推断"></a>匿名类的泛型推断</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InferredType</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// JDK8 中会有如下异常提示</span></span><br><span class="line">    <span class="comment">// Class &#x27;Anonymous class derived from InferredType&#x27; must either be declared abstract or implement abstract method &#x27;test(T)&#x27; in &#x27;InferredType&#x27;</span></span><br><span class="line">    InferredType&lt;String&gt; inferredType = <span class="keyword">new</span> <span class="title class_">InferredType</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String o)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="允许接口定义private方法"><a href="#允许接口定义private方法" class="headerlink" title="允许接口定义private方法"></a>允许接口定义private方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PrivateFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        func3();</span><br><span class="line">        <span class="comment">// JDK8+</span></span><br><span class="line">        System.out.println(<span class="string">&quot;默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">func3</span><span class="params">()</span> &#123;</span><br><span class="line">        func4();</span><br><span class="line">        System.out.println(<span class="string">&quot;私有默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态私有实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以起到优化重复代码的帮助</li></ol><h1 id="不可作为变量名"><a href="#不可作为变量名" class="headerlink" title="_不可作为变量名"></a><code>_</code>不可作为变量名</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// As of Java 9, &#x27;_&#x27; is a keyword, and may not be used as an identifier</span></span><br><span class="line"><span class="comment">// JDK8 是可以正常使用的，影响不大，几乎很少有场景会单独使用 _ 作为变量名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">_</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure><h1 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="comment">// 不用该注解，仅会导致编译器提示，不会异常</span></span><br><span class="line"><span class="comment">// 此注解用于泛型可变入参函数，JDK9是拓展至可声明private函数</span></span><br><span class="line"><span class="comment">//  Possible heap pollution from parameterized vararg type</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  &lt;T&gt; <span class="keyword">void</span> <span class="title function_">saveVarargs</span><span class="params">(T... params)</span> &#123;</span><br><span class="line">    Arrays.stream(params).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Class文件版本号变动至53"><a href="#Class文件版本号变动至53" class="headerlink" title="Class文件版本号变动至53"></a>Class文件版本号变动至53</h1><h1 id="编译旧版本范围变动"><a href="#编译旧版本范围变动" class="headerlink" title="编译旧版本范围变动"></a>编译旧版本范围变动</h1><blockquote><p>The javac command no longer supports -source or-target values for releases before 6&#x2F;1.6. However, older class files are still readable by javac. Source code for an older release can be ported to a newer source level. To generate class files usable by releases older than JDK 6, a javac from a JDK 6, 7, or 8 release family can be used.<br><a href="https://openjdk.java.net/jeps/182">JEP 182</a> documents the policy for retiring old -source and -target options.  </p></blockquote><p>JDK9在使用javac编译java文件时，指定java的版本仅支持*1.6+*，不再支持编译到1.5以及更早期的版本</p><h1 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h1><p>引用官方原文</p><blockquote><p>Immediate feedback is important when learning a programming language and its APIs. The number one reason schools cite for moving away from Java as a teaching language is that other languages have a “REPL” and have far lower bars to an initial “Hello, world!” program. A Read-Eval-Print Loop (REPL) is an interactive programming tool which loops, continually reading user input, evaluating the input, and printing the value of the input or a description of the state change the input caused. Scala, Ruby, JavaScript, Haskell, Clojure, and Python all have REPLs and all allow small initial programs. JShell adds REPL functionality to the Java platform.<br>Exploration of coding options is also important for developers prototyping code or investigating a new API. Interactive evaluation is vastly more efficient in this regard than edit&#x2F;compile&#x2F;execute and System.out.println.<br>Without the ceremony of class Foo { public static void main(String[] args) { … } }, learning and exploration is streamlined.</p></blockquote><p>大致含义是降低Java学习的入门门槛，可以更方便的测试API<br>吐槽:</p><ol><li>对于习惯了ide的代码提示和代码模板(<code>code templates</code>)来说，突然使用<code>jshell</code>会有些难受</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/&quot;&gt;Oracle Java9官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.oracle.com/java/technologies/javase/9-relnotes.html&quot;&gt;JDK 9 Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/quick-start&quot;&gt;Module System Quick-Start Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-7744EF96-5899-4FB2-B34E-86D49B2E89B6&quot;&gt;JDK9迁移指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/213&quot;&gt;Milling Project Coin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/282&quot;&gt;jlink: The Java Linker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openjdk.java.net/jeps/222&quot;&gt;The Java Shell&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;本文仅涉及部分JDK9变更，完整可查看官方文档&lt;a href=&quot;https://docs.oracle.com/javase/9/whatsnew/toc.htm&quot;&gt;Standard Edition What’s New in Oracle JDK 9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;除了模块化，其他改动对日常开发影响不多，可以着重关注模块化和接口私有函数&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="模块系统" scheme="http://janwarlen.com/tags/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="REPL (JShell)" scheme="http://janwarlen.com/tags/REPL-JShell/"/>
    
    <category term="JDK9" scheme="http://janwarlen.com/tags/JDK9/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-StreamAPI</title>
    <link href="http://janwarlen.com/2022/06/08/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-StreamAPI/"/>
    <id>http://janwarlen.com/2022/06/08/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-StreamAPI/</id>
    <published>2022-06-08T12:13:11.000Z</published>
    <updated>2022-06-10T19:21:32.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h3><ol><li><a href="https://dev.java/learn/the-stream-api/">Java官方学习手册-Stream</a></li><li><a href="https://github.com/CarpenterLee/JavaLambdaInternals">GitHub-CarpenterLee-JavaLambdaInternals</a></li><li><a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html">Oracle关于parallelism官方文档</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description">Oracle关于Stream包官方描述文档</a><span id="more"></span></li></ol><h2 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol><li>Stream API 是关于向 JDK 提供众所周知的 map-filter-reduce 算法的实现</li><li><code>map</code>只会变更对象的类型，不会改变对象集合的数量</li><li><code>filter</code>只会改变对象集合的数量，而不会改变其中对象的类型</li><li><code>reduce</code>允许针对数据流构建任何你想构建的数据结构</li></ol><h4 id="案例-统计所有人口超过10w的城市人口总和"><a href="#案例-统计所有人口超过10w的城市人口总和" class="headerlink" title="案例 - 统计所有人口超过10w的城市人口总和"></a>案例 - 统计所有人口超过10w的城市人口总和</h4><h5 id="城市类定义"><a href="#城市类定义" class="headerlink" title="城市类定义"></a>城市类定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">City</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">City</span><span class="params">(String name, <span class="type">int</span> population)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.population = population;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 城市名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 城市人口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> population;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPopulation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> population;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPopulation</span><span class="params">(<span class="type">int</span> population)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.population = population;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;City&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, population=&quot;</span> + population +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;City&gt; cities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">City</span> <span class="variable">city1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;1&quot;</span>, <span class="number">50_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;2&quot;</span>, <span class="number">2_100_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;3&quot;</span>, <span class="number">90_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;4&quot;</span>, <span class="number">130_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;5&quot;</span>, <span class="number">1_000_000</span>);</span><br><span class="line">cities.add(city1);</span><br><span class="line">cities.add(city2);</span><br><span class="line">cities.add(city3);</span><br><span class="line">cities.add(city4);</span><br><span class="line">cities.add(city5);</span><br></pre></td></tr></table></figure><h5 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (City city : cities) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">population</span> <span class="operator">=</span> city.getPopulation();</span><br><span class="line">    <span class="keyword">if</span> (population &gt; <span class="number">100_000</span>) &#123;</span><br><span class="line">        sum += population;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure><h5 id="StreamApi写法"><a href="#StreamApi写法" class="headerlink" title="StreamApi写法"></a>StreamApi写法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步先创建流</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> cities.stream()</span><br><span class="line"><span class="comment">// 第二步 将城市集合转换为人口集合</span></span><br><span class="line">        .mapToInt(City::getPopulation)</span><br><span class="line"><span class="comment">// 第三步 过滤人口超过 10w 的城市人口</span></span><br><span class="line">        .filter(population -&gt; population &gt; <span class="number">100_000</span>)</span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line">        .sum();</span><br><span class="line">System.out.println(<span class="string">&quot;Stream Sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h4><h5 id="创建一个空流"><a href="#创建一个空流" class="headerlink" title="创建一个空流"></a>创建一个空流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.empty()</span><br></pre></td></tr></table></figure><p>一般场景不会用到，通常与<code>flatMap</code>结合使用，过滤不需要的元素</p><h5 id="从可变参数或数组创建流"><a href="#从可变参数或数组创建流" class="headerlink" title="从可变参数或数组创建流"></a>从可变参数或数组创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Arrays.stream(array)</span><br></pre></td></tr></table></figure><h5 id="给定规则创建流并持续添加元素"><a href="#给定规则创建流并持续添加元素" class="headerlink" title="给定规则创建流并持续添加元素"></a>给定规则创建流并持续添加元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Supplier&lt;T&gt; s)</span><br><span class="line"></span><br><span class="line">Stream.generate(() -&gt; <span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><p>需注意的是，该方法将会无限制的添加元素进入流中，需要搭配<code>limit</code>使用，避免<code>OOM</code></p><h5 id="创建符合一定规则的流"><a href="#创建符合一定规则的流" class="headerlink" title="创建符合一定规则的流"></a>创建符合一定规则的流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// seed是第一个元素， UnaryOperator则是所有后续元素将要遵守的规则</span></span><br><span class="line">Stream.iterate(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">Stream.iterate(<span class="string">&quot;+&quot;</span>, s -&gt; s + <span class="string">&quot;+&quot;</span>)</span><br><span class="line"><span class="comment">// +</span></span><br><span class="line"><span class="comment">// ++</span></span><br><span class="line"><span class="comment">// +++</span></span><br><span class="line"><span class="comment">// ++++</span></span><br><span class="line"><span class="comment">// +++++</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>通常需要搭配<code>limit</code>使用,<code>Java9</code>该方法添加了重载，添加了入参，可自定义停止创建规则，当规则符合false则停止创建流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="string">&quot;+&quot;</span>, s -&gt; s.length() &lt;= <span class="number">5</span>, s -&gt; s + <span class="string">&quot;+&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="创建一个在一定范围的数字流"><a href="#创建一个在一定范围的数字流" class="headerlink" title="创建一个在一定范围的数字流"></a>创建一个在一定范围的数字流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">IntStream.range(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">IntStream.rangeClosed(<span class="number">0</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h5 id="创建随机数流"><a href="#创建随机数流" class="headerlink" title="创建随机数流"></a>创建随机数流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10L</span>);</span><br><span class="line">random.ints();</span><br><span class="line">random.ints(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// [0, 7)</span></span><br><span class="line">random.ints(<span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// [2,9)</span></span><br><span class="line">random.ints(<span class="number">10</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>相对应的，还有<code>long</code>与<code>double</code></p><h5 id="通过String创建char字符流"><a href="#通过String创建char字符流" class="headerlink" title="通过String创建char字符流"></a>通过String创建char字符流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">chars</span> <span class="operator">=</span> test.chars();</span><br></pre></td></tr></table></figure><h5 id="读取文件创建流"><a href="#读取文件创建流" class="headerlink" title="读取文件创建流"></a>读取文件创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">log</span> <span class="operator">=</span> Path.of(<span class="string">&quot;/tmp/debug.log&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(log)) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="variable">warnings</span> <span class="operator">=</span> </span><br><span class="line">        lines.filter(line -&gt; line.contains(<span class="string">&quot;WARNING&quot;</span>))</span><br><span class="line">             .count();</span><br><span class="line">    System.out.println(<span class="string">&quot;Number of warnings = &quot;</span> + warnings);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// do something with the exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过正则创建流"><a href="#通过正则创建流" class="headerlink" title="通过正则创建流"></a>通过正则创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;For there is good news yet to hear and fine things to be seen&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot; &quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = pattern.splitAsStream(sentence);</span><br></pre></td></tr></table></figure><h5 id="通过Builder创建流"><a href="#通过Builder创建流" class="headerlink" title="通过Builder创建流"></a>通过Builder创建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream.Builder&lt;String&gt; builder = Stream.&lt;String&gt;builder();</span><br><span class="line"></span><br><span class="line">builder.add(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">       .add(<span class="string">&quot;two&quot;</span>)</span><br><span class="line">       .add(<span class="string">&quot;three&quot;</span>)</span><br><span class="line">       .add(<span class="string">&quot;four&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = builder.build();</span><br></pre></td></tr></table></figure><h4 id="常用方法及功能描述"><a href="#常用方法及功能描述" class="headerlink" title="常用方法及功能描述"></a>常用方法及功能描述</h4><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>filter</td><td>根据用户自定义条件过滤Stream中所有数据，符合条件的通过</td></tr><tr><td>map</td><td>使用用户自定义的功能代码应用到每一个元素，常规用于类型转换</td></tr><tr><td>mapToInt</td><td>通过用户自定义的代码将当前Stream转换为IntStream(通常是为了调用IntStream额外的接口，如<code>sum</code>)</td></tr><tr><td>mapToLong</td><td>通过用户自定义代码将当前Stream转换为LongStream</td></tr><tr><td>mapToDouble</td><td>通过用户自定义代码将当前Stream转换为DoublegStream</td></tr><tr><td>flatMap</td><td>将Stream中的多维元素降一维，如<code>Stream&lt;List&lt;City&gt;&gt;</code>转换为<code>Stream&lt;City&gt;</code></td></tr><tr><td>flatMapToInt</td><td>效果同<code>flatMap</code>，仅可用于<code>int</code>类型,如 <code>Stream&lt;int[]&gt;</code> 转换为 <code>Stream&lt;int&gt;</code></td></tr><tr><td>flatMapToLong</td><td>效果同 <code>flatMapToInt</code> ，类型限制为<code>long</code></td></tr><tr><td>flatMapToDouble</td><td>效果同<code>flatMapToInt</code>，类型限制为<code>double</code></td></tr><tr><td>distinct</td><td>对数据流进行去重，重复判定由<code>Object.equals(Object)</code>确认</td></tr><tr><td>sorted</td><td>将流中元素根据用户实现<code>Comparable</code>内容进行自然排序，若类型未实现该接口，则抛出异常<code>java.lang.ClassCastException</code></td></tr><tr><td>sorted(Comparator&lt;? super T&gt; comparator)</td><td>重载函数，根据入参的自定义规则进行自然排序</td></tr><tr><td>peek</td><td>使用用户自定义操作应用到流中每一个元素</td></tr><tr><td>limit</td><td>根据用户自定义长度，对流进行截断</td></tr><tr><td>skip</td><td>从流开头跳过用户给定长度，如果流元素数不够，则流将会被清空</td></tr><tr><td>forEach</td><td>将用户自定义操作应用到流中每一个元素</td></tr><tr><td>forEachOrdered</td><td>通常在<code>parallel stream</code>中使用，对流按照给定顺序进行元素操作</td></tr><tr><td>toArray</td><td>将流中元素组成数组返回,返回<code>Object[]</code></td></tr><tr><td>toArray(IntFunction&lt;A[]&gt; generator)</td><td>重载函数，可由用户指定数组类型，使用方式<code>toArray(String[]::new)</code></td></tr><tr><td>min&#x2F;max</td><td>根据自定义的<code>Comparator</code>实现，寻找流中最小&#x2F;最大元素</td></tr><tr><td>count</td><td>统计流中元素数量</td></tr><tr><td>anyMatch</td><td>根据用户自定义判断条件，判断流中是否有任意符合元素</td></tr><tr><td>allMatch</td><td>判断流中元素是否全部符合自定义条件</td></tr><tr><td>noneMatch</td><td>判断流中元素是否全部不符合自定义条件</td></tr><tr><td>findFirst</td><td>返回流中第一个元素,<code>parallelStream</code>中将无法保证根据给定顺序确认第一个</td></tr><tr><td>findAny</td><td>返回流中任意一个元素,<code>Stream</code>中始终返回第一个,<code>parallelStream</code>中将会任意返回</td></tr><tr><td>concat</td><td>将两个流合并为一个</td></tr></tbody></table><h5 id="IntStream-x2F-LongStream-x2F-DoubleStream"><a href="#IntStream-x2F-LongStream-x2F-DoubleStream" class="headerlink" title="IntStream&#x2F;LongStream&#x2F;DoubleStream"></a>IntStream&#x2F;LongStream&#x2F;DoubleStream</h5><p>相对比常规Stream，此三种流额外实现几种方法</p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>sum</td><td>将流中元素求和</td></tr><tr><td>average</td><td>求平均值</td></tr><tr><td>min</td><td>最小值(无需提供<code>Comparator</code>实现)</td></tr><tr><td>max</td><td>最大值(无需提供<code>Comparator</code>实现)</td></tr><tr><td>summaryStatistics</td><td>返回统计结果，包含元素个数、总和、最大值、最小值</td></tr></tbody></table><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>reduce</code>操作一般是处理一组数据生成一个值，上文中提及的<code>sum</code>&#x2F;<code>min</code>&#x2F;<code>max</code>&#x2F;<code>count</code>都是<code>reduce</code>操作，因这些方法使用频繁，因此被单独设置一个方法以方便使用</p><h5 id="找最大值"><a href="#找最大值" class="headerlink" title="找最大值"></a>找最大值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; ints = Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional = ints.reduce((i1, i2) -&gt; i1 &gt; i2 ? i1: i2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optional.isPresent()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + optional.get());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;No result could be computed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码中，<code>reduce</code>操作通过用户自定义的规则<code>(i1, i2) -&gt; i1 &gt; i2 ? i1: i2</code>对整个流中数据进行规约(reduce)，最终求得最大值</p><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure><p>其中，入参<code>BinaryOperator&lt;T&gt; accumulator</code>是由用户提供的函数，用于对所有元素进行操作，返回值会作为新元素添加到流中加入后续的规则应用，而该接口待实现的方法入参有两个，分别代表了当前元素与下一个元素，返回值会作为下一轮的当前元素；<br>入参<code>identity</code>是由用户自定义，相当于在流的开头，人工添加一个元素，需注意的是，在<code>parallel</code>模式中，<code>identity</code>极有可能被重复使用，因此需要额外注意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).parallel().reduce(<span class="number">9</span>, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i1=&quot;</span> + i1 + <span class="string">&quot; i2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 * <span class="number">10</span> + i2;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;reduce with identity=&quot;</span> + reduce);</span><br><span class="line"></span><br><span class="line"><span class="comment">// i1=9 i2=1</span></span><br><span class="line"><span class="comment">// i1=9 i2=2</span></span><br><span class="line"><span class="comment">// i1=9 i2=5</span></span><br><span class="line"><span class="comment">// i1=9 i2=3</span></span><br><span class="line"><span class="comment">// i1=9 i2=8</span></span><br><span class="line"><span class="comment">// i1=95 i2=93</span></span><br><span class="line"><span class="comment">// i1=92 i2=98</span></span><br><span class="line"><span class="comment">// i1=91 i2=1043</span></span><br><span class="line"><span class="comment">// i1=1018 i2=1953</span></span><br><span class="line"><span class="comment">// reduce with identity=12133</span></span><br></pre></td></tr></table></figure><p>入参<code>combiner</code>仅在<code>parallel</code>模式中才会生效，非<code>parallel</code>模式的流将不会执行，而<code>combiner</code>的两个入参，分别是两个<code>accumulator</code>的执行结果，并且<code>combiner</code>本身的执行结果也会加入新的<code>combiner</code>中等待执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">reduce1</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).parallel().reduce(<span class="number">7</span>, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i1=&quot;</span> + i1 + <span class="string">&quot; i2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 * <span class="number">10</span> + i2;</span><br><span class="line">&#125;, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a1=&quot;</span> + i1 + <span class="string">&quot; a2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 * <span class="number">10</span> + i2;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;reduce with identity &amp; combiner=&quot;</span> + reduce1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// i1=7 i2=1</span></span><br><span class="line"><span class="comment">// i1=7 i2=2</span></span><br><span class="line"><span class="comment">// i1=7 i2=8</span></span><br><span class="line"><span class="comment">// i1=7 i2=5</span></span><br><span class="line"><span class="comment">// i1=7 i2=3</span></span><br><span class="line"><span class="comment">// a1=72 a2=78</span></span><br><span class="line"><span class="comment">// a1=75 a2=73</span></span><br><span class="line"><span class="comment">// a1=71 a2=823</span></span><br><span class="line"><span class="comment">// a1=798 a2=1533</span></span><br><span class="line"><span class="comment">// reduce with identity &amp; combiner=9513</span></span><br></pre></td></tr></table></figure><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>大多数业务场景都涉及模型的转换，此时，<code>reduce</code>将会力不从心，而<code>collect</code>将会完美的解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; collect = Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>上述代码将<code>int</code>元素通过<code>collect</code>与<code>Collectors</code>转换为<code>&lt;List&gt;</code>集合，<code>collect</code>有重载的两个方法，分别如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line">&lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大多数情况下，我们都是使用<code>Collector</code>，因<code>Collectors</code>已经内置大多数使用频率较高的函数，如<code>toList</code>&#x2F;<code>toSet</code>&#x2F;<code>toCollection</code>&#x2F;<code>toMap</code>等，其中<code>toList</code>&#x2F;<code>toSet</code>最容易理解，即转为<code>List</code>&#x2F;<code>Set</code>，如果想转换为其他的集合，则可以使用<code>toCollection</code>，在调用时，同时声明想要转换的集合即可，如:<code>Collectors.toCollection(ArrayList::new)</code>即是转换为<code>ArrayList</code></p><h5 id="Collectors-toMap"><a href="#Collectors-toMap" class="headerlink" title="Collectors.toMap"></a>Collectors.toMap</h5><p>转换为<code>Map</code>稍微复杂一些，重载一共有以下三个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper, Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper)</span><br><span class="line">Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper, Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)</span><br><span class="line">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper, Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier)</span><br></pre></td></tr></table></figure><p>其中<code>keyMapper</code>与<code>valueMapper</code>，是针对流中对象操作，分别处理出Map中的key与value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;City&gt; cities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">City</span> <span class="variable">city1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;1&quot;</span>, <span class="number">50_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;2&quot;</span>, <span class="number">2_100_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;3&quot;</span>, <span class="number">90_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;4&quot;</span>, <span class="number">130_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;5&quot;</span>, <span class="number">1_000_000</span>);</span><br><span class="line">cities.add(city1);</span><br><span class="line">cities.add(city2);</span><br><span class="line">cities.add(city3);</span><br><span class="line">cities.add(city4);</span><br><span class="line">cities.add(city5);</span><br><span class="line">Map&lt;String, Integer&gt; collect1 = cities.stream().collect(Collectors.toMap(City::getName, City::getPopulation));</span><br><span class="line">collect1.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"></span><br><span class="line"><span class="comment">// key=1 value=50000</span></span><br><span class="line"><span class="comment">// key=2 value=2100000</span></span><br><span class="line"><span class="comment">// key=3 value=90000</span></span><br><span class="line"><span class="comment">// key=4 value=130000</span></span><br><span class="line"><span class="comment">// key=5 value=1000000</span></span><br></pre></td></tr></table></figure><h6 id="Key值冲突"><a href="#Key值冲突" class="headerlink" title="Key值冲突"></a>Key值冲突</h6><p>而在转换为Map的时候，通常会遇到<code>Key</code>值重复的问题，如果此时不加以特殊处理，则会导致旧值被覆盖问题，此时<code>mergeFunction</code>则发挥了重要的作用，入参是两个<code>value</code>，不是<code>key</code>，处理结果将作为新的<code>value</code>插入到Map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cities.add(<span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;1&quot;</span>, <span class="number">5</span>));</span><br><span class="line">Map&lt;String, Integer&gt; collect = cities.stream().collect(Collectors.toMap(City::getName, City::getPopulation, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i1=&quot;</span> + i1 + <span class="string">&quot; i2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 + i2;</span><br><span class="line">&#125;));</span><br><span class="line">collect.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"></span><br><span class="line"><span class="comment">// i1=50000 i2=5</span></span><br><span class="line"><span class="comment">// key=1 value=50005</span></span><br><span class="line"><span class="comment">// key=2 value=2100000</span></span><br><span class="line"><span class="comment">// key=3 value=90000</span></span><br><span class="line"><span class="comment">// key=4 value=130000</span></span><br><span class="line"><span class="comment">// key=5 value=1000000</span></span><br></pre></td></tr></table></figure><h6 id="指定Map类型"><a href="#指定Map类型" class="headerlink" title="指定Map类型"></a>指定Map类型</h6><p>有些场景中，我们需要使用其他<code>Map</code>类型，如<code>HashTable</code>，此时则需要<code>mapSupplier</code>的帮忙了，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他Map类型均可自由指定，但必须实现Map接口</span></span><br><span class="line">Hashtable&lt;String, Integer&gt; collect2 = cities.stream().collect(Collectors.toMap(City::getName, City::getPopulation, Integer::sum, Hashtable::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><h5 id="Collectors其他场景"><a href="#Collectors其他场景" class="headerlink" title="Collectors其他场景"></a>Collectors其他场景</h5><h6 id="Collectors-averagingInt"><a href="#Collectors-averagingInt" class="headerlink" title="Collectors.averagingInt"></a><code>Collectors.averagingInt</code></h6><p>求平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Double</span> <span class="variable">collect4</span> <span class="operator">=</span> cities.stream().collect(Collectors.averagingInt(City::getPopulation));</span><br></pre></td></tr></table></figure><h6 id="Collectors-collectingAndThen"><a href="#Collectors-collectingAndThen" class="headerlink" title="Collectors.collectingAndThen"></a><code>Collectors.collectingAndThen</code></h6><p>先通过第一个入参处理流，然后再通过第二个入参处理上一个处理结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出人口最多的城市</span></span><br><span class="line"><span class="type">String</span> <span class="variable">collect5</span> <span class="operator">=</span> cities.stream().collect(Collectors.collectingAndThen(Collectors.maxBy(Comparator.comparing(City::getPopulation)), e -&gt; e.map(City::getName).orElse(<span class="literal">null</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;largest city = &quot;</span> + collect5);</span><br></pre></td></tr></table></figure><h6 id="Collectors-joining"><a href="#Collectors-joining" class="headerlink" title="Collectors.joining"></a><code>Collectors.joining</code></h6><p>将流中所有字符串拼接为<code>String</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Stream.of(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;3&quot;</span>).collect(Collectors.joining()));</span><br><span class="line">System.out.println(Stream.of(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;3&quot;</span>).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">System.out.println(Stream.of(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;3&quot;</span>).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>)));</span><br><span class="line"><span class="comment">// 28153</span></span><br><span class="line"><span class="comment">// 2,8,1,5,3</span></span><br><span class="line"><span class="comment">// &#123;2,8,1,5,3&#125;</span></span><br></pre></td></tr></table></figure><h6 id="Collectors-groupingBy"><a href="#Collectors-groupingBy" class="headerlink" title="Collectors.groupingBy"></a><code>Collectors.groupingBy</code></h6><p>根据自定义规则对流中数据进行分类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;City&gt;&gt; collect6 = cities.stream().collect(Collectors.groupingBy(City::getName));</span><br><span class="line">collect6.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"><span class="comment">// key=1 value=[City&#123;name=&#x27;1&#x27;, population=50000&#125;, City&#123;name=&#x27;1&#x27;, population=5&#125;]</span></span><br><span class="line"><span class="comment">// key=2 value=[City&#123;name=&#x27;2&#x27;, population=2100000&#125;]</span></span><br><span class="line"><span class="comment">// key=3 value=[City&#123;name=&#x27;3&#x27;, population=90000&#125;]</span></span><br><span class="line"><span class="comment">// key=4 value=[City&#123;name=&#x27;4&#x27;, population=130000&#125;]</span></span><br><span class="line"><span class="comment">// key=5 value=[City&#123;name=&#x27;5&#x27;, population=1000000&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数2</span></span><br><span class="line"><span class="comment">// groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream)</span></span><br><span class="line"><span class="comment">// downstream 是在分组完成后，再执行的处理函数</span></span><br><span class="line">Map&lt;String, Long&gt; collect7 = cities.stream().collect(Collectors.groupingBy(City::getName, Collectors.counting()));</span><br><span class="line">collect7.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数3</span></span><br><span class="line"><span class="comment">// groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream)</span></span><br><span class="line"><span class="comment">// mapFactory 指明一个Map的构造函数即可，将会影响最终返回Map类型</span></span><br><span class="line">Hashtable&lt;String, Long&gt; collect8 = cities.stream().collect(Collectors.groupingBy(City::getName, Hashtable::<span class="keyword">new</span>, Collectors.counting()));</span><br></pre></td></tr></table></figure><h6 id="Collectors-partitioningBy"><a href="#Collectors-partitioningBy" class="headerlink" title="Collectors.partitioningBy"></a><code>Collectors.partitioningBy</code></h6><p>根据自定义判断规则，对流中元素进行分类，仅分为两组，通常在类似与统计及格人数之类场景使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; collect9 = Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.partitioningBy(e -&gt; e &gt; <span class="number">5</span>));</span><br><span class="line">collect9.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"><span class="comment">// key=false value=[2, 1, 5, 3]</span></span><br><span class="line"><span class="comment">// key=true value=[8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数 partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream)</span></span><br><span class="line"><span class="comment">// 新增入参是在分类结束后调用</span></span><br><span class="line">Map&lt;Boolean, Long&gt; collect10 = Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.partitioningBy(e -&gt; e &gt; <span class="number">5</span>, Collectors.counting()));</span><br><span class="line">collect10.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot; value=&quot;</span> + v));</span><br><span class="line"><span class="comment">// key=false value=4</span></span><br><span class="line"><span class="comment">// key=true value=1</span></span><br></pre></td></tr></table></figure><h6 id="Collectors-summarizingInt"><a href="#Collectors-summarizingInt" class="headerlink" title="Collectors.summarizingInt"></a><code>Collectors.summarizingInt</code></h6><p>类似于<code>Stream</code>中的<code>summaryStatistics</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">collect11</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.summarizingInt(e -&gt; e));</span><br><span class="line">System.out.println(<span class="string">&quot;summarizingInt=&quot;</span> + collect11);</span><br><span class="line"><span class="comment">// summarizingInt=IntSummaryStatistics&#123;count=5, sum=19, min=1, average=3.800000, max=8&#125;</span></span><br></pre></td></tr></table></figure><h6 id="Collectors-summingInt"><a href="#Collectors-summingInt" class="headerlink" title="Collectors.summingInt"></a><code>Collectors.summingInt</code></h6><p>求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">collect12</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).collect(Collectors.summingInt(e -&gt; e));</span><br><span class="line">System.out.println(<span class="string">&quot;summingInt=&quot;</span> + collect12);</span><br><span class="line"><span class="comment">// summingInt=19</span></span><br></pre></td></tr></table></figure><h3 id="终章"><a href="#终章" class="headerlink" title="终章"></a>终章</h3><h4 id="Stream-1"><a href="#Stream-1" class="headerlink" title="Stream"></a>Stream</h4><h5 id="不存储"><a href="#不存储" class="headerlink" title="不存储"></a>不存储</h5><p><code>Stream</code>不存储任何对象在其中，其本身只充当管道的作用，它可以从各种数据结构、数组、生成器函数或I&#x2F;O流进行数据传输</p><h5 id="天然的函数式"><a href="#天然的函数式" class="headerlink" title="天然的函数式"></a>天然的函数式</h5><p>对流的操作会产生结果，但不会修改其源。例如，过滤从集合中获得的 Stream 会生成一个没有过滤元素的新 Stream，而不是从源集合中删除元素。</p><h5 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h5><p>许多流操作，例如过滤、映射或重复删除，可以延迟实现，从而为优化提供机会。例如，“查找具有三个连续元音的第一个字符串”不需要检查所有输入字符串。<br>流操作分为中间（流产生）操作和终端（产生价值或副作用）操作。中间操作总是懒惰的。</p><h5 id="可能无限"><a href="#可能无限" class="headerlink" title="可能无限"></a>可能无限</h5><p>虽然集合的大小是有限的，但流不需要。诸如 limit(n) 或 findFirst() 之类的短路操作可以允许对无限流的计算在有限时间内完成。</p><h5 id="消耗品"><a href="#消耗品" class="headerlink" title="消耗品"></a>消耗品</h5><p>流的元素在流的生命周期中只被访问一次。像迭代器一样，必须生成一个新流来重新访问源的相同元素。</p><h5 id="中间操作-intermediate"><a href="#中间操作-intermediate" class="headerlink" title="中间操作(intermediate)"></a>中间操作(intermediate)</h5><h6 id="无状态-Stateless"><a href="#无状态-Stateless" class="headerlink" title="无状态(Stateless)"></a>无状态(Stateless)</h6><p>无状态操作，例如filter and map，在处理新元素时不保留先前看到的元素的状态——每个元素都可以独立于对其他元素的操作进行处理.仅包含无状态中间操作的管道可以单次处理，无论是顺序的还是并行的，数据缓冲最少。</p><h6 id="有状态-stateful"><a href="#有状态-stateful" class="headerlink" title="有状态(stateful)"></a>有状态(stateful)</h6><p>有状态的操作，例如 distinct和sorted，在处理新元素时可能会合并来自先前看到的元素的状态。<br>有状态的操作可能需要在产生结果之前处理整个输入。例如，在查看流的所有元素之前，无法通过对流进行排序产生任何结果。因此，在并行计算下，一些包含有状态中间操作的管道可能需要对数据进行多次传递，或者可能需要缓冲重要数据。</p><h6 id="短路操作-short-circuiting"><a href="#短路操作-short-circuiting" class="headerlink" title="短路操作(short-circuiting)"></a>短路操作(short-circuiting)</h6><p>如果在呈现无限输入时，中间操作可能会产生有限流（如<code>limit</code>），则它是短路的。如果一个终端操作在有无限输入时可能会在有限时间内终止，那么它就是短路的。在管道中进行短路操作是无限流处理在有限时间内正常终止的必要条件，但不是充分条件。</p><h4 id="流处理过程"><a href="#流处理过程" class="headerlink" title="流处理过程"></a>流处理过程</h4><h5 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h5><p><img src="http://img.janwarlen.com/blog/StreamAPI.png" alt="Stream类图"></p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用本文最开始案例进行展示</span></span><br><span class="line">sum = cities</span><br><span class="line">        .stream()</span><br><span class="line">        .mapToInt(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;map:&quot;</span> + e.getName());</span><br><span class="line">            <span class="keyword">return</span> e.getPopulation();</span><br><span class="line">        &#125;)</span><br><span class="line">        .filter(population -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;filter:&quot;</span> + population);</span><br><span class="line">            <span class="keyword">return</span> population &gt; <span class="number">100_000</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// sum 内部也是通过reduce实现，此处用reduce是为了输出日志更好地展示过程</span></span><br><span class="line">        .reduce(<span class="number">0</span>, (i1, i2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;reduce:&quot;</span> + i1 + <span class="string">&quot; &quot;</span> + i2);</span><br><span class="line">            <span class="keyword">return</span> i1 + i2;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;Stream Sum = &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:1</span></span><br><span class="line"><span class="comment">// filter:50000</span></span><br><span class="line"><span class="comment">// map:2</span></span><br><span class="line"><span class="comment">// filter:2100000</span></span><br><span class="line"><span class="comment">// reduce:0 2100000</span></span><br><span class="line"><span class="comment">// map:3</span></span><br><span class="line"><span class="comment">// filter:90000</span></span><br><span class="line"><span class="comment">// map:4</span></span><br><span class="line"><span class="comment">// filter:130000</span></span><br><span class="line"><span class="comment">// reduce:2100000 130000</span></span><br><span class="line"><span class="comment">// map:5</span></span><br><span class="line"><span class="comment">// filter:1000000</span></span><br><span class="line"><span class="comment">// reduce:2230000 1000000</span></span><br><span class="line"><span class="comment">// Stream Sum = 3230000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>通过集合<code>cities</code>的函数<code>stream()</code>创建一个新的<code>Stream</code>，临时称作<code>s1</code></li><li><code>s1</code>通过函数<code>mapToInt</code>在自己的基础上创建一个新的<code>Stream</code>,临时称作<code>s2</code>,并将<code>s1</code>设置为<code>s2</code>的上游<code>previousStage</code></li><li><code>s2</code>通过函数<code>filter</code>在自己的基础上创建一个新的<code>Stream</code>，临时称作<code>s3</code>，并将<code>s2</code>设置为<code>s3</code>的上游<code>previousStage</code></li><li><code>s3</code>调用函数<code>reduce</code>触发结算操作，结算过程有两个核心点</li><li><code>java.util.stream.AbstractPipeline#wrapSink</code>通过该函数将结算操作前的所有中间操作逆序遍历(通过<code>previousStage</code>)，生成一个从上到下的新操作链<code>Sink</code></li><li><code>java.util.Spliterator#forEachRemaining</code>通过该函数将遍历数据源，并针对所有元素应用<code>Sink</code>(此时<code>Sink</code>是一条操作链，元素将会按顺序执行，直到结束或被中间操作剔除,如<code>filter</code>)</li><li>最终返回时，在<code>java.util.stream.ReduceOps.ReduceOp#evaluateSequential</code>中，通过对返回结果的<code>get()</code>函数取出最终返回结果</li><li>中间操作的叠加与结算时操作链的生成可以通过<code>装饰者模式</code>去理解，而结算时<code>downstream.accept(mapper.applyAsInt(u));</code>可以看出，先处理自己的操作<code>mapper.applyAsInt(u)</code>，然后再将结果传递给下一个中间操作<code>downstream.accept</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IntStream <span class="title function_">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="built_in">super</span> P_OUT&gt; mapper)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IntPipeline</span>.StatelessOp&lt;P_OUT&gt;(<span class="built_in">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                            StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        Sink&lt;P_OUT&gt; <span class="title function_">opWrapSink</span><span class="params">(<span class="type">int</span> flags, Sink&lt;Integer&gt; sink)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sink</span>.ChainedReference&lt;P_OUT, Integer&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(P_OUT u)</span> &#123;</span><br><span class="line">                    downstream.accept(mapper.applyAsInt(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="parallelStream"><a href="#parallelStream" class="headerlink" title="parallelStream"></a>parallelStream</h4><h5 id="通过-fork-x2F-join-框架执行"><a href="#通过-fork-x2F-join-框架执行" class="headerlink" title="通过 fork&#x2F;join 框架执行"></a>通过 fork&#x2F;join 框架执行</h5><p>Terminal操作会在<code>java.util.stream.AbstractPipeline#evaluate(java.util.stream.TerminalOp&lt;E_OUT,R&gt;)</code>中判断是否是<code>parallel</code>，如果是，则会通过调用<code>ReduceTask</code>的invoke函数执行流处理，下方堆栈是我在生成操作链是通过断点，使用<code>Thread.currentThread().getStackTrace()</code>得出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> = &#123;StackTraceElement@<span class="number">821</span>&#125; <span class="string">&quot;java.lang.Thread.getStackTrace(Thread.java:1559)&quot;</span></span><br><span class="line"><span class="number">1</span> = &#123;StackTraceElement@<span class="number">822</span>&#125; <span class="string">&quot;java.util.stream.AbstractPipeline.wrapSink(AbstractPipeline.java:517)&quot;</span></span><br><span class="line"><span class="number">2</span> = &#123;StackTraceElement@<span class="number">823</span>&#125; <span class="string">&quot;java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)&quot;</span></span><br><span class="line"><span class="number">3</span> = &#123;StackTraceElement@<span class="number">824</span>&#125; <span class="string">&quot;java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:747)&quot;</span></span><br><span class="line"><span class="number">4</span> = &#123;StackTraceElement@<span class="number">825</span>&#125; <span class="string">&quot;java.util.stream.ReduceOps$ReduceTask.doLeaf(ReduceOps.java:721)&quot;</span></span><br><span class="line"><span class="number">5</span> = &#123;StackTraceElement@<span class="number">826</span>&#125; <span class="string">&quot;java.util.stream.AbstractTask.compute(AbstractTask.java:316)&quot;</span></span><br><span class="line"><span class="number">6</span> = &#123;StackTraceElement@<span class="number">827</span>&#125; <span class="string">&quot;java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731)&quot;</span></span><br><span class="line"><span class="number">7</span> = &#123;StackTraceElement@<span class="number">828</span>&#125; <span class="string">&quot;java.util.concurrent.ForkJoinTask.doExec$$$capture(ForkJoinTask.java:289)&quot;</span></span><br><span class="line"><span class="number">8</span> = &#123;StackTraceElement@<span class="number">829</span>&#125; <span class="string">&quot;java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java)&quot;</span></span><br><span class="line"><span class="number">9</span> = &#123;StackTraceElement@<span class="number">830</span>&#125; <span class="string">&quot;java.util.concurrent.ForkJoinTask.doInvoke(ForkJoinTask.java:401)&quot;</span></span><br><span class="line"><span class="number">10</span> = &#123;StackTraceElement@<span class="number">831</span>&#125; <span class="string">&quot;java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:734)&quot;</span></span><br><span class="line"><span class="number">11</span> = &#123;StackTraceElement@<span class="number">832</span>&#125; <span class="string">&quot;java.util.stream.ReduceOps$ReduceOp.evaluateParallel(ReduceOps.java:714)&quot;</span></span><br><span class="line"><span class="number">12</span> = &#123;StackTraceElement@<span class="number">833</span>&#125; <span class="string">&quot;java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:233)&quot;</span></span><br><span class="line"><span class="number">13</span> = &#123;StackTraceElement@<span class="number">834</span>&#125; <span class="string">&quot;java.util.stream.IntPipeline.reduce(IntPipeline.java:457)&quot;</span></span><br><span class="line"><span class="number">14</span> = &#123;StackTraceElement@<span class="number">835</span>&#125; <span class="string">&quot;com.janwarlen.jdk8.stream.StreamCasesCityPopulationSum.main(StreamCasesCityPopulationSum.java:29)&quot;</span></span><br></pre></td></tr></table></figure><h5 id="Task类继承UML"><a href="#Task类继承UML" class="headerlink" title="Task类继承UML"></a>Task类继承UML</h5><p>注意：并非所有<code>parallel</code>都是调用<code>ReduceTask</code>，其他类还有<code>FindTask</code>、<code>ForEachOrderedTask</code>、<code>ForEachTask</code>和<code>MatchTask</code><br><img src="http://img.janwarlen.com/blog/parallelStreamTaskUML.png" alt="最终任务执行类UML"></p><h5 id="自定义ForkJoinPool"><a href="#自定义ForkJoinPool" class="headerlink" title="自定义ForkJoinPool"></a>自定义ForkJoinPool</h5><p><code>ParallelStreams</code> 默认使用 <code>ForkJoinPool.commonPool()</code>线程池。如果需要指定线程池，可参照如下操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">customThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">actualTotal</span> <span class="operator">=</span> customThreadPool.submit(() -&gt; roster.parallelStream().reduce(<span class="number">0</span>, Integer::sum)).get();</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>不建议将stream流操作分割为一步一步操作，这将会产生stream的临时变量，而stream对象是仅可操作一次的，这存在反复操作风险，同理也不建议作为方法函数的入参<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;City&gt; cities = StreamCasesCityPopulationSum.getCities();</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">mapped</span> <span class="operator">=</span> cities.stream().mapToInt(City::getPopulation);</span><br><span class="line"><span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> mapped.sum();</span><br><span class="line">System.out.println(<span class="string">&quot;all=&quot;</span> + all);</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">filted</span> <span class="operator">=</span> mapped.filter(population -&gt; population &gt; <span class="number">100_000</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> filted.sum();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台将会输出</span></span><br><span class="line"></span><br><span class="line">all=<span class="number">3370000</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">at java.util.stream.AbstractPipeline.&lt;init&gt;(AbstractPipeline.java:<span class="number">203</span>)</span><br><span class="line">at java.util.stream.IntPipeline.&lt;init&gt;(IntPipeline.java:<span class="number">91</span>)</span><br><span class="line">at java.util.stream.IntPipeline$StatelessOp.&lt;init&gt;(IntPipeline.java:<span class="number">594</span>)</span><br><span class="line">at java.util.stream.IntPipeline$<span class="number">9.</span>&lt;init&gt;(IntPipeline.java:<span class="number">333</span>)</span><br><span class="line">at java.util.stream.IntPipeline.filter(IntPipeline.java:<span class="number">332</span>)</span><br><span class="line">at com.janwarlen.jdk8.stream.StreamAttention.main(StreamAttention.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure></li><li>Stream流拆分或使用非线程安全的共享变量，则会存在数据在流处理过程中变更风险</li><li>在流处理中，尽量避免对元素的状态操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; seen = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">stream.parallel().map(e -&gt; &#123; <span class="keyword">if</span> (seen.add(e)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">return</span> e; &#125;)</span><br></pre></td></tr></table></figure></li><li>尽量避免<code>Side-effects</code>操作，如forEach&#x2F;peek等，尤其是<code>parallel</code>模式下，可能会导致线程不安全等问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">    .forEach(s -&gt; results.add(s));  <span class="comment">// Unnecessary use of side-effects!</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt;results =</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">    .collect(Collectors.toList());  <span class="comment">// No side-effects!</span></span><br></pre></td></tr></table></figure></li><li>对顺序不敏感的流处理，可使用<code>unordered()</code>提高部分有状态或终端操作的并行性</li><li>仅在对顺序无感的流处理中使用<code>parallel</code>模式</li><li><code>parallel</code>模式默认情况下公用一个线程池，因此需要避免I&#x2F;O操作，以免阻塞其他并行流，或自定义一个线程池，单独提交并行流</li><li>并行流中Map操作推荐使用<code>Concurrent</code>，如<code>groupingByConcurrent</code>替换<code>groupingBy</code>、<code>ConcurrentMap</code>替换<code>Map</code>、<code>Collectors.toConcurrentMap</code>替换<code>Collectors.toMap</code>等等，理由是在并行流中<code>Concurrent</code>在性能消耗方面要好很多</li><li>并行模式下避免使用有状态的lambda表达式，如下所示，与<em>注意事项4</em>相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; parallelStorage = Collections.synchronizedList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).parallel()</span><br><span class="line">        <span class="comment">// Don&#x27;t do this! It uses a stateful lambda expression.</span></span><br><span class="line">        .map(e -&gt; &#123; parallelStorage.add(e); <span class="keyword">return</span> e; &#125;)</span><br><span class="line">        .forEachOrdered(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(parallelStorage);</span><br><span class="line"><span class="comment">// 每次运行，parallelStorage中存储顺序均不相同</span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 [1, 3, 4, 2, 5]</span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 [1, 3, 2, 5, 4]</span></span><br><span class="line"><span class="comment">// 推荐使用collect</span></span><br><span class="line">List&lt;Integer&gt; collect13 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).parallel().collect(Collectors.toList());</span><br><span class="line">System.out.println(collect13);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 每次运行结果不变</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.java/learn/the-stream-api/&quot;&gt;Java官方学习手册-Stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CarpenterLee/JavaLambdaInternals&quot;&gt;GitHub-CarpenterLee-JavaLambdaInternals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html&quot;&gt;Oracle关于parallelism官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description&quot;&gt;Oracle关于Stream包官方描述文档&lt;/a&gt;</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="JDK8" scheme="http://janwarlen.com/tags/JDK8/"/>
    
    <category term="StreamAPI" scheme="http://janwarlen.com/tags/StreamAPI/"/>
    
  </entry>
  
  <entry>
    <title>Java版本特性-Lambda</title>
    <link href="http://janwarlen.com/2022/06/07/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-Lambda/"/>
    <id>http://janwarlen.com/2022/06/07/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-Lambda/</id>
    <published>2022-06-07T10:05:32.000Z</published>
    <updated>2022-06-10T19:06:23.236Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h4><ol><li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27">Oracle官方Lambda文档</a></li><li><a href="https://github.com/CarpenterLee/JavaLambdaInternals">GitHub-CarpenterLee-JavaLambdaInternals</a><span id="more"></span><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3></li></ol><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LambdaParameters -&gt; LambdaBody</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="无入参案例"><a href="#无入参案例" class="headerlink" title="无入参案例"></a>无入参案例</h5><h6 id="JDK7匿名内部类版本"><a href="#JDK7匿名内部类版本" class="headerlink" title="JDK7匿名内部类版本:"></a>JDK7匿名内部类版本:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h6 id="JDK8-Lambda版本"><a href="#JDK8-Lambda版本" class="headerlink" title="JDK8 Lambda版本:"></a>JDK8 Lambda版本:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;起飞&quot;</span>)).start();</span><br></pre></td></tr></table></figure><h5 id="一个入参案例"><a href="#一个入参案例" class="headerlink" title="一个入参案例"></a>一个入参案例</h5><h6 id="自定义接口类"><a href="#自定义接口类" class="headerlink" title="自定义接口类"></a>自定义接口类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaSingleParam</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="自定义调用类"><a href="#自定义调用类" class="headerlink" title="自定义调用类"></a>自定义调用类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaFuncAccepter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">(LambdaSingleParam lambda)</span> &#123;</span><br><span class="line">        lambda.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="JDK7-匿名类版本"><a href="#JDK7-匿名类版本" class="headerlink" title="JDK7 匿名类版本"></a>JDK7 匿名类版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc(<span class="keyword">new</span> <span class="title class_">LambdaSingleParam</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="JDK8-Lambda版本-1"><a href="#JDK8-Lambda版本-1" class="headerlink" title="JDK8 Lambda版本"></a>JDK8 Lambda版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc((LambdaSingleParam) System.out::println);</span><br><span class="line"><span class="comment">// 当接收lambda表达式的类存在重载时，才需要显示的强转辅助编译器确认调用函数</span></span><br><span class="line"><span class="comment">// 当不存在重载时，直接可以使用  LambdaFuncAccepter.testFunc(System.out::println);</span></span><br><span class="line"><span class="comment">// 单个参数场景下的 System.out.println(i); 可以简写为 System.out::println </span></span><br><span class="line"><span class="comment">// 一般情况下，表达式类似于  a -&gt; System.out.println(a); 参数的() 可以省略</span></span><br></pre></td></tr></table></figure><h5 id="多入参案例"><a href="#多入参案例" class="headerlink" title="多入参案例"></a>多入参案例</h5><h6 id="自定义接口类-1"><a href="#自定义接口类-1" class="headerlink" title="自定义接口类"></a>自定义接口类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaMultipleParams</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="自定义调用类-1"><a href="#自定义调用类-1" class="headerlink" title="自定义调用类"></a>自定义调用类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaFuncAccepter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">(LambdaMultipleParams lambda)</span> &#123;</span><br><span class="line">        lambda.test(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="JDK7-匿名类版本-1"><a href="#JDK7-匿名类版本-1" class="headerlink" title="JDK7 匿名类版本"></a>JDK7 匿名类版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc(<span class="keyword">new</span> <span class="title class_">LambdaMultipleParams</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(x + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="JDK8-Lambda版本-2"><a href="#JDK8-Lambda版本-2" class="headerlink" title="JDK8 Lambda版本"></a>JDK8 Lambda版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc((a, b) -&gt; System.out.println(a + b));</span><br><span class="line"><span class="comment">// 多参数场景下，入参的 &#x27;()&#x27; 必须存在</span></span><br></pre></td></tr></table></figure><h4 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h4><h5 id="单条执行语句"><a href="#单条执行语句" class="headerlink" title="单条执行语句"></a>单条执行语句</h5><h6 id="无return案例"><a href="#无return案例" class="headerlink" title="无return案例"></a>无return案例</h6><p><a href="#%E6%97%A0%E5%85%A5%E5%8F%82%E6%A1%88%E4%BE%8B">同无入参案例</a></p><h6 id="有return案例"><a href="#有return案例" class="headerlink" title="有return案例"></a>有return案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaWIthReturnNoParam</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// () -&gt; 233 ,其中return可以省略</span></span><br><span class="line"><span class="type">LambdaWIthReturnNoParam</span> <span class="variable">lambdaWIthReturnNoParam</span> <span class="operator">=</span> () -&gt; <span class="number">233</span>;</span><br><span class="line">System.out.println(lambdaWIthReturnNoParam.test());</span><br></pre></td></tr></table></figure><h5 id="多条执行语句"><a href="#多条执行语句" class="headerlink" title="多条执行语句"></a>多条执行语句</h5><h6 id="无return案例-1"><a href="#无return案例-1" class="headerlink" title="无return案例"></a>无return案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用runable接口</span></span><br><span class="line"><span class="comment">// 多条执行语句的方法体必须使用 &#123; &#125; 包裹</span></span><br><span class="line"><span class="comment">// 语法规则基本与正常函数方法体一致</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;line1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;line2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h6 id="有return案例-1"><a href="#有return案例-1" class="headerlink" title="有return案例"></a>有return案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 LambdaWIthReturnNoParam 接口</span></span><br><span class="line"><span class="comment">// return 也属于执行语句</span></span><br><span class="line"><span class="comment">// 多条语句场景 return 不可省略</span></span><br><span class="line"><span class="type">LambdaWIthReturnNoParam</span> <span class="variable">lambdaWIthReturnNoParam</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;line1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2022</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(lambdaWIthReturnNoParam.test());</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>lambda表达式的使用必须要有对应的函数接口，并且该接口有且仅有一个无默认实现的函数(当接口的其他函数均由默认实现时，该接口也可使用lambda，如<code>Comparator</code>)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Arrays.sort(a, (o1, o2) -&gt; o2 - o1);</span><br><span class="line"><span class="comment">// 也可写成，不过Integer内置是固定升序的，无法修改</span></span><br><span class="line">Arrays.sort(a, Integer::compare);</span><br></pre></td></tr></table></figure></li><li>多参数场景下，要么都声明入参类型，要么都不声明，不允许一部分声明，一部分隐藏<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc((a, <span class="type">int</span> b) -&gt; System.out.println(a + b));</span><br><span class="line"><span class="comment">// 此时编译器会报错</span></span><br></pre></td></tr></table></figure></li><li>final 不能修饰推断类型入参，如需使用final，需要将入参显示设置类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器会提示异常</span></span><br><span class="line">LambdaFuncAccepter.testFunc((a, <span class="keyword">final</span> b) -&gt; System.out.println(a + b));</span><br><span class="line"><span class="comment">// 需调整为如下所示:</span></span><br><span class="line">LambdaFuncAccepter.testFunc((<span class="type">int</span> a, <span class="keyword">final</span> <span class="type">int</span> b) -&gt; System.out.println(a + b));</span><br></pre></td></tr></table></figure></li><li>lambda方法体使用外部变量时，必须遵守声明时赋值后续不可赋值规则(同final修饰规则)，但调用对象函数修改对象内部状态合法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">    <span class="comment">// 虽然sb没有被final声明，但是在lambda内部存在隐形的final限制</span></span><br><span class="line">    <span class="comment">// sb = new StringBuilder();</span></span><br><span class="line">    sb.append(<span class="number">111</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;line1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 即便是在外部在初始化后再修改赋值，此时已经破坏final规则</span></span><br><span class="line">y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">    System.out.println(y);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li><li>使用数组一类时，需要注意下标的使用，如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">        <span class="comment">// 此时 i 不是遵守final规则的变量</span></span><br><span class="line">        System.out.println(b[i]);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以修改调整如下所示:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : b) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 此时变量i作为临时变量还尚未经历再一次的赋值修改，因此还遵守 effectively final 规则</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>lambda方法体使用外部变量时，必须确保所有外部变量均以完成初始化(仅声明不行，如分支，必须确保变量初始化)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">if</span> (sb.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Variable &#x27;x&#x27; might not have been initialized</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;引用参考文档链接&quot;&gt;&lt;a href=&quot;#引用参考文档链接&quot; class=&quot;headerlink&quot; title=&quot;引用参考文档链接&quot;&gt;&lt;/a&gt;引用参考文档链接&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27&quot;&gt;Oracle官方Lambda文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CarpenterLee/JavaLambdaInternals&quot;&gt;GitHub-CarpenterLee-JavaLambdaInternals&lt;/a&gt;</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="Lambda" scheme="http://janwarlen.com/tags/Lambda/"/>
    
    <category term="JDK8" scheme="http://janwarlen.com/tags/JDK8/"/>
    
  </entry>
  
  <entry>
    <title>一书一图-Head First设计模式</title>
    <link href="http://janwarlen.com/2022/06/05/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-Head%20First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://janwarlen.com/2022/06/05/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-Head%20First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-04T16:01:49.000Z</published>
    <updated>2022-06-04T16:15:54.240Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h4><ol><li>本书适合刚学习编程，并对编程十分感兴趣的同学，此书无法立刻提升编码能力，仅仅只能提供认知拓展；</li><li>设计模式是一种经验总结，并非发明创造，因此不能刻版的使用，需要因地制宜，甚至有些场景下，不适用任何设计模式解决问题反而会是最佳方案；</li><li>有一定的项目编码经验的同学更适合其他学习方式，如文字版的网页菜鸟教程或者视频类其他知识分享者上传的视频教程，本人更推荐文字版的，比较方便，更能快速的了解；</li><li>学习设计模式主要核心是弄清楚要解决的问题即使用场景，最好是能根据教材&#x2F;教程的案例，自己手敲一遍代码并运行去理解，仅仅靠定义去了解是远远不够的；</li><li>还想更进一步了解使用场景的同学可以去阅读各大开源项目的代码，尤其是中间件一类，因为更多会考虑性能和拓展问题，设计模式使用频率会远高于一般的业务项目；</li><li>思维导图中的一些优点缺点是结合部分网络教程的观点罗列而来，并非标准答案；</li><li>本文的思维导图仅是本人的读书笔记，不可作为权威版本去学习参考，可以简单浏览，如果感兴趣可以购买正版书籍学习；<span id="more"></span></li></ol><p><img src="http://img.janwarlen.com/blog/Head%20First%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="Head First设计模式"></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;本书适合刚学习编程，并对编程十分感兴趣的同学，此书无法立刻提升编码能力，仅仅只能提供认知拓展；&lt;/li&gt;
&lt;li&gt;设计模式是一种经验总结，并非发明创造，因此不能刻版的使用，需要因地制宜，甚至有些场景下，不适用任何设计模式解决问题反而会是最佳方案；&lt;/li&gt;
&lt;li&gt;有一定的项目编码经验的同学更适合其他学习方式，如文字版的网页菜鸟教程或者视频类其他知识分享者上传的视频教程，本人更推荐文字版的，比较方便，更能快速的了解；&lt;/li&gt;
&lt;li&gt;学习设计模式主要核心是弄清楚要解决的问题即使用场景，最好是能根据教材&amp;#x2F;教程的案例，自己手敲一遍代码并运行去理解，仅仅靠定义去了解是远远不够的；&lt;/li&gt;
&lt;li&gt;还想更进一步了解使用场景的同学可以去阅读各大开源项目的代码，尤其是中间件一类，因为更多会考虑性能和拓展问题，设计模式使用频率会远高于一般的业务项目；&lt;/li&gt;
&lt;li&gt;思维导图中的一些优点缺点是结合部分网络教程的观点罗列而来，并非标准答案；&lt;/li&gt;
&lt;li&gt;本文的思维导图仅是本人的读书笔记，不可作为权威版本去学习参考，可以简单浏览，如果感兴趣可以购买正版书籍学习；</summary>
    
    
    
    <category term="设计模式" scheme="http://janwarlen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://janwarlen.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="读书笔记" scheme="http://janwarlen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一书一图-深入理解Java虚拟机</title>
    <link href="http://janwarlen.com/2022/06/01/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://janwarlen.com/2022/06/01/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2022-06-01T02:53:49.000Z</published>
    <updated>2022-05-31T21:17:34.206Z</updated>
    
    <content type="html"><![CDATA[<p>Tips：  </p><ol><li>本书推荐按章节顺序读取，但是不同篇章需要不同程度的深入了解；</li><li>对于Java开发人员，本书最重要的篇章就是自动内存管理机制部分(第2章-第5章)，可以在日常的OOM和StackOverflow场景中提供巨大帮助，尤其其中提供的几个案例，更能帮助读者更好的理解内存管理；</li><li>其次就是高效并发篇章，该篇章可以帮助读者更深入的理解并发竞争的模型，理解为什么死锁，不过部分内容除了需要本书的其他篇章内容支撑外i，还需要额外了解操作系统知识(信号量)，并且无死锁场景的排查案例，因此需要读者需要额外通过其他方式学习如何在死锁时定位；</li><li>其他篇章内容对于Java开发人员基本只需要阅读产生印象即可，无需更深入了解(对大部分常规日常工作无明显帮助)；</li><li>平台(中间件)开发人员，需要额外深入阅读虚拟机执行子系统篇章，尤其是类加载内容，其中的双亲委派模型尤为重要；</li><li>思维导图不适合作为学习材料，可以简单一阅，建议购买正版书籍。<span id="more"></span></li></ol><p><img src="http://img.janwarlen.com/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="深入理解Java虚拟机"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Tips：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本书推荐按章节顺序读取，但是不同篇章需要不同程度的深入了解；&lt;/li&gt;
&lt;li&gt;对于Java开发人员，本书最重要的篇章就是自动内存管理机制部分(第2章-第5章)，可以在日常的OOM和StackOverflow场景中提供巨大帮助，尤其其中提供的几个案例，更能帮助读者更好的理解内存管理；&lt;/li&gt;
&lt;li&gt;其次就是高效并发篇章，该篇章可以帮助读者更深入的理解并发竞争的模型，理解为什么死锁，不过部分内容除了需要本书的其他篇章内容支撑外i，还需要额外了解操作系统知识(信号量)，并且无死锁场景的排查案例，因此需要读者需要额外通过其他方式学习如何在死锁时定位；&lt;/li&gt;
&lt;li&gt;其他篇章内容对于Java开发人员基本只需要阅读产生印象即可，无需更深入了解(对大部分常规日常工作无明显帮助)；&lt;/li&gt;
&lt;li&gt;平台(中间件)开发人员，需要额外深入阅读虚拟机执行子系统篇章，尤其是类加载内容，其中的双亲委派模型尤为重要；&lt;/li&gt;
&lt;li&gt;思维导图不适合作为学习材料，可以简单一阅，建议购买正版书籍。</summary>
    
    
    
    <category term="Java" scheme="http://janwarlen.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://janwarlen.com/tags/Java/"/>
    
    <category term="读书笔记" scheme="http://janwarlen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JVM" scheme="http://janwarlen.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读-HashMap</title>
    <link href="http://janwarlen.com/2018/08/16/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-HashMap/"/>
    <id>http://janwarlen.com/2018/08/16/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-HashMap/</id>
    <published>2018-08-15T16:34:42.000Z</published>
    <updated>2022-05-31T18:26:48.313Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h4><ol><li>扩容是一个特别耗性能的操作，因此建议使用HashMap时，尽量指定一定大小的初始容量</li><li><code>HashMap</code>是线程不安全的，并发环境中建议使用<code>ConcurrentHashMap</code></li><li>JDK8中引入的红黑树优化了大量hash碰撞时的性能</li><li>HashMap中的红黑树代码作者实在没力气看了，因此这篇文章不涉及内部红黑树分析</li><li>该篇文章纯粹是作者个人观点，并非官方权威，阅读请勿迷信<span id="more"></span><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><code>hashmap</code>使用数组+链表（红黑树）作为整体结构<h5 id="节点数据结构"><a href="#节点数据结构" class="headerlink" title="节点数据结构"></a>节点数据结构</h5>一般情况下，节点会使用如下代码构建结构,该结构为<a href="https://baike.baidu.com/item/%E5%8D%95%E9%93%BE%E8%A1%A8">单链表</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>JDK8中增加特性：当链表长度超过8时（等于也会触发），会转换为红黑树结构。红黑树需要了解的小伙伴可以看下这篇文章：<a href="http://janwarlen.com/2018/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/">一步一步数据结构-红黑树</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5>图片来源美团技术博客：<a href="https://tech.meituan.com/java_hashmap.html">Java 8系列之重新认识HashMap</a>  <img src="https://tech.meituan.com/img/java-hashmap/hashMap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="hashMap内存结构图" heigth="280" width="470">  本质上，在一般情况下的HashMap就是一维数组+单链表，其中一维数组在这里的作用个人感觉更像是指针，当用户通过`get`获取值的时候，先通过hash找到对应数组位置，再通过数组找到对应的链表，再进行链表遍历找到完全符合的**键值节点**</li></ol><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>在初步了解HashMap长相之后，我们可以通过基本操作来了解它的工作过程。</p><h5 id="hash与索引计算"><a href="#hash与索引计算" class="headerlink" title="hash与索引计算"></a>hash与索引计算</h5><p>HashMap通过Key的hash值找到数组的对应位置，因此我们需要先行了解hash的运算规则，因使用的是key对应对象的<code>hashCode()</code>函数，因此在使用自定义对象作为key时，需格外注意。<br>运算符相关介绍：<br><a href="https://baike.baidu.com/item/%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6">&gt;&gt;&gt; 右移运算符</a><br><a href="https://jingyan.baidu.com/article/fec4bce2759713f2618d8b98.html">^ 按位异或运算符</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引计算通过<code>(n - 1) &amp; hash</code>，引用美团技术博客中原文(n即length)：</p><blockquote><p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p></blockquote><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><p><a href="https://zhidao.baidu.com/question/321019160.html">&amp;</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 此处是对HashMap容量判断，属于边界异常判断</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 需注意的是，上一小节是介绍hash的运算过程，转换为数组索引是`(n - 1) &amp; hash`</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 索引位置链表为空，直接插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 此处判断的是对应索引位置单链表的头结点，需注意(k = p.key) == key || (key != null &amp;&amp; key.equals(k)))</span></span><br><span class="line">        <span class="comment">// 因key可以为任意对象，因此==在某些时候不能作为判断相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果索引对应链表已经是红黑树，交由红黑树处理</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当头结点并非所寻节点，则遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 无相同key节点，直接尾插法插入新节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 当链表达到阈值，则进行转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 相同key情况在此处处理，直接进行值覆盖（相当于修改）</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 数组阈值判断，如果达到阈值，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 意义不明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 避免数组为空（即HashMap为空），数组索引对应链表为空</span></span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash   已经计算索引位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 找对应节点</span></span><br><span class="line">        <span class="comment">// 判断索引对应链表头结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 添加if判断，避免边界问题（个人猜测主要是避免红黑树的情况）</span></span><br><span class="line">        <span class="comment">// 因为单链表的边界避免可以通过循环条件控制，此处使用的是do&#123;&#125;while循环，可以使用while改变条件判断时机</span></span><br><span class="line">        <span class="comment">// 此处都是个人猜测，极具争议性，非正规解释</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 红黑树节点交由红黑树内部方法定位所寻找节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到节点后进行删除操作，判断条件避免不存在节点情况和需要严格匹配值情况</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 红黑树交由内部处理</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">// 此处情况是，链表头结点就是所寻节点，因此node与p相等</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 单链表删除操作</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);<span class="comment">// 意义不明</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 避免为空条件三连</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 链表头结点判断</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 当链表不仅仅只有头节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 红黑树交由内部处理</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历链表寻找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>所有操作在需要对链表进行判断的情况下，在JDK8中，都是先判断头结点，再判断是否存在后续节点，然后红黑树交由红黑树内部方法处理，单链表遍历通过do{}while进行循环遍历。对比JDK1.7我们可以看出代码变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="type">return</span> <span class="variable">null</span> <span class="operator">=</span>= entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">getForNullKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK7中，因为没有引入红黑树优化，因此链表都为单链表，因此遍历都是通过for循环，后续节点非空判断也在for循环的判断条件中。因此，此处<strong>个人</strong>大胆总结，该变化由红黑树引起。可能由于<code>instanceof</code>存在一定程度的性能损耗，因此，先进行首节点判断以尽可能的避免首节点就是所寻节点从而不用使用<code>instanceof</code>可以提升一定程度的性能（存在争议）。</p><h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><h5 id="HashMap的创建"><a href="#HashMap的创建" class="headerlink" title="HashMap的创建"></a>HashMap的创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可自定义初始容量和加载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅指定初始容量，使用默认的加载因子0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认的加载因子初始化，未指定初始容量，将会使用默认初始容量16</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据已有map导入至新的hashmap中，使用默认加载因子0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上创建HashMap的方式中，需要注意指定初始容量的函数，两者都会执行<code>this.threshold = tableSizeFor(initialCapacity);</code>这段代码将会将使用者指定的容量转化为2的整数次方数，举例说明<code>tableSizeFor(11)</code>将会返回<code>16</code>,<code>tableSizeFor(17)</code>将会返回<code>32</code>。其内部实现为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhidao.baidu.com/question/291266003.html">他人解释</a>，根据该解释，再加上程序语言一般情况下<code>int</code>最大值为<code>2147483647</code>，转化为二进制是32位，而<code>1+2+4+8+16=31</code>，因此基本可以认定只要传入<code>int</code>不是非法，都会被该函数运算处理，此时需要注意<code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>该函数限定了最大值。<br>一般情况下，我们使用HashMap并不会指定初始容量与加载因子，会使用默认的无参构造（即将会创建初始容量为16，加载因子为0.75的一个HashMap），那么很容易会碰到容量达到阈值（总容量*加载因子）从而触发自动扩容。因为底层就是创建新数组，然后数据内容从旧数组中转移至新的，因此我们先看下数据的新增定位过程。</p><h5 id="HashMap的索引计算"><a href="#HashMap的索引计算" class="headerlink" title="HashMap的索引计算"></a>HashMap的索引计算</h5><p>之前查看<code>put</code>源码时，很容易看出索引位置由<code>(n - 1) &amp; hash</code>算出，其中<code>n</code>为当前数组容量长度。<code>&amp;</code>是按位与运算，我简易模拟下hash为48和1568时的运算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  48-&gt; 0000 0000 0000 0000 0000 0000 0011 0000</span><br><span class="line">  15-&gt; 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">&amp;</span><br><span class="line">       0000 0000 0000 0000 0000 0000 0000 0000 -&gt; 0</span><br><span class="line"></span><br><span class="line">1568-&gt; 0000 0000 0000 0000 0000 0110 0010 0000</span><br><span class="line">  15-&gt; 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">&amp;</span><br><span class="line">       0000 0000 0000 0000 0000 0000 0000 0000 -&gt; 0</span><br><span class="line">Tips:48为字符串&quot;0&quot;的hash值，1568为字符串&quot;11&quot;的hash值</span><br><span class="line">因为&amp;运算的特性，仅有1&amp;1的结果才为1，因此n-1的值限定了计算&amp;的长度</span><br><span class="line">当前例子中仅仅计算最后四位，因为前面的所有都是0，无需考虑</span><br></pre></td></tr></table></figure><h5 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h5><p>扩容由<code>++size &gt; threshold</code>触发，因此我使用如下代码进行简易的触发扩容，并且确保至少有一条单链表存在一个以上的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; test = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 0 与 11 索引位置相同，索引为0</span></span><br><span class="line">    <span class="comment">// 1 与 12 索引位置相同，索引为1</span></span><br><span class="line">    test.put(String.valueOf(i), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.janwarlen.com/18-8-15/52850757.jpg" alt="简易数据"><br>从图中可以轻易看出数组已经存在<strong>11</strong>个数据，因此当前<code>size</code>为11，此时满足<code>++size &gt; threshold</code>条件，触发扩容，容量会由<code>newThr = oldThr &lt;&lt; 1; // double threshold</code>扩大一倍（即原来的两倍），因为容量的扩大，计算索引时的公式<code>(n - 1) &amp; hash</code>，此时<code>n-1</code>的二进制肯定比之前多一位，因此节点的位置需要重新计算。而根据函数<code>tableSizeFor</code>我们可知，基本上所有的HashMap的容量都是<code>2</code>的整数次方数。因此可以看如下过程（以初始容量为16举例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始内容    hash值   hash值的二进制                               与<span class="number">15</span>&amp;结果  与<span class="number">31</span>&amp;结果</span><br><span class="line"><span class="number">0</span>           <span class="number">48</span>      <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> <span class="number">0000</span>     <span class="number">0</span>           <span class="number">16</span></span><br><span class="line"><span class="number">11</span>          <span class="number">1568</span>    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0110</span> <span class="number">0010</span> <span class="number">0000</span>     <span class="number">0</span>           <span class="number">0</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">n-<span class="number">1</span>=<span class="number">15</span>(非hash值!)   <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line">n^<span class="number">2</span>-<span class="number">1</span>=<span class="number">31</span>            <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1111</span></span><br><span class="line">Tip：对不齐我也没办法，我也很难受，将就看吧</span><br></pre></td></tr></table></figure><p>可以轻易看出，元素是否需要转移位置取决于新增的那一位是1还是0，因此和<code>n</code>进行<code>&amp;</code>运算即可得知，为0即保留位置无需移动，为1则代表需要移动<code>n</code>个位置。<br>先看下源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">           