<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java版本特性-JDK9</title>
    <url>/2022/06/11/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-JDK9/</url>
    <content><![CDATA[<h1 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h1><ol>
<li><a href="https://docs.oracle.com/javase/9/">Oracle Java9官方文档</a></li>
<li><a href="https://www.oracle.com/java/technologies/javase/9-relnotes.html">JDK 9 Release Notes</a></li>
<li><a href="http://openjdk.java.net/projects/jigsaw/quick-start">Module System Quick-Start Guide</a></li>
<li><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-7744EF96-5899-4FB2-B34E-86D49B2E89B6">JDK9迁移指南</a></li>
<li><a href="http://openjdk.java.net/jeps/213">Milling Project Coin</a></li>
<li><a href="http://openjdk.java.net/jeps/282">jlink: The Java Linker</a></li>
<li><a href="http://openjdk.java.net/jeps/222">The Java Shell</a></li>
</ol>
<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><ol>
<li>本文仅涉及部分JDK9变更，完整可查看官方文档<a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm">Standard Edition What’s New in Oracle JDK 9</a></li>
<li>除了模块化，其他改动对日常开发影响不多，可以着重关注模块化和接口私有函数</li>
</ol>
<span id="more"></span>

<h1 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="ModularDemo"><a href="#ModularDemo" class="headerlink" title="ModularDemo"></a><a href="https://github.com/JanWarlen/ModularDemo">ModularDemo</a></h3><p>因目前Oracle开放的JDK下载版本仅有8&#x2F;11&#x2F;17&#x2F;18，因此该项目通过JDK18编译JDK9(Project language level设置为9)模拟</p>
<h4 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h4><p><img src="http://img.janwarlen.com/blog/Modular-%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="Modular"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><code>common</code>与<code>service</code>是在 Maven 层面上的子模块,JDK9的模块化主要通过类<code>module-info.java</code></li>
<li>每个工程(模块)仅可有一个<code>module-info.java</code></li>
<li>对外开放的最小粒度是<code>package</code>，无法以类作为最小单位，如果有类不愿对外开放，建议迁移到单独的包中</li>
<li>打包后，虽然<code>common</code>没有开放<code>intern</code>包，但是最终common.jar中还是会有<code>intern</code>中的类</li>
<li>如果类不惜那个对外开放，但是其中部分功能还需要对外使用，可以单独在对外开放的包中新建一个类，作为转发调用</li>
<li>从初步的使用感觉，目前仅在权限控制方面有明显的作用</li>
<li><code>maven-compiler-plugin</code>仅在<code>3.8.0+</code>才支持<code>module</code>(可查看<code>ModularDemo/pom.xml</code>)</li>
</ol>
<h1 id="jlink"><a href="#jlink" class="headerlink" title="jlink"></a>jlink</h1><p>可以自定义Java程序运行时的JRE环境</p>
<h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jlink --module-path &lt;modulepath&gt; --add-modules &lt;modules&gt; --limit-modules &lt;modules&gt; --output &lt;path&gt;</span><br><span class="line">module-path: 指的是你自定义的JRE环境所有需要的module所处的路径</span><br><span class="line">add-modules: 在 module-path 中，你需要那些module</span><br><span class="line">limit-modules: 根据module名称限制搜寻范围</span><br><span class="line">output: 自定义JRE的输出路径</span><br><span class="line"></span><br><span class="line">jlink --output service/src/main/resources/jre --module-path &quot;service/src/main/resources&quot; --add-modules common</span><br><span class="line">我将入门案例中的common的jar包拷贝到service/src/main/resources中，因此 module-path 就是 &quot;service/src/main/resources&quot;，而因 service 仅需要 common 一个模块，因此我只添加了 common</span><br></pre></td></tr></table></figure>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ol>
<li>自定义的JRE环境没有无关的jar包，因此启动内存消耗会少<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;totalMemory:&quot;</span> + Runtime.getRuntime().totalMemory()/ (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;freeMemory:&quot;</span> + Runtime.getRuntime().freeMemory()/ (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;maxMemory:&quot;</span> + Runtime.getRuntime().maxMemory()/ (<span class="number">1024</span> * <span class="number">1024</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(base) MacBook-Pro ModularDemo % ./service/src/main/resources/jre/bin/java -jar service/target/service-1.0-SNAPSHOT.jar</span><br><span class="line">hello</span><br><span class="line">this is private class.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">false</span><br><span class="line">totalMemory:512</span><br><span class="line">freeMemory:510</span><br><span class="line">maxMemory:8192</span><br><span class="line">(base) MacBook-Pro ModularDemo % java -jar service/target/service-1.0-SNAPSHOT.jar </span><br><span class="line">hello</span><br><span class="line">this is private class.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">false</span><br><span class="line">totalMemory:520</span><br><span class="line">freeMemory:514</span><br><span class="line">maxMemory:8192</span><br></pre></td></tr></table></figure></li>
<li>可以根据应用自定义不同的JRE，而不用将所有 module 对全部应用开放</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>初步感受，该功能在嵌入式领域可以发挥非常重要的作用，在服务器端程序，作用可能没有那么明显</li>
<li>最好可以搭配<a href="http://openjdk.java.net/jeps/200">The Modular JDK</a>、<a href="http://openjdk.java.net/jeps/201">Modular Source Code</a>、<a href="http://openjdk.java.net/jeps/220">Modular Run-Time Images</a>一起使用，效果更佳(此处埋坑，以后有时间再回头来研究这三个)</li>
</ol>
<h1 id="正则-调整作用范围"><a href="#正则-调整作用范围" class="headerlink" title="正则^调整作用范围"></a>正则<code>^</code>调整作用范围</h1><p>将作用到整个表达式，而不是第一个group</p>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[^a-b[c-d]e-f]&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">a</span> <span class="operator">=</span> compile.matcher(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">c</span> <span class="operator">=</span> compile.matcher(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// JDK8 false JDK9 false</span></span><br><span class="line">System.out.println(a.matches());</span><br><span class="line"><span class="comment">// JDK8 true JDK9 false</span></span><br><span class="line">System.out.println(c.matches());</span><br></pre></td></tr></table></figure>

<h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><p>可以在try外部声明变量，将变量名放在try中即可，但是该变量受<code>final or effectively final</code>规则限制，即在初始化完成后不可再次进行赋值操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Files.newInputStream(Paths.get(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> (in) &#123;</span><br><span class="line">    <span class="comment">// JDK8中该用法会有以下异常提示</span></span><br><span class="line">    <span class="comment">// Resource references are not supported at language level &#x27;8&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="匿名类的泛型推断"><a href="#匿名类的泛型推断" class="headerlink" title="匿名类的泛型推断"></a>匿名类的泛型推断</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InferredType</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// JDK8 中会有如下异常提示</span></span><br><span class="line">    <span class="comment">// Class &#x27;Anonymous class derived from InferredType&#x27; must either be declared abstract or implement abstract method &#x27;test(T)&#x27; in &#x27;InferredType&#x27;</span></span><br><span class="line">    InferredType&lt;String&gt; inferredType = <span class="keyword">new</span> <span class="title class_">InferredType</span>&lt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String o)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="允许接口定义private方法"><a href="#允许接口定义private方法" class="headerlink" title="允许接口定义private方法"></a>允许接口定义private方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PrivateFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        func3();</span><br><span class="line">        <span class="comment">// JDK8+</span></span><br><span class="line">        System.out.println(<span class="string">&quot;默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">func3</span><span class="params">()</span> &#123;</span><br><span class="line">        func4();</span><br><span class="line">        System.out.println(<span class="string">&quot;私有默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态私有实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以起到优化重复代码的帮助</li>
</ol>
<h1 id="不可作为变量名"><a href="#不可作为变量名" class="headerlink" title="_不可作为变量名"></a><code>_</code>不可作为变量名</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// As of Java 9, &#x27;_&#x27; is a keyword, and may not be used as an identifier</span></span><br><span class="line"><span class="comment">// JDK8 是可以正常使用的，影响不大，几乎很少有场景会单独使用 _ 作为变量名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">_</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure>

<h1 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="comment">// 不用该注解，仅会导致编译器提示，不会异常</span></span><br><span class="line"><span class="comment">// 此注解用于泛型可变入参函数，JDK9是拓展至可声明private函数</span></span><br><span class="line"><span class="comment">//  Possible heap pollution from parameterized vararg type</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  &lt;T&gt; <span class="keyword">void</span> <span class="title function_">saveVarargs</span><span class="params">(T... params)</span> &#123;</span><br><span class="line">    Arrays.stream(params).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Class文件版本号变动至53"><a href="#Class文件版本号变动至53" class="headerlink" title="Class文件版本号变动至53"></a>Class文件版本号变动至53</h1><h1 id="编译旧版本范围变动"><a href="#编译旧版本范围变动" class="headerlink" title="编译旧版本范围变动"></a>编译旧版本范围变动</h1><blockquote>
<p>The javac command no longer supports -source or-target values for releases before 6&#x2F;1.6. However, older class files are still readable by javac. Source code for an older release can be ported to a newer source level. To generate class files usable by releases older than JDK 6, a javac from a JDK 6, 7, or 8 release family can be used.<br><a href="https://openjdk.java.net/jeps/182">JEP 182</a> documents the policy for retiring old -source and -target options.  </p>
</blockquote>
<p>JDK9在使用javac编译java文件时，指定java的版本仅支持*1.6+*，不再支持编译到1.5以及更早期的版本</p>
<h1 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h1><p>引用官方原文</p>
<blockquote>
<p>Immediate feedback is important when learning a programming language and its APIs. The number one reason schools cite for moving away from Java as a teaching language is that other languages have a “REPL” and have far lower bars to an initial “Hello, world!” program. A Read-Eval-Print Loop (REPL) is an interactive programming tool which loops, continually reading user input, evaluating the input, and printing the value of the input or a description of the state change the input caused. Scala, Ruby, JavaScript, Haskell, Clojure, and Python all have REPLs and all allow small initial programs. JShell adds REPL functionality to the Java platform.<br>Exploration of coding options is also important for developers prototyping code or investigating a new API. Interactive evaluation is vastly more efficient in this regard than edit&#x2F;compile&#x2F;execute and System.out.println.<br>Without the ceremony of class Foo { public static void main(String[] args) { … } }, learning and exploration is streamlined.</p>
</blockquote>
<p>大致含义是降低Java学习的入门门槛，可以更方便的测试API<br>吐槽:</p>
<ol>
<li>对于习惯了ide的代码提示和代码模板(<code>code templates</code>)来说，突然使用<code>jshell</code>会有些难受</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>模块系统</tag>
        <tag>REPL (JShell)</tag>
        <tag>JDK9</tag>
      </tags>
  </entry>
  <entry>
    <title>Java版本特性-Lambda</title>
    <url>/2022/06/07/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-Lambda/</url>
    <content><![CDATA[<h4 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h4><ol>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27">Oracle官方Lambda文档</a></li>
<li><a href="https://github.com/CarpenterLee/JavaLambdaInternals">GitHub-CarpenterLee-JavaLambdaInternals</a><span id="more"></span>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3></li>
</ol>
<h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LambdaParameters -&gt; LambdaBody</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="无入参案例"><a href="#无入参案例" class="headerlink" title="无入参案例"></a>无入参案例</h5><h6 id="JDK7匿名内部类版本"><a href="#JDK7匿名内部类版本" class="headerlink" title="JDK7匿名内部类版本:"></a>JDK7匿名内部类版本:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h6 id="JDK8-Lambda版本"><a href="#JDK8-Lambda版本" class="headerlink" title="JDK8 Lambda版本:"></a>JDK8 Lambda版本:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;起飞&quot;</span>)).start();</span><br></pre></td></tr></table></figure>

<h5 id="一个入参案例"><a href="#一个入参案例" class="headerlink" title="一个入参案例"></a>一个入参案例</h5><h6 id="自定义接口类"><a href="#自定义接口类" class="headerlink" title="自定义接口类"></a>自定义接口类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaSingleParam</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="自定义调用类"><a href="#自定义调用类" class="headerlink" title="自定义调用类"></a>自定义调用类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaFuncAccepter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">(LambdaSingleParam lambda)</span> &#123;</span><br><span class="line">        lambda.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="JDK7-匿名类版本"><a href="#JDK7-匿名类版本" class="headerlink" title="JDK7 匿名类版本"></a>JDK7 匿名类版本</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc(<span class="keyword">new</span> <span class="title class_">LambdaSingleParam</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="JDK8-Lambda版本-1"><a href="#JDK8-Lambda版本-1" class="headerlink" title="JDK8 Lambda版本"></a>JDK8 Lambda版本</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc((LambdaSingleParam) System.out::println);</span><br><span class="line"><span class="comment">// 当接收lambda表达式的类存在重载时，才需要显示的强转辅助编译器确认调用函数</span></span><br><span class="line"><span class="comment">// 当不存在重载时，直接可以使用  LambdaFuncAccepter.testFunc(System.out::println);</span></span><br><span class="line"><span class="comment">// 单个参数场景下的 System.out.println(i); 可以简写为 System.out::println </span></span><br><span class="line"><span class="comment">// 一般情况下，表达式类似于  a -&gt; System.out.println(a); 参数的() 可以省略</span></span><br></pre></td></tr></table></figure>

<h5 id="多入参案例"><a href="#多入参案例" class="headerlink" title="多入参案例"></a>多入参案例</h5><h6 id="自定义接口类-1"><a href="#自定义接口类-1" class="headerlink" title="自定义接口类"></a>自定义接口类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaMultipleParams</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="自定义调用类-1"><a href="#自定义调用类-1" class="headerlink" title="自定义调用类"></a>自定义调用类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaFuncAccepter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFunc</span><span class="params">(LambdaMultipleParams lambda)</span> &#123;</span><br><span class="line">        lambda.test(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="JDK7-匿名类版本-1"><a href="#JDK7-匿名类版本-1" class="headerlink" title="JDK7 匿名类版本"></a>JDK7 匿名类版本</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc(<span class="keyword">new</span> <span class="title class_">LambdaMultipleParams</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(x + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="JDK8-Lambda版本-2"><a href="#JDK8-Lambda版本-2" class="headerlink" title="JDK8 Lambda版本"></a>JDK8 Lambda版本</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc((a, b) -&gt; System.out.println(a + b));</span><br><span class="line"><span class="comment">// 多参数场景下，入参的 &#x27;()&#x27; 必须存在</span></span><br></pre></td></tr></table></figure>

<h4 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h4><h5 id="单条执行语句"><a href="#单条执行语句" class="headerlink" title="单条执行语句"></a>单条执行语句</h5><h6 id="无return案例"><a href="#无return案例" class="headerlink" title="无return案例"></a>无return案例</h6><p><a href="#%E6%97%A0%E5%85%A5%E5%8F%82%E6%A1%88%E4%BE%8B">同无入参案例</a></p>
<h6 id="有return案例"><a href="#有return案例" class="headerlink" title="有return案例"></a>有return案例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaWIthReturnNoParam</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// () -&gt; 233 ,其中return可以省略</span></span><br><span class="line"><span class="type">LambdaWIthReturnNoParam</span> <span class="variable">lambdaWIthReturnNoParam</span> <span class="operator">=</span> () -&gt; <span class="number">233</span>;</span><br><span class="line">System.out.println(lambdaWIthReturnNoParam.test());</span><br></pre></td></tr></table></figure>
<h5 id="多条执行语句"><a href="#多条执行语句" class="headerlink" title="多条执行语句"></a>多条执行语句</h5><h6 id="无return案例-1"><a href="#无return案例-1" class="headerlink" title="无return案例"></a>无return案例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用runable接口</span></span><br><span class="line"><span class="comment">// 多条执行语句的方法体必须使用 &#123; &#125; 包裹</span></span><br><span class="line"><span class="comment">// 语法规则基本与正常函数方法体一致</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;line1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;line2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h6 id="有return案例-1"><a href="#有return案例-1" class="headerlink" title="有return案例"></a>有return案例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 LambdaWIthReturnNoParam 接口</span></span><br><span class="line"><span class="comment">// return 也属于执行语句</span></span><br><span class="line"><span class="comment">// 多条语句场景 return 不可省略</span></span><br><span class="line"><span class="type">LambdaWIthReturnNoParam</span> <span class="variable">lambdaWIthReturnNoParam</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;line1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2022</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(lambdaWIthReturnNoParam.test());</span><br></pre></td></tr></table></figure>


<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>lambda表达式的使用必须要有对应的函数接口，并且该接口有且仅有一个无默认实现的函数(当接口的其他函数均由默认实现时，该接口也可使用lambda，如<code>Comparator</code>)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Arrays.sort(a, (o1, o2) -&gt; o2 - o1);</span><br><span class="line"><span class="comment">// 也可写成，不过Integer内置是固定升序的，无法修改</span></span><br><span class="line">Arrays.sort(a, Integer::compare);</span><br></pre></td></tr></table></figure></li>
<li>多参数场景下，要么都声明入参类型，要么都不声明，不允许一部分声明，一部分隐藏<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaFuncAccepter.testFunc((a, <span class="type">int</span> b) -&gt; System.out.println(a + b));</span><br><span class="line"><span class="comment">// 此时编译器会报错</span></span><br></pre></td></tr></table></figure></li>
<li>final 不能修饰推断类型入参，如需使用final，需要将入参显示设置类型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器会提示异常</span></span><br><span class="line">LambdaFuncAccepter.testFunc((a, <span class="keyword">final</span> b) -&gt; System.out.println(a + b));</span><br><span class="line"><span class="comment">// 需调整为如下所示:</span></span><br><span class="line">LambdaFuncAccepter.testFunc((<span class="type">int</span> a, <span class="keyword">final</span> <span class="type">int</span> b) -&gt; System.out.println(a + b));</span><br></pre></td></tr></table></figure></li>
<li>lambda方法体使用外部变量时，必须遵守声明时赋值后续不可赋值规则(同final修饰规则)，但调用对象函数修改对象内部状态合法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">    <span class="comment">// 虽然sb没有被final声明，但是在lambda内部存在隐形的final限制</span></span><br><span class="line">    <span class="comment">// sb = new StringBuilder();</span></span><br><span class="line">    sb.append(<span class="number">111</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;line1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 即便是在外部在初始化后再修改赋值，此时已经破坏final规则</span></span><br><span class="line">y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">    System.out.println(y);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li>
<li>使用数组一类时，需要注意下标的使用，如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">        <span class="comment">// 此时 i 不是遵守final规则的变量</span></span><br><span class="line">        System.out.println(b[i]);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以修改调整如下所示:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : b) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 此时变量i作为临时变量还尚未经历再一次的赋值修改，因此还遵守 effectively final 规则</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>lambda方法体使用外部变量时，必须确保所有外部变量均以完成初始化(仅声明不行，如分支，必须确保变量初始化)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">if</span> (sb.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// Variable &#x27;x&#x27; might not have been initialized</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/01/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>一书一图-Head First设计模式</title>
    <url>/2022/06/05/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-Head%20First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h4><ol>
<li>本书适合刚学习编程，并对编程十分感兴趣的同学，此书无法立刻提升编码能力，仅仅只能提供认知拓展；</li>
<li>设计模式是一种经验总结，并非发明创造，因此不能刻版的使用，需要因地制宜，甚至有些场景下，不适用任何设计模式解决问题反而会是最佳方案；</li>
<li>有一定的项目编码经验的同学更适合其他学习方式，如文字版的网页菜鸟教程或者视频类其他知识分享者上传的视频教程，本人更推荐文字版的，比较方便，更能快速的了解；</li>
<li>学习设计模式主要核心是弄清楚要解决的问题即使用场景，最好是能根据教材&#x2F;教程的案例，自己手敲一遍代码并运行去理解，仅仅靠定义去了解是远远不够的；</li>
<li>还想更进一步了解使用场景的同学可以去阅读各大开源项目的代码，尤其是中间件一类，因为更多会考虑性能和拓展问题，设计模式使用频率会远高于一般的业务项目；</li>
<li>思维导图中的一些优点缺点是结合部分网络教程的观点罗列而来，并非标准答案；</li>
<li>本文的思维导图仅是本人的读书笔记，不可作为权威版本去学习参考，可以简单浏览，如果感兴趣可以购买正版书籍学习；<span id="more"></span></li>
</ol>
<p><img src="http://img.janwarlen.com/blog/Head%20First%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="Head First设计模式"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>一书一图-深入理解Java虚拟机</title>
    <url>/2022/06/01/%E4%B8%80%E4%B9%A6%E4%B8%80%E5%9B%BE-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>Tips：  </p>
<ol>
<li>本书推荐按章节顺序读取，但是不同篇章需要不同程度的深入了解；</li>
<li>对于Java开发人员，本书最重要的篇章就是自动内存管理机制部分(第2章-第5章)，可以在日常的OOM和StackOverflow场景中提供巨大帮助，尤其其中提供的几个案例，更能帮助读者更好的理解内存管理；</li>
<li>其次就是高效并发篇章，该篇章可以帮助读者更深入的理解并发竞争的模型，理解为什么死锁，不过部分内容除了需要本书的其他篇章内容支撑外i，还需要额外了解操作系统知识(信号量)，并且无死锁场景的排查案例，因此需要读者需要额外通过其他方式学习如何在死锁时定位；</li>
<li>其他篇章内容对于Java开发人员基本只需要阅读产生印象即可，无需更深入了解(对大部分常规日常工作无明显帮助)；</li>
<li>平台(中间件)开发人员，需要额外深入阅读虚拟机执行子系统篇章，尤其是类加载内容，其中的双亲委派模型尤为重要；</li>
<li>思维导图不适合作为学习材料，可以简单一阅，建议购买正版书籍。<span id="more"></span></li>
</ol>
<p><img src="http://img.janwarlen.com/blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="深入理解Java虚拟机"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>读书笔记</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>一步一步数据结构-AVLTree</title>
    <url>/2018/04/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVLTree/</url>
    <content><![CDATA[<p>Tips：</p>
<ol>
<li>AVLTree是二叉搜索树的进一步变种</li>
<li>使用在AVLTree中的类需要实现Compareable接口</li>
<li>建议先理解链表与二叉树相关知识</li>
</ol>
<p><a href="https://github.com/JanWarlen/DemoList/blob/master/DataStructDemo/src/main/java/com/janwarlen/btree/AVLTree.java">demo代码</a></p>
<span id="more"></span>
<h4 id="理论背景"><a href="#理论背景" class="headerlink" title="理论背景"></a>理论背景</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>AVLTree首先是二叉搜索树</li>
<li>带有平衡条件：每个节点的左右节点的高度差值不超过1（左子数，右子树）</li>
<li>每个节点的左子树与右子树都是AVLTree</li>
</ul>
<center>![AVLTree](http://img.janwarlen.com/18-4-16/94024279.jpg)</center>  
<center>图1(AVLTree)</center>  
<center>![二叉树](http://img.janwarlen.com/18-4-16/91461504.jpg)</center>  
<center>图2(非AVLTree)</center>

<h5 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h5><p>节点的插入与删除都有可能会造成操作节点至根节点的所有节点的平衡信息，因此在执行插入和删除节点（单节点操作，非批量）后需要对树进行简单的修正来恢复平衡，这种操作就是旋转。<br>旋转一共适应四种情况：</p>
<ul>
<li>对节点x的左节点的左子树进行了一次插入  </li>
<li>对节点x的左节点的右子树进行了一次插入  </li>
<li>对节点x的右节点的左子树进行了一次插入  </li>
<li>对节点x的右节点的右子树进行了一次插入  <h5 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h5><img src="http://img.janwarlen.com/18-4-16/89314830.jpg" alt="单旋转示意图"><br>该示意图展示了第一个情况下的单旋转过程，图中节点a即情况中的节点x，<code>L1</code>即为左子树，至于插入的节点是<code>L1</code>中的哪一个则无关紧要，因为都是导致<code>L1</code>高度增加。因<code>L1</code>的高度增加，则对于节点a来说，左子树与右子树的高度差大于1，因此满足了旋转操作条件；<br>为了将树恢复平衡，我们需要将<code>L1</code>上移一层，并且将右子树<code>R1</code>下移一层，因此将节点b提升到根节点，此时右节点存在多个，因此根据二叉查询树的性质，子树R2是小于节点a的，因此断开节点b与子树R2的链接，将子树R2作为节点a的左子树。<h5 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h5><img src="http://img.janwarlen.com/18-4-17/89508273.jpg" alt="双旋转示意图"><br>该示意图展示了双旋转解决的一种情况，实际操作中b&#x2F;c仅会存在一个，因为插入b或者c时就会触发旋转操作。在示意图中，初始树无论是左单旋转还是右单旋转都无法一次平衡，因此，先进行局部旋转，待一次局部旋转后，二叉树将会转化为可单旋转的结构，此时再进行相应单旋转即可平衡二叉树。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h5><p>首先，因为AVLTree的特性是每个节点的左右子节点的高度差不大于1（另有说法为平衡因子），因此节点除了含有常规二叉树元素还需一个元素记录改节点高度，最终设计节点结构如下：<br><img src="http://img.janwarlen.com/18-4-17/78737741.jpg" alt="AVLTree 节点结构"><br>根据结构图设计节点代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T element)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(element, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T element, Node&lt;T&gt; l, Node&lt;T&gt; r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.element = element;</span><br><span class="line">        <span class="built_in">this</span>.left = l;</span><br><span class="line">        <span class="built_in">this</span>.right = r;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T element;</span><br><span class="line">    Node&lt;T&gt; left;</span><br><span class="line">    Node&lt;T&gt; right;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h5><h6 id="左单旋转"><a href="#左单旋转" class="headerlink" title="左单旋转"></a>左单旋转</h6><p>此处的左单旋转不是向左转，而是左子树进行旋转操作<br><img src="http://img.janwarlen.com/18-4-17/81615402.jpg" alt="左单旋转"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左单旋转</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">rotateWithLeftChild</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    Node&lt;T&gt; left = ele.left;</span><br><span class="line">    ele.left = left.right;</span><br><span class="line">    left.right = ele;</span><br><span class="line">    ele.height = Math.max(height(ele.left), height(ele.right)) + <span class="number">1</span>;</span><br><span class="line">    left.height = Math.max(height(left.left), height(left.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="右单旋转"><a href="#右单旋转" class="headerlink" title="右单旋转"></a>右单旋转</h6><p><img src="http://img.janwarlen.com/18-4-17/15092152.jpg" alt="右单旋转"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右单旋转</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">rotateWithRightChild</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    Node&lt;T&gt; right = ele.right;</span><br><span class="line">    ele.right = right.left;</span><br><span class="line">    right.left = ele;</span><br><span class="line">    ele.height = Math.max(height(ele.left), height(ele.right)) + <span class="number">1</span>;</span><br><span class="line">    right.height = Math.max(height(right.left), height(right.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="左双旋转"><a href="#左双旋转" class="headerlink" title="左双旋转"></a>左双旋转</h6><p><img src="http://img.janwarlen.com/18-4-17/60894239.jpg" alt="左双旋转"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左双旋转</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">doubleWithLeftChild</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    ele.left = rotateWithRightChild(ele.left);</span><br><span class="line">    <span class="keyword">return</span> rotateWithLeftChild(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="右双旋转"><a href="#右双旋转" class="headerlink" title="右双旋转"></a>右双旋转</h6><p><img src="http://img.janwarlen.com/18-4-17/80162235.jpg" alt="右双旋转"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右双旋转</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">doubleWithRightChild</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    ele.right = rotateWithLeftChild(ele.right);</span><br><span class="line">    <span class="keyword">return</span> rotateWithRightChild(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">balance</span><span class="params">(Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == ele) &#123;</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左子树高于右子树</span></span><br><span class="line">    <span class="keyword">if</span> (height(ele.left) - height(ele.right) &gt; ALLOWED_IMBALANCE) &#123;</span><br><span class="line">        <span class="comment">//判断需要单旋转还是双旋转</span></span><br><span class="line">        <span class="keyword">if</span> (height(ele.left.left) &gt;= height(ele.left.right)) &#123;</span><br><span class="line">            <span class="comment">//左单旋转</span></span><br><span class="line">            ele = rotateWithLeftChild(ele);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//左双旋转</span></span><br><span class="line">            ele = doubleWithLeftChild(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右子树高于左子树</span></span><br><span class="line">    <span class="keyword">if</span> (height(ele.right) - height(ele.left) &gt; ALLOWED_IMBALANCE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height(ele.right.right) &gt;= height(ele.right.left)) &#123;</span><br><span class="line">            <span class="comment">//右单旋转</span></span><br><span class="line">            ele = rotateWithRightChild(ele);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//右双旋转</span></span><br><span class="line">            ele = doubleWithRightChild(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新计算节点高度</span></span><br><span class="line">    ele.height = Math.max(height(ele.left), height(ele.right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ele;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>下图示例从1-9的插入过程，涵盖需要旋转情况并不全面<br><img src="http://img.janwarlen.com/18-4-18/22401721.jpg" alt="插入示例"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node&lt;T&gt; <span class="title function_">insert</span><span class="params">(T element, Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == ele) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;T&gt;(element);</span><br><span class="line">    &#125;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; comparableEle = (Comparable&lt;? <span class="built_in">super</span> T&gt;) element;</span><br><span class="line">    <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> comparableEle.compareTo(ele.element);</span><br><span class="line">    <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//left</span></span><br><span class="line">        ele.left = insert(element, ele.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareRes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        ele.right = insert(element, ele.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//duplicate</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逐层平衡</span></span><br><span class="line">    <span class="keyword">return</span> balance(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>下图示例元素6（右子树找最小）与元素5的删除过程。<br><img src="http://img.janwarlen.com/18-4-18/60876473.jpg" alt="删除 示例"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; <span class="title function_">remove</span><span class="params">(T element, Node&lt;T&gt; ele)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == ele) &#123;</span><br><span class="line">            <span class="keyword">return</span> ele;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; comparableEle = (Comparable&lt;? <span class="built_in">super</span> T&gt;) element;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compareRes</span> <span class="operator">=</span> comparableEle.compareTo(ele.element);</span><br><span class="line">        <span class="keyword">if</span> (compareRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ele.left = remove(element, ele.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareRes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ele.right = remove(element, ele.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != ele.left &amp;&amp; <span class="literal">null</span> != ele.right) &#123;</span><br><span class="line">                ele.element = findMax(ele.left).element;</span><br><span class="line">                ele.left = remove(ele.element, ele.left);</span><br><span class="line">            <span class="comment">//此处理论从左子树找最大和右子树找最小并无明显区别，因为最后都会经balance进行平衡</span></span><br><span class="line"><span class="comment">//            ele.element = findMin(ele.right).element;</span></span><br><span class="line"><span class="comment">//            ele.right = remove(ele.element, ele.right);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ele = (<span class="literal">null</span> != ele.left) ? ele.left : ele.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐层平衡</span></span><br><span class="line">        <span class="keyword">return</span> balance(ele);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>AVLTree</tag>
        <tag>二叉树</tag>
        <tag>一步一步数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>一步一步数据结构-红黑树</title>
    <url>/2018/07/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>Tips:  </p>
<ol>
<li>红黑树是搜索二叉树的变种，可以先行理解<a href="http://janwarlen.com/2018/04/12/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVLTree/">AVLTree</a>  </li>
<li>根据多方资料查找，很多人说2-3树和2-3-4树有助于理解红黑树（个人未进行深入了解，有兴趣可以自行搜索相关资料，或者等我再一次诈尸） <code>红黑树是2-3-4树的一种等同。换句话说，对于每个2-3-4树，都存在至少一个数据元素是同样次序的红黑树。在2-3-4树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得2-3-4树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍2-3-4树的原因，尽管2-3-4树在实践中不经常使用。 (wiki)</code>  </li>
<li>红黑树与AVL树不同，不具备部分AVL树的特性，如：每个节点的左右节点的高度差值不超过1</li>
<li>关于为什么新增节点一定是红色，个人未找到合理解释（目前仅理解为红色可以避免部分需要修复的情况），可能会在2-3-4树中找到原因</li>
</ol>
<p><a href="https://github.com/JanWarlen/DemoList/blob/master/DataStructDemo/src/main/java/com/janwarlen/btree/RBTree.java">demo代码</a><br><code>主要参考于TreeMap</code></p>
<span id="more"></span>

<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<h4 id="节点颜色修复"><a href="#节点颜色修复" class="headerlink" title="节点颜色修复"></a>节点颜色修复</h4><blockquote>
<p>旋转可以参考AVLTree中的介绍，但需注意在AVLTree中介绍的左旋与右旋的定义，本文中以方向定左右，上文以子树位置定左右。</p>
</blockquote>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>wiki百科中详细罗列了几种情况，此处我将会直接搬运，并且稍加个人理解，各位读者阅读时，请捎带“眼镜”以防被我的漏洞所误导。</p>
<ul>
<li>性质1和性质3总是保持着。</li>
<li>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</li>
<li>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</li>
</ul>
<p>关于这三点的理解，除了第一点外，剩余两点十分抽象，如果仅靠这个去尝试理解，需要自己手动模拟红黑树的插入。<br>下面我将由wiki列出的5中情况代入，去阐述插入所遇到的问题。</p>
<p><strong>注意：</strong>新增节点的插入，一定是叶子节点（在树的调整修复前，读者可以手动尝试，我将举简单例子）<br>插入： 1,5,2,7,4,6,9,3<br><img src="http://img.janwarlen.com/18-6-25/33467818.jpg" alt="红黑树例1"></p>
<blockquote>
<p>情形1:新节点N位于树的根上，没有父节点。在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑节点数目增加一，性质5匹配。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此处是指插入的新节点是树的根，因此只需要保证性质2`根是黑色`即可满足条件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>情形2:新节点的父节点P是黑色，所以性质4没有失效（新节点是红色的）。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为插入节点都是红色，因此并未破坏性质。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>情形3:如果父节点P和叔父节点U二者都是红色，（此时新插入节点N做为P的左子节点或右子节点都属于情形3，这里右图仅显示N做为P左子的情形）则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G可能是根节点，这就违反了性质2，也有可能祖父节点G的父节点是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行情形1的整个过程。（把G当成是新加入的节点进行各种情形的检查）</p>
</blockquote>
<p><img src="http://img.janwarlen.com/18-6-21/94370219.jpg" alt="情形3"><br><strong>注意：</strong><code>在余下的情形下，我们假定父节点P是其父亲G的左子节点。如果它是右子节点，情形4和情形5中的左和右应当对调。</code></p>
<blockquote>
<p>情形4:父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色;接着，我们按情形5处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。</p>
</blockquote>
<p><img src="http://img.janwarlen.com/18-6-25/46564427.jpg" alt="情形4"></p>
<blockquote>
<p>情形5：父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色（如果P和G都是红色就违反了性质4，所以G必须是黑色）。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。</p>
</blockquote>
<p><img src="http://img.janwarlen.com/18-6-25/24676155.jpg" alt="情形5"></p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>节点删除我们只需要考虑被删除的节点有一个子节点或者本身为叶子节点（叶子节点也可看做只有一个子节点），因被删除节点有两个子节点时，删除方案是使用前驱节点（左子树最大）或者后继节点（右子树最小）进行替换，然后删除替换节点（替换节点要么只有一个子节点，要么是叶子节点）。<br>情况一：删除红色节点，父节点、子节点都为黑色。不会破坏性质。<br><img src="http://img.janwarlen.com/18-6-25/5931354.jpg" alt="情况一"><br>情况二：删除黑色节点，子节点为红色。子节点提升，颜色修复红转黑，满足红黑树性质。<br><img src="http://img.janwarlen.com/18-6-25/71572459.jpg" alt="情况二"><br>情况三（四）：删除黑色节点，子节点也为黑色（需要注意双子节点情况，删除节点为替换节点）<br>不再单独列出情况四<br><img src="http://img.janwarlen.com/18-7-16/98551352.jpg" alt="例2"><br>需注意，删除中的例子<strong>无节点52</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void remove(Node&lt;T&gt; d) &#123;</span><br><span class="line"></span><br><span class="line">    //该if判断即是将双子节点情况转为单子节点情况</span><br><span class="line">    if (d.left != null &amp;&amp; d.right != null) &#123;</span><br><span class="line">        // 左右节点皆不为空，将待删除节点元素赋值为后继节点元素</span><br><span class="line">        // 注意，此时未带来节点颜色</span><br><span class="line">        Node&lt;T&gt; s = successor(d);</span><br><span class="line">        d.element = s.element;</span><br><span class="line">        // 待删除节点指针指向后继节点</span><br><span class="line">        d = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node&lt;T&gt; replacement = (d.left != null ? d.left : d.right);</span><br><span class="line"></span><br><span class="line">    if (replacement != null) &#123;</span><br><span class="line">        // 左右节点至少有一个节点不为空</span><br><span class="line">        replacement.parent = d.parent;</span><br><span class="line">        if (d.parent == null) &#123;</span><br><span class="line">            // 树仅有两个节点,d为根结点</span><br><span class="line">            root = replacement;</span><br><span class="line">        &#125; else if (d == d.parent.left) &#123;</span><br><span class="line">            // 待删除节点为父节点的左节点</span><br><span class="line">            d.parent.left = replacement;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 待删除节点为父节点的右节点</span><br><span class="line">            d.parent.right = replacement;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 断开待删除节点的所有链接</span><br><span class="line">        // 当待删除节点左右节点皆不为空时，此时d指向后继节点</span><br><span class="line">        d.left = d.right = d.parent = null;</span><br><span class="line"></span><br><span class="line">        // Fix replacement</span><br><span class="line">        // 当待删除节点为红色时，无需调整节点颜色</span><br><span class="line">        if (d.color == BLACK) &#123;</span><br><span class="line">            // 此时原节点已被删除，replacement是替换后节点</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (null == d.parent) &#123;</span><br><span class="line">        // 当前树仅有根结点</span><br><span class="line">        root = null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (d.color == BLACK)</span><br><span class="line">            // 待删除节点为叶子节点</span><br><span class="line">            fixAfterDeletion(d);</span><br><span class="line"></span><br><span class="line">        if (d.parent != null) &#123;</span><br><span class="line">            // 针对删除节点为叶子节点情况</span><br><span class="line">            if (d == d.parent.left)</span><br><span class="line">                d.parent.left = null;</span><br><span class="line">            else if (d == d.parent.right)</span><br><span class="line">                d.parent.right = null;</span><br><span class="line">            d.parent = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 待删除节点已被删除替换后，进行颜色修复</span><br><span class="line">private void fixAfterDeletion(Node&lt;T&gt; x) &#123;</span><br><span class="line">    //  只有节点为黑色才需要修复</span><br><span class="line">    while (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        // 左节点</span><br><span class="line">        if (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Node&lt;T&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            // 兄弟节点为红色，自己是黑色,设定为情况1</span><br><span class="line">            if (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                    colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                // 兄弟节点的子节点都为黑色,设定为情况2</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    // 兄弟节点的子节点只有右节点为黑色，设定为情况3</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                // 兄弟节点的右节点为红色,设定为情况4</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // symmetric</span><br><span class="line">            // 镜像对称</span><br><span class="line">            Node&lt;T&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            if (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                    colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.janwarlen.com/18-7-16/52797124.jpg" alt="情况三/四"><br>放在代码后是希望能先阅读代码再看过程，能更易理解</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>一步一步数据结构</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>基础语法探究</title>
    <url>/2018/02/27/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p><a href="https://github.com/JanWarlen/DemoList/tree/master/BasicGrammarDemo">测试代码</a></p>
<span id="more"></span>

<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul>
<li>Only access<blockquote>
<p>当使用foreach循环基本类型时变量时不能修改集合中的元素的值，遍历对象时可以修改对象的属性的值，但是不能修改对象的引用</p>
</blockquote>
</li>
<li>Only single structure<blockquote>
<p>同时只能遍历一个collection或数组，不能同时遍历多余一个collection或数组</p>
</blockquote>
</li>
<li>Only single element<blockquote>
<p>遍历过程中，collection或数组中同时只有一个元素可见，即只有“当前遍历到的元素”可见，而前一个或后一个元素是不可见的。</p>
</blockquote>
</li>
<li>Only forward<blockquote>
<p>只能正向遍历，不能反向遍历</p>
</blockquote>
</li>
<li>At least Java 5<blockquote>
<p>如果要兼容Java 5之前的Java版本，就不能使用For-each</p>
</blockquote>
</li>
<li>Iterable<blockquote>
<p>任何一个集合，无论是JDK提供的还是自己写的，只要想使用foreach循环遍历，就必须正确地实现Iterable接口</p>
</blockquote>
</li>
<li>Array<blockquote>
<p>Java将对于数组的foreach循环转换为对于这个数组每一个的循环引用。</p>
</blockquote>
</li>
</ul>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><ul>
<li>匹配的模式(Pattern flags)<br><code>Pattern Pattern.compile(String regex, int flag)</code></li>
</ul>
<table>
<thead>
<tr>
<th>编译标志</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Pattern.UNIX_LINES</td>
<td>启用 Unix 行模式。在此模式中，.、^ 和 $ 的行为中仅识别 ‘&#x2F;n’行结束符。通过嵌入式标志表达式 (?d) 也可以启用 Unix 行模式。</td>
</tr>
<tr>
<td>CASE_INSENSITIVE</td>
<td>启用不区分大小写的匹配。默认情况下，不区分大小写的匹配假定仅匹配 US-ASCII 字符集中的字符。可以通过指定#UNICODE_CASE标志连同此标志来启用 Unicode 感知的、不区分大小写的匹配。通过嵌入式标志表达式  (?i)也可以启用不区分大小写的匹配。指定此标志可能对性能产生一些影响。</td>
</tr>
<tr>
<td>COMMENTS</td>
<td>模式中允许空白和注释。此模式将忽略空白和在结束行之前以 #开头的嵌入式注释。通过嵌入式标志表达式  (?x) 也可以启用注释模式。</td>
</tr>
<tr>
<td>MULTILINE</td>
<td>启用多行模式。在多行模式中，表达式 ^ 和 $仅分别在行结束符前后匹配，或者在输入序列的结尾处匹配。默认情况下，这些表达式仅在整个输入序列的开头和结尾处匹配。通过嵌入式标志表达式 (?m) 也可以启用多行模式。</td>
</tr>
<tr>
<td>LITERAL</td>
<td>启用模式的字面值解析。指定此标志后，指定模式的输入字符串就会作为字面值字符序列来对待。输入序列中的元字符或转义序列不具有任何特殊意义。标志 CASE_INSENSITIVE 和 UNICODE_CASE 在与此标志一起使用时将对匹配产生影响。其他标志都变得多余了。不存在可以启用字面值解析的嵌入式标志字符。</td>
</tr>
<tr>
<td>DOTALL</td>
<td>启用 dotall 模式。在 dotall 模式中，表达式 .可以匹配任何字符，包括行结束符。默认情况下，此表达式不匹配行结束符。通过嵌入式标志表达式 (?s) 也可以启用 dotall 模式（s 是 “single-line” 模式的助记符，在 Perl 中也使用它）。</td>
</tr>
<tr>
<td>UNICODE_CASE</td>
<td>启用 Unicode 感知的大小写折叠。指定此标志后，由 #CASE_INSENSITIVE标志启用时，不区分大小写的匹配将以符合 Unicode Standard的方式完成。默认情况下，不区分大小写的匹配假定仅匹配 US-ASCII 字符集中的字符。通过嵌入式标志表达式 (?u)也可以启用 Unicode 感知的大小写折叠。指定此标志可能对性能产生影响。</td>
</tr>
<tr>
<td>CANON_EQ</td>
<td>启用规范等价。指定此标志后，当且仅当其完整规范分解匹配时，两个字符才可视为匹配。例如，当指定此标志时，表达式 “a&#x2F;u030A” 将与字符串 “&#x2F;u00E5”匹配。默认情况下，匹配不考虑采用规范等价。不存在可以启用规范等价的嵌入式标志字符。指定此标志可能对性能产生影响。</td>
</tr>
<tr>
<td>UNICODE_CHARACTER_CLASS</td>
<td>启用Unicode版本的预定义字符类和POSIX字符类。当这个标志被指定时，那么（仅US-ASCII）预定义的字符类和POSIX字符类符合Unicode技术标准＃18：Unicode正则表达式；附录C：兼容性属性； UNICODE_CHARACTER_CLASS模式也可以通过嵌入标志表达式(?U)。该标志暗示着UNICODE_CASE，也就是说，它启用Unicode感知的案例折叠，指定此标志可能会导致性能损失。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>BasicGrammar</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读-ArrayList</title>
    <url>/2018/03/01/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-ArrayList/</url>
    <content><![CDATA[<p>Tips：</p>
<ol>
<li>如果要在集合中使用自定义类，建议重写equals函数  </li>
<li>如果集合内元素较多，使用结束后建议清空（GC）  </li>
<li><a href="http://www.runoob.com/java/java-bitset-class.html">BitSet</a>  </li>
<li>ArrayList是非线程安全的  <span id="more"></span>
<h4 id="继承实现关系图"><a href="#继承实现关系图" class="headerlink" title="继承实现关系图"></a>继承实现关系图</h4><img src="http://img.janwarlen.com/18-3-1/80652992.jpg" alt="ArrayList"><br><strong>蓝色实线为继承，绿色虚线为实现</strong><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h4></li>
</ol>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">释义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DEFAULT_CAPACITY</td>
<td align="left">默认容量</td>
</tr>
<tr>
<td align="left">EMPTY_ELEMENTDATA</td>
<td align="left">创建大小为空实例时使用的空数组</td>
</tr>
<tr>
<td align="left">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</td>
<td align="left">给无参构造函数使用</td>
</tr>
<tr>
<td align="left">elementData</td>
<td align="left">数据数组</td>
</tr>
<tr>
<td align="left">size</td>
<td align="left">实际大小</td>
</tr>
<tr>
<td align="left">MAX_ARRAY_SIZE</td>
<td align="left">值为(Integer.MAX_VALUE - 8)，主要防止自动扩容时，申请空间过大</td>
</tr>
<tr>
<td align="left">modCount</td>
<td align="left">默认为0，统计集合的修改次数，也可用于线程安全判断</td>
</tr>
</tbody></table>
<h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建指定大小容量实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建默认实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据传入集合创建实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><h5 id="单元素添加"><a href="#单元素添加" class="headerlink" title="单元素添加"></a>单元素添加</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按顺序添加元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次添加元素之前都会进行容量检查，当容量不足时进行扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保集合有足够大小空间添加元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当最小需求大于当前集合空间容量时，进行扩容</span></span><br><span class="line"><span class="comment">* 大部分情况下会进行1.5倍扩容策略</span></span><br><span class="line"><span class="comment">* 当集合本身超过2/3的`Integer.MAX_VALUE`时，因1.5倍会超过整形最大值</span></span><br><span class="line"><span class="comment">* 因此会有`hugeCapacity`进行娄底，以防内存泄露</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当minCapacity &lt; 0 时，意味着当前集合元素数量基本已经达到整形最大值</span></span><br><span class="line"><span class="comment">* 因此会直接抛出`OutOfMemoryError`</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 否则进行最大化扩容</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="单元素指定位置添加"><a href="#单元素指定位置添加" class="headerlink" title="单元素指定位置添加"></a>单元素指定位置添加</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 指定位置添加元素采用的是指定索引及之后所有元素通过拷贝进行后移</span></span><br><span class="line"><span class="comment">* 在直接使用数组下标直接赋值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验索引是否合法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="添加集合"><a href="#添加集合" class="headerlink" title="添加集合"></a>添加集合</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 尾部拷贝</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="指定位置添加集合"><a href="#指定位置添加集合" class="headerlink" title="指定位置添加集合"></a>指定位置添加集合</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过两次拷贝完成</span></span><br><span class="line"><span class="comment">* 第一次拷贝腾出指定索引后传入集合大小的空间位置</span></span><br><span class="line"><span class="comment">* 第二次拷贝将传入集合元素拷贝进实例</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><h5 id="移除单个元素"><a href="#移除单个元素" class="headerlink" title="移除单个元素"></a>移除单个元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 移除元素都是移除索引在前的</span></span><br><span class="line"><span class="comment">* 如：aaacjgllstgt</span></span><br><span class="line"><span class="comment">* 移除g会先移除索引为5的，再次调用才会移除后面的</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 元素的判断调用了传入参数对象的equals方法，因此进行了为空区分</span></span><br><span class="line"><span class="comment">* 使用自定义对象建议完成equals方法的重写</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 拷贝指定索引之后的元素前移</span></span><br><span class="line"><span class="comment">* 元素数量减一，并末尾置空</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="根据条件删除元素"><a href="#根据条件删除元素" class="headerlink" title="根据条件删除元素"></a>根据条件删除元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="comment">// figure out which elements are to be removed</span></span><br><span class="line">    <span class="comment">// any exception thrown from the filter predicate at this stage</span></span><br><span class="line">    <span class="comment">// will leave the collection unmodified</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">removeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BitSet</span> <span class="variable">removeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            <span class="comment">//筛选出符合条件的待移除元素</span></span><br><span class="line">            <span class="comment">//并且记录该元素索引</span></span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="comment">//因为ArrayList不是线程安全的，该判断防止在筛选时，集合被改动</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">anyToRemove</span> <span class="operator">=</span> removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            <span class="comment">//返回无需移除的元素索引</span></span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            <span class="comment">//无需移除的元素留存</span></span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            <span class="comment">//置null多余元素</span></span><br><span class="line">            elementData[k] = <span class="literal">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.size = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="comment">//因为ArrayList不是线程安全的，该判断防止在筛选时，集合被改动</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回是否有移除</span></span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="移除指定集合"><a href="#移除指定集合" class="headerlink" title="移除指定集合"></a>移除指定集合</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 传入集合必须非 NULL</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* c为传入集合参数，complement为移除策略</span></span><br><span class="line"><span class="comment">* 分移除传入集合中元素（false），还是除传入集合元素之外移除（true）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="type">boolean</span> complement)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                <span class="comment">//此处代码是进行元素保留，并非移除</span></span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            <span class="comment">//如果有异常出现导致try中for循环中断</span></span><br><span class="line">            <span class="comment">//在异常位置开始拷贝，从留存索引进行保存，防止数据异常</span></span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">//如果有元素被移除，则无论是否发生异常</span></span><br><span class="line">            <span class="comment">//在留存元素的最后一个下标之后全部置NULL，让GC回收</span></span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="literal">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="保留指定集合内元素"><a href="#保留指定集合内元素" class="headerlink" title="保留指定集合内元素"></a>保留指定集合内元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本与移除指定集合一直，只是传参为true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全员置空，空间大小不变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><h5 id="是否包含元素"><a href="#是否包含元素" class="headerlink" title="是否包含元素"></a>是否包含元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果传入NULL，返回第一个null索引</span></span><br><span class="line"><span class="comment">* 如果不为null，使用传入参数对象的equals函数，返回第一个相等元素索引</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找元素的最后索引"><a href="#查找元素的最后索引" class="headerlink" title="查找元素的最后索引"></a>查找元素的最后索引</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从集合末尾开始查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查找指定索引元素"><a href="#查找指定索引元素" class="headerlink" title="查找指定索引元素"></a>查找指定索引元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改集合"><a href="#修改集合" class="headerlink" title="修改集合"></a>修改集合</h4><h5 id="修改指定索引元素"><a href="#修改指定索引元素" class="headerlink" title="修改指定索引元素"></a>修改指定索引元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换后返回旧元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="清除多余空间"><a href="#清除多余空间" class="headerlink" title="清除多余空间"></a>清除多余空间</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清除多余空间，使得GC能够回收</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="根据特殊条件置换元素"><a href="#根据特殊条件置换元素" class="headerlink" title="根据特殊条件置换元素"></a>根据特殊条件置换元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">//调用传入operator的apply方法处理特定元素，并返回处理结果进行替换</span></span><br><span class="line">        elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="comment">//因为ArrayList不是线程安全的，该判断防止在筛选时，集合被改动</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="根据指定规则排序"><a href="#根据指定规则排序" class="headerlink" title="根据指定规则排序"></a>根据指定规则排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="comment">//因为ArrayList不是线程安全的，该判断防止在筛选时，集合被改动</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>SourceCode</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>部分关键词探究</title>
    <url>/2018/02/27/%E9%83%A8%E5%88%86%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p><a href="https://github.com/JanWarlen/DemoList/tree/master/BasicGrammarDemo">测试代码</a></p>
<span id="more"></span>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul>
<li>成员变量</li>
<li>成员方法</li>
<li>静态块</li>
<li>静态导包</li>
</ul>
<h3 id="strictfp"><a href="#strictfp" class="headerlink" title="strictfp"></a>strictfp</h3><blockquote>
<p>浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，可以用关键字strictfp.通常处理器都各自实现浮点运算，各自专业浮点处理器为实现最高速，计算结果会和IEEE标准有细小差别。比如intel主流芯片的浮点运算，内部是80bit高精运算，只输出64bit的结果。IEEE只要求64bit精度的计算，你更精确反而导致结果不一样。所以设立‘严格浮点计算strictfp’，保证在各平台间结果一致，IEEE标准优先，性能其次；而非严格的浮点计算是“性能优先”，标准其次。<br><a href="https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin">https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin</a></p>
</blockquote>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><ul>
<li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li>
<li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</li>
<li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。<blockquote>
<p>若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。</p>
</blockquote>
</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul>
<li>确保线程互斥的访问同步代码;</li>
<li>保证共享变量的修改能够及时可见;</li>
<li>有效解决重排序问题.</li>
<li>偏向锁<blockquote>
<p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
</blockquote>
</li>
<li>轻量级锁<blockquote>
<p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p>
</blockquote>
</li>
<li>自旋锁<blockquote>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p>
</blockquote>
</li>
<li>锁消除<blockquote>
<p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p>
</blockquote>
</li>
<li>可重入性<blockquote>
<p>从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。</p>
</blockquote>
</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><a href="http://www.importnew.com/27002.html">参考1  就是要你懂 Java 中 volatile 关键字实现原理</a><br><a href="https://www.cnblogs.com/yzwall/p/6661528.html">参考2  volatile关键字与Java内存模型(JMM)</a></p>
<ul>
<li>汇编指令会多出Lock前缀<blockquote>
<p>将当前处理器缓存行的数据写回主存；<br>令其他CPU里缓存该内存地址的数据无效；</p>
</blockquote>
</li>
<li>针对编译器重排序<br><img src="http://img.janwarlen.com/18-2-1/65557665.jpg"></li>
<li>针对处理器重排序<br><img src="http://img.janwarlen.com/18-2-1/35462866.jpg"></li>
<li>在每个volatile变量写操作之前插入StoreStore屏障，之后插入StoreLoad屏障；<blockquote>
<p>之前插入StoreStore屏障：禁止volatile写之前的写操作与其重排序，保证之前的所有写操作都写回主存，对volatile写可见；<br>之后插入StoreLoad屏障：禁止volatile写之后的读写操作与其重排序，实现volatile写结果对后续操作可见；</p>
</blockquote>
</li>
</ul>
<p>+在每个volatile变量读操作之后，接连插入LoadLoad屏障，LoadStore屏障；</p>
<blockquote>
<p>插入LoadLoad屏障：禁止volatile变量读之后的读操作与其重排序；<br>插入LoadStore屏障：禁止volatile变量读之后的写操作与其重排序；<br>通过插入两次内存屏障，实现volatile读结果对后续操作可见；  </p>
</blockquote>
<h5 id="volatile用来修饰共享变量（成员变量，static变量）表明："><a href="#volatile用来修饰共享变量（成员变量，static变量）表明：" class="headerlink" title="volatile用来修饰共享变量（成员变量，static变量）表明："></a>volatile用来修饰共享变量（成员变量，static变量）表明：</h5><p><code>volatile变量写</code>：</p>
<ul>
<li>当写一个volatile变量时，JMM会把所有线程本地内存的对应变量副本刷新回主存；（注意是所有共享变量，不是一个volatile变量） </li>
<li>volatile写和解锁内存语义相同；</li>
</ul>
<p><code>volatile变量读</code>：</p>
<ul>
<li>当读一个volatile变量时，JMM会设置该线程的volatile变量副本（本地内存中）无效，线程只能从主存中读取该变量；  </li>
<li>保证了volatile变量读，总能看见对该volatile变量最后的修改；  </li>
<li>volatile变量读和加锁内存语义相同；</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>BasicGrammar</tag>
      </tags>
  </entry>
  <entry>
    <title>Curator&#39;s Tech Notes 翻译与部分验证</title>
    <url>/2018/02/26/Curator&#39;s_Tech_Notes/</url>
    <content><![CDATA[<p><a href="https://github.com/JanWarlen/DemoList/tree/master/CuratorDemo">测试代码</a></p>
<span id="more"></span>

<h4 id="ZooKeeper-watches-are-single-threaded"><a href="#ZooKeeper-watches-are-single-threaded" class="headerlink" title="ZooKeeper watches are single threaded."></a>ZooKeeper watches are single threaded.</h4><p>ZooKeeper的观察器（个人更愿意称作触发器，后续叫做触发器）是单线程的。</p>
<blockquote>
<p>When your watcher is called, it should return as quickly as possible. All ZooKeeper watchers are serialized - processed by a single thread. Thus, no other watchers can be processed while your watcher is running. For example, a Curator user had a watcher handler something like this:</p>
</blockquote>
<p>当你的触发器被触发，建议尽快返回结果。所有的ZooKeeper（在同一启动实例里的同一zk客户端实例）的触发器都是被一个单线程串行处理的，所以当一个触发器正在执行内部逻辑时，其他触发器无法运行其内部逻辑。下面是一个触发器的简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">InterProcessMutex   lock = ...</span><br><span class="line"> </span><br><span class="line">public void process(WatchedEvent event)</span><br><span class="line">&#123;</span><br><span class="line">    lock.acquire();</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>This cannot work. Curator’s InterProcessMutex relies on ZooKeeper watchers getting notified. The code above, however, is holding on to the ZooKeeper watcher processing thread. The way to fix this is to run the code that needs a lock in a separate thread. e.g.</p>
</blockquote>
<p>（非翻译）上面的做法是无效的，并且会影响其他的watcher。Curator的单个zk客户端实例的所有watcher都是单线程处理，所以锁的使用在单线程顺序执行时无意义的，并且因为锁的阻塞，会影响到后续watcher的执行时间。避免阻塞但是又想使用锁可以使用如下方法,将lock使用在watcher中另起的线程中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">InterProcessMutex   lock = ...</span><br><span class="line">ExecutorService    service = ...</span><br><span class="line"> </span><br><span class="line">public void process(WatchedEvent event)</span><br><span class="line">&#123;</span><br><span class="line">    service.submit(new Callable&lt;Void&gt;()&#123;</span><br><span class="line">        Void call() &#123;</span><br><span class="line">            lock.acquire();</span><br><span class="line">              ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="InterProcessMutex-acquire-can-be-used-to-return-immediately-if-lock-can’t-be-acquired"><a href="#InterProcessMutex-acquire-can-be-used-to-return-immediately-if-lock-can’t-be-acquired" class="headerlink" title="InterProcessMutex acquire() can be used to return immediately if lock can’t be acquired."></a>InterProcessMutex acquire() can be used to return immediately if lock can’t be acquired.</h4><blockquote>
<p>It’s not obvious from the docs, but calling InterProcessMutex.acquire(0, unit) will return immediately (i.e. without any waiting) if the lock cannot be acquired.<br>e.g.</p>
</blockquote>
<p>(非翻译)InterProcessMutex acquire()不会受到阻塞影响，会立即返回，不会等待获取锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">InterProcessMutex lock = ...</span><br><span class="line">boolean didLock = lock.acquire(0, TimeUnit.any);</span><br><span class="line">if ( !didLock )</span><br><span class="line">&#123;</span><br><span class="line">    // comes back immediately</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dealing-with-session-failure"><a href="#Dealing-with-session-failure" class="headerlink" title="Dealing with session failure"></a>Dealing with session failure</h4><blockquote>
<p>ZooKeeper clients maintain a session with the server ensemble. Ephemeral nodes are tied to this session. When writing ZooKeeper-based applications you must deal with session expirations (due to network partitions, server crashes, etc.). This ZooKeeper FAQ discusses it: <a href="http://wiki.apache.org/hadoop/ZooKeeper/FAQ#A3">http://wiki.apache.org/hadoop/ZooKeeper/FAQ#A3</a>  </p>
</blockquote>
<p>zk客户端实例需要维护和服务器的会话。临时节点是绑定在会话中的（连接和session断掉时被删除，已验证）。编写使用zk的应用程序必须要处理session的失效事件（比如网络分裂（network partition）、服务器故障等）</p>
<blockquote>
<p>For the most part, Curator shields you from the details of session management. However, Curator’s behavior can be modified. By default, Curator treats session failures the same way that it treats connection failures: i.e. the current retry policy is checked and, if permitted, operations are retried.  </p>
</blockquote>
<p>大多数情况下，Curator对用户屏蔽了session管理。但是，Curator的策略是可以被修改的。默认情况下，Curator会使用连接失效的处理方式处理session失效事件。—检查当前的重试策略，如果已授权，则重试操作。</p>
<blockquote>
<p>There are use-cases, though, where a series of operations must be tied to the ZooKeeper session. For example, an ephemeral node is created as a kind of marker then several other ZooKeeper operations are performed. If the session were to fail at any point, the entire operation should fail. Curator’s default behavior doesn’t do this. When you need this behavior, use:<code>SessionFailRetryLoop</code>  </p>
</blockquote>
<p>但是有些用户操作需要使用zk的session来保证一系列操作的完整性。比如说，先创建一个临时节点，然后执行其他几个zk的操作。如果在任何一个环节发生了session异常，那么整个（系列）操作应该是失败的。但是Curator的默认策略并没有采取这个措施。如果你也需要采取这个策略，请使用<code>SessionFailRetryLoop</code></p>
<blockquote>
<p>This is similar to the standard retry loop but if a session fails, any future Curator methods (in the same thread) will also fail.</p>
</blockquote>
<p>这和标准的循环重试非常相像，但是一旦session发成异常，所有的后续Curator的操作（同线程）都将失败。</p>
<h4 id="ZooKeeper-makes-a-very-bad-Queue-source"><a href="#ZooKeeper-makes-a-very-bad-Queue-source" class="headerlink" title="ZooKeeper makes a very bad Queue source"></a>ZooKeeper makes a very bad Queue source</h4><blockquote>
<p>The ZooKeeper recipes page lists Queues as a possible use-case for ZooKeeper. Curator includes several Queue recipes. In our experience, however, it is a bad idea to use ZooKeeper as a Queue:</p>
</blockquote>
<p><code>The ZooKeeper recipes page lists Queues</code>是zookeeper使用的一种方式。Curator包含大量的<code>Queue recipes</code>。但是，根据我们的经验，使用zookeeper作为队列是十分不建议的，理由如下：</p>
<blockquote>
<ul>
<li>ZooKeeper has a 1MB transport limitation. In practice this means that ZNodes must be relatively small. Typically, queues can contain many thousands of messages.</li>
</ul>
</blockquote>
<p>zookeeper通信有1MB的限制（每个节点大小限制）。因此这意味着在实践中ZNodes往往相对较小。一般情况下，队列可以保存数千条消息。</p>
<blockquote>
<ul>
<li>ZooKeeper can slow down considerably on startup if there are many large ZNodes. This will be common if you are using ZooKeeper for queues. You will need to significantly increase initLimit and syncLimit.</li>
</ul>
</blockquote>
<p>如果zookeeper中含有一定规模的大节点，zookeeper的启动速度将会明显降低。如果真的使用zookeeper作为队列使用这将会是非常常见的情况。使用者必须跨越式的增加<code>initLimit</code>和<code>syncLimit</code>。</p>
<blockquote>
<ul>
<li>If a ZNode gets too big it can be extremely difficult to clean. getChildren() will fail on the node. At Netflix we had to create a special-purpose program that had a huge value for jute.maxbuffer in order to get the nodes and delete them.</li>
</ul>
</blockquote>
<p>如果ZNode变得太大，清理将会更加艰难。<code>getChildren()</code>也会失败。在Netflix，我们必须创建含有大容量的<code>jute.maxbuffer</code>的特殊程序以获取节点并删除。</p>
<blockquote>
<ul>
<li>ZooKeeper can start to perform badly if there are many nodes with thousands of children.</li>
</ul>
</blockquote>
<p>如果有太多节点有数千的子节点，zookeeper的性能将会受到严重影响。</p>
<blockquote>
<ul>
<li>The ZooKeeper database is kept entirely in memory. So, you can never have more messages than can fit in memory.</li>
</ul>
</blockquote>
<p>因为zookeeper是保存在内存中的，所以内存大小会限制消息内容的多少。</p>
<h4 id="Porting-Netflix-Curator-code-to-Apache-Curator"><a href="#Porting-Netflix-Curator-code-to-Apache-Curator" class="headerlink" title="Porting Netflix Curator code to Apache Curator"></a>Porting Netflix Curator code to Apache Curator</h4><blockquote>
<p>The APIs in Apache Curator are exactly the same as Netflix Curator. The only difference is the package names. Simply replace com.netflix.* with org.apache.*.</p>
</blockquote>
<p><code>Netflix Curator</code>和<code>Apache Curator</code>是完全一致的，只需要修改包名就可以了。</p>
<h4 id="Friends-don’t-let-friends-write-ZooKeeper-recipes"><a href="#Friends-don’t-let-friends-write-ZooKeeper-recipes" class="headerlink" title="Friends don’t let friends write ZooKeeper recipes"></a>Friends don’t let friends write ZooKeeper recipes</h4><blockquote>
<p>Writing ZooKeeper code is on par with the difficulty in writing concurrent language code. As we all know Concurrency is Hard! For ZooKeeper in particular, there are numerous edge case and undocumented behaviors that you must know in order to write correct recipes. In light of this, we strongly suggest you use one of the existing Curator pre-built recipes instead of writing raw ZooKeeper code yourself. At minimum, use a Curator recipe as a base for your work.</p>
</blockquote>
<p>编写zookeeper的代码的难度和并发编程的难度基本一致。而并发编程是众所周知的困难！特别是对于zookeeper来说，要编写出正确的<code>recipe</code>，使用者必须知道非常繁多的边界情况和无文档的特性。因此，强烈建议使用Curator的预编译<code>recipes</code>而不是自己撰写zookeeper代码。至少，使用<code>Curator recipe</code>作为使用者的工作基础。</p>
<h4 id="Curator-Recipes-Own-Their-ZNode-x2F-Paths"><a href="#Curator-Recipes-Own-Their-ZNode-x2F-Paths" class="headerlink" title="Curator Recipes Own Their ZNode&#x2F;Paths"></a>Curator Recipes Own Their ZNode&#x2F;Paths</h4><blockquote>
<p>Do not use paths passed to Curator recipes. Curator recipes rely on owning those paths and the ZNodes in those paths. For example, do not add your own ZNodes to the path passed to LeaderSelector, etc.</p>
</blockquote>
<p>不要使用传递给<code>Curator recipes</code>的路径。<code>Curator recipes</code>依赖于这些路径及其子节点。比如，不要在传递给<code>LeaderSelector</code>的路径下添加使用者自己的节点，范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selector = <span class="keyword">new</span> <span class="title class_">LeaderSelector</span>(client, <span class="string">&quot;/leader&quot;</span>, listener);</span><br><span class="line">client.create().forPath(<span class="string">&quot;/leader/mynode&quot;</span>);   <span class="comment">// THIS IS NOT SUPPORTED!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Also, do not delete nodes that have been “given” to a Curator recipe.</p>
</blockquote>
<p>同样的，也别删除。</p>
<h4 id="Controlling-Curator-Logging"><a href="#Controlling-Curator-Logging" class="headerlink" title="Controlling Curator Logging"></a>Controlling Curator Logging</h4><blockquote>
<p>Curator logging can be customized. Use the following switches via the command line (-D) or via System.setProperty()</p>
</blockquote>
<p>Curator日志可以自定义。通过命令行(-D)或者<code>System.setProperty()</code>使用如下配置：</p>
<table>
<thead>
<tr>
<th>Switch</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>curator-dont-log-connection-problems&#x3D;true</td>
<td>Normally, connection issues are logged as the warning “Connection attempt unsuccessful…” or the error “Connection timed out…”. This switch turns these messages off.</td>
</tr>
<tr>
<td>curator-log-events&#x3D;true</td>
<td>All ZooKeeper events will be logged as DEBUG.</td>
</tr>
<tr>
<td>curator-log-only-first-connection-issue-as-error-level&#x3D;true</td>
<td>When this switch is enabled, the first connection issue is logged as ERROR. Additional connection issues are logged as DEBUG until the connection is restored.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>curator-dont-log-connection-problems&#x3D;true</td>
<td>正常情况下，连接问题会被记录为警告”Connection attempt unsuccessful…”或者错误”Connection timed out…”，该配置将会关闭这些信息</td>
</tr>
<tr>
<td>curator-log-events&#x3D;true</td>
<td>所有的zookeeper事件的记录都为DEBUG</td>
</tr>
<tr>
<td>curator-log-only-first-connection-issue-as-error-level&#x3D;true</td>
<td>当启用该配置，第一次连接问题会被记录为错误。额外的连接问题会被以DEBUG记录直到连接恢复</td>
</tr>
</tbody></table>
<h4 id="PathChildrenCache-now-uses-getData-instead-of-checkExists"><a href="#PathChildrenCache-now-uses-getData-instead-of-checkExists" class="headerlink" title="PathChildrenCache now uses getData() instead of checkExists()."></a>PathChildrenCache now uses getData() instead of checkExists().</h4><blockquote>
<p>Curator 2.5.0 changes internal behavior for PathChildrenCache. Now, regardless of whether or not “cacheData” is set to true, PathChildrenCache will always call getData on the nodes. This is due to <a href="https://issues.apache.org/jira/browse/CURATOR-107">CURATOR-107</a>. It’s been shown that using checkExists() with watchers can cause a type of memory leak as watchers will be left dangling on non-existent ZNodes. Calling getData() works around this issue. However, it’s possible that this change will affect performance. If you would like the old behavior of using checkExists(), you can set a system property: add -Dcurator-path-children-cache-use-exists&#x3D;true to your command line or call System.setProperty(“curator-path-children-cache-use-exists”, “true”).</p>
</blockquote>
<p>Curator 2.5.0 改变了<code>PathChildrenCache</code>的内部行为。现在，不论是否设置<code>cacheData</code>为true，<code>PathChildrenCache</code>都将会在节点上调用方法<code>getData</code>。原因可以查看该文档<a href="https://issues.apache.org/jira/browse/CURATOR-107">CURATOR-107</a>。该文档写明，在观察者中使用<code>checkExists()</code>将会导致某种类存泄露，因为观察者有可能会挂在不存在的节点上。调用<code>cacheData</code>可以解决此问题。但是，这种改变可能会影响性能。如果你更愿意使用旧方式处理<code>checkExists()</code>，你可以设置系统属性：<br>添加<code>-Dcurator-path-children-cache-use-exists=true</code>在命令行或者使用函数<code>System.setProperty(&quot;curator-path-children-cache-use-exists&quot;, &quot;true&quot;)</code></p>
<h4 id="JVM-pauses-can-cause-unexpected-client-state-with-improperly-chosen-session-timeouts"><a href="#JVM-pauses-can-cause-unexpected-client-state-with-improperly-chosen-session-timeouts" class="headerlink" title="JVM pauses can cause unexpected client state with improperly chosen session timeouts"></a>JVM pauses can cause unexpected client state with improperly chosen session timeouts</h4><blockquote>
<blockquote>
<p>Background discussion: <a href="http://qnalist.com/questions/6134306/locking-leader-election-and-dealing-with-session-loss">http://qnalist.com/questions/6134306/locking-leader-election-and-dealing-with-session-loss</a></p>
</blockquote>
</blockquote>
<blockquote>
<p>ZooKeeper&#x2F;Curator recipes rely on a consistent view of the state of the ensemble. ZooKeeper clients maintain a session with the server they are connected to. Clients maintain periodic heartbeats to the server to maintain this session. If a heartbeat is missed, the client goes into Disconnected state. When this happens, Curator goes into SUSPENDED via the ConnectionStateListener. Any locks, etc. must be considered temporarily lost while the connection is SUSPENDED (see <a href="http://curator.apache.org/errors.html">http://curator.apache.org/errors.html</a> and the Error Handling section of each recipe’s documentation). </p>
</blockquote>
<p>(非翻译)zookeeper的客户端维护了当前连接的session。同时客户端还维护了定期的心跳来维持session。如果心跳因为种种原因漏过了，当前客户端将会进入<code>Disconnected</code>状态。如果发生这种情况，<code>Curator</code>将会通过<code>ConnectionStateListener</code>进入<code>SUSPENDED</code>状态。任何锁一类的情况必须考虑连接的短暂失连。</p>
<blockquote>
<p>The implication of this is that great care must be taken to tune your JVM and choose an appropriate session timeout. Here’s an example of what can happen if this is not done:</p>
</blockquote>
<p>这意味着必须小心的调整JVM参数并且设定恰当的session失效时间。以下罗列了一个未正确设置会发生的情况：</p>
<blockquote>
<ul>
<li>A session timeout of 3 seconds is used</li>
<li>Client A creates a Curator InterProcessMutex and acquires the lock</li>
<li>Client B also creates a Curator InterProcessMutex for the same path and is blocked waiting for the lock to release</li>
<li>Client A’s JVM has a stop-the-world GC for 10 seconds<ul>
<li>Client A’s session will have lapsed due to missed heartbeats</li>
<li>ZooKeeper will delete Client A’s EPHEMERAL node representing its InterProcessMutex lock</li>
<li>Client B’s watcher will fire and it will successfully gain the lock</li>
</ul>
</li>
<li>After the GC, Client A will un-pause</li>
<li>For a short period of time, BOTH CLIENT A AND CLIENT B WILL BELIEVE THEY ARE THE LOCK HOLDER</li>
</ul>
</blockquote>
<ul>
<li>session超时3秒</li>
<li>Client A 创建了一个<code>Curator InterProcessMutex</code>并且申请获取锁</li>
<li>Client B 也创建了一个<code>Curator InterProcessMutex</code>在同样的路径下，并且等待A释放锁</li>
<li>Client A 的JVM发生了全局GC，暂停了10s<ul>
<li>Client A的session将会因为错过心跳而失效</li>
<li>zookeeper将会删除Client A代表<code>InterProcessMutex lock</code>的临时节点</li>
<li>Client B观察者将会触发，并且可以成功获取锁</li>
</ul>
</li>
<li>完成GC后，client A会继续运行</li>
<li>在很短的时间内，<strong>A和B都认定他们都是锁的拥有者</strong></li>
</ul>
<blockquote>
<p>The remedy for this is tune your JVM so that GC pauses (or other kinds of pauses) do not exceed your session timeout. JVM tuning is beyond the scope of this Tech Note. The default Curator session timeout is 60 seconds. Very low session timeouts should be considered risky.</p>
</blockquote>
<p>针对这种情况的补救措施就是修改调整JVM参数，使得GC时间（或者任意一种能够导致全局暂停的）不会超过之前设定的session失效时间。JVM设置不在本篇范畴内讨论。默认的Curator的session失效时间是60s。如果失效时间过低，这就需要考虑该情况的风险控制。</p>
<blockquote>
<p>Summary: there is always an edge case where VM pauses might exceed your client heartbeat and cause a client misperception about it’s state for a short period of time once the VM un-pauses. In practice, a tuned VM that has been running within known bounds for a reasonable period will not exhibit this behavior. Session timeout must match this known bounds in order to have consistent client state. </p>
</blockquote>
<p>总结：如同“墨菲定律”，VM暂停一定会在某种情况下超过你的客户端心跳然后在VM结束暂停后很短的时间内使得客户端的状态陷入混乱。实际上，一个调整过的VM在已知边界下的合理时间内运行将不会发生这种情况。session失效时间必须适配已知的边界情况以保持客户端状态的一致。</p>
<h4 id="Curator-internally-wraps-Watchers"><a href="#Curator-internally-wraps-Watchers" class="headerlink" title="Curator internally wraps Watchers"></a>Curator internally wraps Watchers</h4><blockquote>
<p>When you set Watchers using Curator, your Watcher instance is not passed directly to ZooKeeper. Instead it is wrapped in a special-purpose Curator Watcher (the internal class, NamespaceWatcher). Normally, this is not an issue and is transparent to your client code. However, if you bypass Curator and set a Watcher directly with the ZooKeeper handle, ZooKeeper will not recognize it as the same Watcher set via Curator and that watcher will get called twice when it triggers.</p>
</blockquote>
<p>当你使用Curator设置Watcher的时候，Watcher的实例是不会直接连接zookeeper的。取而代之的是使用一个特殊的<code>Curator Watcher</code>（内部类，<code>NamespaceWatcher</code>）。一般而言，这不是错误并且对于你的客户端代码，这部分是透明的。但是，如果你绕过Curator直接在<code>ZooKeeper handle</code>上设置Watcher，zookeeper将无法识别出是否是已经通过Curator设置的Watcher，因此该Watcher将会在触发的时候调用两次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="type">Watcher</span>   <span class="variable">myWatcher</span> <span class="operator">=</span> ...</span><br><span class="line">curator.getData().usingWatcher(myWatcher).forPath(path);</span><br><span class="line">curator.getZookeeperClient().getZooKeeper().getData(path, myWatcher, stat);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// myWatcher will get called twice when the data for path is changed</span></span><br></pre></td></tr></table></figure>
<p>Tip：经验证</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>调用次数</th>
</tr>
</thead>
<tbody><tr>
<td>curator.getData().usingWatcher(myWatcher).forPath(path);<br> curator.getData().usingWatcher(myWatcher).forPath(path);</td>
<td>1</td>
</tr>
<tr>
<td>curator.getZookeeperClient().getZooKeeper().getData(path, myWatcher, stat);<br>curator.getZookeeperClient().getZooKeeper().getData(path, myWatcher, stat);</td>
<td>1</td>
</tr>
<tr>
<td>curator.getData().usingWatcher(myWatcher).forPath(path);<br>    curator.getZookeeperClient().getZooKeeper().getData(path, myWatcher, stat);</td>
<td>2</td>
</tr>
<tr>
<td>总结，zookeeper会认定通过Curator和Zookeeper Handle绑定的watcher是不同的，但是同一方式重复绑定会被zookeeper识别从而避免多次触发。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="Curator-connection-semantics"><a href="#Curator-connection-semantics" class="headerlink" title="Curator connection semantics"></a>Curator connection semantics</h4><blockquote>
<p>The following events occur in the life cycle of a connection between Curator and Zookeeper.<br>CONNECTED: This occurs when Curator initially connects to Zookeeper. It will only ever be seen once per Curator instance.<br>SUSPENDED: This occurs as soon as Curator determines that it has lost its connection to Zookeeper  </p>
</blockquote>
<p>以下事件发生在Curator和zookeeper连接的生命周期中（即在连接中）：<br>已连接：当Curator初始化时连接zookeeper时发生。每个Curator实例只会发生一次。<br>挂起：一旦Curator确定与zookeeper的连接丢失，立即发生</p>
<blockquote>
<p>LOST: The meaning of a LOST even varies between Curator 2.X and Curator 3.X.<br>In all versions of Curator, a LOST event may be explicitly received from Zookeeper if Curator attempts to use a session that has been timed out by Zookeeper.<br>In Curator 2.X a LOST event will occur when Curator gives up retrying an operation. The number of retries is determined by the specified retry policy. A LOST event of this type does not necessarily mean that the session on the server has been lost, but it must be assumed to be so.</p>
</blockquote>
<p>丢失：在Curator 2.X版本与3.X版本有多种释义。<br>无论什么版本，只要Curator尝试使用已经被zookeeper超时的session时，zookeeper就<code>may be explicitly</code>发出一个<code>LOST</code>事件。<br>在2.X的版本中，<code>LOST</code>将会在Curator客户端放弃重试操作时发生。重试次数由明确的重试策略决定。发生这类的<code>LOST</code>事件并不等同于session超时丢失，但我们必须假设已经超时丢失。</p>
<blockquote>
<p>In Curator 3.x, Curator attempts to simulate server side session loss, by starting a timer (set to the negotiated session timeout length) upon receiving the SUSPENDED event. If the timer expires before Curator re-establishes a connection to Zookeeper then Curator will publish a LOST event. It can be assumed that if this LOST event is received that the session has timed out on the server (though this is not guaranteed as Curator has no connection to the server at this point to confirm this).  </p>
</blockquote>
<p>在3.X的版本中，Curator会通过启用一个监听<code>SUSPENDED</code>事件的计时器（设置为session的超时时间）尝试模拟服务器端的session丢失。如果计时器在Curator重新建立起与zookeeper的连接前失效，Curator就将会发布<code>LOST</code>事件。可以假设，如果接收到该<code>LOST</code>事件，就认定在服务器的session已经超时（尽管因为Curator已经丢失了与服务器的连接无法确认这一点）</p>
<blockquote>
<p>RECONNECTED: This occurs once a connection has been reestablished to Zookeeper.</p>
</blockquote>
<p>重连：当与zookeeper的连接重新建立时发生。</p>
<h4 id="Guava-usage-in-Curator"><a href="#Guava-usage-in-Curator" class="headerlink" title="Guava usage in Curator"></a>Guava usage in Curator</h4><h5 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h5><blockquote>
<p>Since Curator was created at Netflix it has used Google’s popular Guava library. Due to the many versions of Guava used in projects that also use Curator there has always been the potential for conflicts. Recent versions of Guava removed some APIs that Curator uses internally and Curator users were getting ClassNotFoundException, etc. <a href="https://issues.apache.org/jira/browse/CURATOR-200">CURATOR-200</a> addresses these issues by shading Guava into Curator.</p>
</blockquote>
<p>因为Curator是由Netflix创建的组件，所以该组件使用了很多谷歌的<code>Guava</code>类库。由于多版本的Guava和Curator在同一项目中使用，这将可能会导致潜在的冲突。最近的Guava版本移除了部分Curator内部使用的API，然后使用者就会收到<code>ClassNotFoundException</code>异常，etc。<a href="https://issues.apache.org/jira/browse/CURATOR-200">CURATOR-200</a>在Curator的包引用中屏蔽Guava就可以解决这类问题。</p>
<h5 id="Shaded-But-Not-Gone"><a href="#Shaded-But-Not-Gone" class="headerlink" title="Shaded But Not Gone"></a>Shaded But Not Gone</h5><blockquote>
<p>Unfortunately, a few of Curator’s public APIs use Guava classes (e.g. ListenerContainer’s use of Guava’s Function). Breaking public APIs would cause as much harm as solving the Guava problem. So, it was decided to to shade all of Guava except for these three classes:</p>
</blockquote>
<p>不幸的是，少部分Curator的公共API使用了Guava的类（ListenerContainer使用了Guava的<code>Function</code>）。当解决Guava版本冲突问题的时候会导致开放的API被破坏。因此，以下三个类将移除屏蔽：</p>
<blockquote>
<ul>
<li>com.google.common.base.Function</li>
<li>com.google.common.base.Predicate</li>
<li>com.google.common.reflect.TypeToken</li>
</ul>
</blockquote>
<blockquote>
<p>The implication of this is that Curator still has a hard dependency on Guava but only for these three classes. What this means for Curator users is that you can use whatever version of Guava your project needs without concern about ClassNotFoundException, NoSuchMethodException, etc.</p>
</blockquote>
<h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h5><blockquote>
<ul>
<li>All but three Guava classes are completed shaded into Curator</li>
<li>Curator still has a hard dependency on Guava but you should be able to use whatever version of Guava your project needs</li>
</ul>
</blockquote>
<ul>
<li>除了三个类，其他Guava都被屏蔽</li>
<li>Curator依然对于Guava有强依赖，但使用者不用再担心Guava的版本，可自由选择</li>
</ul>
<p><a href="https://github.com/Randgalt/curator-guava-example">https://github.com/Randgalt/curator-guava-example</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Curator</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Java版本特性-StreamAPI</title>
    <url>/2022/06/08/Java%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7-StreamAPI/</url>
    <content><![CDATA[<h3 id="引用参考文档链接"><a href="#引用参考文档链接" class="headerlink" title="引用参考文档链接"></a>引用参考文档链接</h3><ol>
<li><a href="https://dev.java/learn/the-stream-api/">Java官方学习手册-Stream</a></li>
<li><a href="https://github.com/CarpenterLee/JavaLambdaInternals">GitHub-CarpenterLee-JavaLambdaInternals</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html">Oracle关于parallelism官方文档</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description">Oracle关于Stream包官方描述文档</a><span id="more"></span></li>
</ol>
<h2 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol>
<li>Stream API 是关于向 JDK 提供众所周知的 map-filter-reduce 算法的实现</li>
<li><code>map</code>只会变更对象的类型，不会改变对象集合的数量</li>
<li><code>filter</code>只会改变对象集合的数量，而不会改变其中对象的类型</li>
<li><code>reduce</code>允许针对数据流构建任何你想构建的数据结构</li>
</ol>
<h4 id="案例-统计所有人口超过10w的城市人口总和"><a href="#案例-统计所有人口超过10w的城市人口总和" class="headerlink" title="案例 - 统计所有人口超过10w的城市人口总和"></a>案例 - 统计所有人口超过10w的城市人口总和</h4><h5 id="城市类定义"><a href="#城市类定义" class="headerlink" title="城市类定义"></a>城市类定义</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">City</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">City</span><span class="params">(String name, <span class="type">int</span> population)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.population = population;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 城市名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 城市人口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> population;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPopulation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> population;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPopulation</span><span class="params">(<span class="type">int</span> population)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.population = population;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;City&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, population=&quot;</span> + population +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;City&gt; cities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">City</span> <span class="variable">city1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;1&quot;</span>, <span class="number">50_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;2&quot;</span>, <span class="number">2_100_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;3&quot;</span>, <span class="number">90_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;4&quot;</span>, <span class="number">130_000</span>);</span><br><span class="line"><span class="type">City</span> <span class="variable">city5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">City</span>(<span class="string">&quot;5&quot;</span>, <span class="number">1_000_000</span>);</span><br><span class="line">cities.add(city1);</span><br><span class="line">cities.add(city2);</span><br><span class="line">cities.add(city3);</span><br><span class="line">cities.add(city4);</span><br><span class="line">cities.add(city5);</span><br></pre></td></tr></table></figure>

<h5 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (City city : cities) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">population</span> <span class="operator">=</span> city.getPopulation();</span><br><span class="line">    <span class="keyword">if</span> (population &gt; <span class="number">100_000</span>) &#123;</span><br><span class="line">        sum += population;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure>

<h5 id="StreamApi写法"><a href="#StreamApi写法" class="headerlink" title="StreamApi写法"></a>StreamApi写法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步先创建流</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> cities.stream()</span><br><span class="line"><span class="comment">// 第二步 将城市集合转换为人口集合</span></span><br><span class="line">        .mapToInt(City::getPopulation)</span><br><span class="line"><span class="comment">// 第三步 过滤人口超过 10w 的城市人口</span></span><br><span class="line">        .filter(population -&gt; population &gt; <span class="number">100_000</span>)</span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line">        .sum();</span><br><span class="line">System.out.println(<span class="string">&quot;Stream Sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure>

<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h4><h5 id="创建一个空流"><a href="#创建一个空流" class="headerlink" title="创建一个空流"></a>创建一个空流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.empty()</span><br></pre></td></tr></table></figure>
<p>一般场景不会用到，通常与<code>flatMap</code>结合使用，过滤不需要的元素</p>
<h5 id="从可变参数或数组创建流"><a href="#从可变参数或数组创建流" class="headerlink" title="从可变参数或数组创建流"></a>从可变参数或数组创建流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Arrays.stream(array)</span><br></pre></td></tr></table></figure>

<h5 id="给定规则创建流并持续添加元素"><a href="#给定规则创建流并持续添加元素" class="headerlink" title="给定规则创建流并持续添加元素"></a>给定规则创建流并持续添加元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(Supplier&lt;T&gt; s)</span><br><span class="line"></span><br><span class="line">Stream.generate(() -&gt; <span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>需注意的是，该方法将会无限制的添加元素进入流中，需要搭配<code>limit</code>使用，避免<code>OOM</code></p>
<h5 id="创建符合一定规则的流"><a href="#创建符合一定规则的流" class="headerlink" title="创建符合一定规则的流"></a>创建符合一定规则的流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// seed是第一个元素， UnaryOperator则是所有后续元素将要遵守的规则</span></span><br><span class="line">Stream.iterate(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line">Stream.iterate(<span class="string">&quot;+&quot;</span>, s -&gt; s + <span class="string">&quot;+&quot;</span>)</span><br><span class="line"><span class="comment">// +</span></span><br><span class="line"><span class="comment">// ++</span></span><br><span class="line"><span class="comment">// +++</span></span><br><span class="line"><span class="comment">// ++++</span></span><br><span class="line"><span class="comment">// +++++</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>通常需要搭配<code>limit</code>使用,<code>Java9</code>该方法添加了重载，添加了入参，可自定义停止创建规则，当规则符合false则停止创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="string">&quot;+&quot;</span>, s -&gt; s.length() &lt;= <span class="number">5</span>, s -&gt; s + <span class="string">&quot;+&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="创建一个在一定范围的数字流"><a href="#创建一个在一定范围的数字流" class="headerlink" title="创建一个在一定范围的数字流"></a>创建一个在一定范围的数字流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">IntStream.range(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">IntStream.rangeClosed(<span class="number">0</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h5 id="创建随机数流"><a href="#创建随机数流" class="headerlink" title="创建随机数流"></a>创建随机数流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10L</span>);</span><br><span class="line">random.ints();</span><br><span class="line">random.ints(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// [0, 7)</span></span><br><span class="line">random.ints(<span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// [2,9)</span></span><br><span class="line">random.ints(<span class="number">10</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>相对应的，还有<code>long</code>与<code>double</code></p>
<h5 id="通过String创建char字符流"><a href="#通过String创建char字符流" class="headerlink" title="通过String创建char字符流"></a>通过String创建char字符流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">chars</span> <span class="operator">=</span> test.chars();</span><br></pre></td></tr></table></figure>

<h5 id="读取文件创建流"><a href="#读取文件创建流" class="headerlink" title="读取文件创建流"></a>读取文件创建流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">log</span> <span class="operator">=</span> Path.of(<span class="string">&quot;/tmp/debug.log&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(log)) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="variable">warnings</span> <span class="operator">=</span> </span><br><span class="line">        lines.filter(line -&gt; line.contains(<span class="string">&quot;WARNING&quot;</span>))</span><br><span class="line">             .count();</span><br><span class="line">    System.out.println(<span class="string">&quot;Number of warnings = &quot;</span> + warnings);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// do something with the exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="通过正则创建流"><a href="#通过正则创建流" class="headerlink" title="通过正则创建流"></a>通过正则创建流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sentence</span> <span class="operator">=</span> <span class="string">&quot;For there is good news yet to hear and fine things to be seen&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot; &quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = pattern.splitAsStream(sentence);</span><br></pre></td></tr></table></figure>

<h5 id="通过Builder创建流"><a href="#通过Builder创建流" class="headerlink" title="通过Builder创建流"></a>通过Builder创建流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.Builder&lt;String&gt; builder = Stream.&lt;String&gt;builder();</span><br><span class="line"></span><br><span class="line">builder.add(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">       .add(<span class="string">&quot;two&quot;</span>)</span><br><span class="line">       .add(<span class="string">&quot;three&quot;</span>)</span><br><span class="line">       .add(<span class="string">&quot;four&quot;</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = builder.build();</span><br></pre></td></tr></table></figure>

<h4 id="常用方法及功能描述"><a href="#常用方法及功能描述" class="headerlink" title="常用方法及功能描述"></a>常用方法及功能描述</h4><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>filter</td>
<td>根据用户自定义条件过滤Stream中所有数据，符合条件的通过</td>
</tr>
<tr>
<td>map</td>
<td>使用用户自定义的功能代码应用到每一个元素，常规用于类型转换</td>
</tr>
<tr>
<td>mapToInt</td>
<td>通过用户自定义的代码将当前Stream转换为IntStream(通常是为了调用IntStream额外的接口，如<code>sum</code>)</td>
</tr>
<tr>
<td>mapToLong</td>
<td>通过用户自定义代码将当前Stream转换为LongStream</td>
</tr>
<tr>
<td>mapToDouble</td>
<td>通过用户自定义代码将当前Stream转换为DoublegStream</td>
</tr>
<tr>
<td>flatMap</td>
<td>将Stream中的多维元素降一维，如<code>Stream&lt;List&lt;City&gt;&gt;</code>转换为<code>Stream&lt;City&gt;</code></td>
</tr>
<tr>
<td>flatMapToInt</td>
<td>效果同<code>flatMap</code>，仅可用于<code>int</code>类型,如 <code>Stream&lt;int[]&gt;</code> 转换为 <code>Stream&lt;int&gt;</code></td>
</tr>
<tr>
<td>flatMapToLong</td>
<td>效果同 <code>flatMapToInt</code> ，类型限制为<code>long</code></td>
</tr>
<tr>
<td>flatMapToDouble</td>
<td>效果同<code>flatMapToInt</code>，类型限制为<code>double</code></td>
</tr>
<tr>
<td>distinct</td>
<td>对数据流进行去重，重复判定由<code>Object.equals(Object)</code>确认</td>
</tr>
<tr>
<td>sorted</td>
<td>将流中元素根据用户实现<code>Comparable</code>内容进行自然排序，若类型未实现该接口，则抛出异常<code>java.lang.ClassCastException</code></td>
</tr>
<tr>
<td>sorted(Comparator&lt;? super T&gt; comparator)</td>
<td>重载函数，根据入参的自定义规则进行自然排序</td>
</tr>
<tr>
<td>peek</td>
<td>使用用户自定义操作应用到流中每一个元素</td>
</tr>
<tr>
<td>limit</td>
<td>根据用户自定义长度，对流进行截断</td>
</tr>
<tr>
<td>skip</td>
<td>从流开头跳过用户给定长度，如果流元素数不够，则流将会被清空</td>
</tr>
<tr>
<td>forEach</td>
<td>将用户自定义操作应用到流中每一个元素</td>
</tr>
<tr>
<td>forEachOrdered</td>
<td>通常在<code>parallel stream</code>中使用，对流按照给定顺序进行元素操作</td>
</tr>
<tr>
<td>toArray</td>
<td>将流中元素组成数组返回,返回<code>Object[]</code></td>
</tr>
<tr>
<td>toArray(IntFunction&lt;A[]&gt; generator)</td>
<td>重载函数，可由用户指定数组类型，使用方式<code>toArray(String[]::new)</code></td>
</tr>
<tr>
<td>min&#x2F;max</td>
<td>根据自定义的<code>Comparator</code>实现，寻找流中最小&#x2F;最大元素</td>
</tr>
<tr>
<td>count</td>
<td>统计流中元素数量</td>
</tr>
<tr>
<td>anyMatch</td>
<td>根据用户自定义判断条件，判断流中是否有任意符合元素</td>
</tr>
<tr>
<td>allMatch</td>
<td>判断流中元素是否全部符合自定义条件</td>
</tr>
<tr>
<td>noneMatch</td>
<td>判断流中元素是否全部不符合自定义条件</td>
</tr>
<tr>
<td>findFirst</td>
<td>返回流中第一个元素,<code>parallelStream</code>中将无法保证根据给定顺序确认第一个</td>
</tr>
<tr>
<td>findAny</td>
<td>返回流中任意一个元素,<code>Stream</code>中始终返回第一个,<code>parallelStream</code>中将会任意返回</td>
</tr>
<tr>
<td>concat</td>
<td>将两个流合并为一个</td>
</tr>
</tbody></table>
<h5 id="IntStream-x2F-LongStream-x2F-DoubleStream"><a href="#IntStream-x2F-LongStream-x2F-DoubleStream" class="headerlink" title="IntStream&#x2F;LongStream&#x2F;DoubleStream"></a>IntStream&#x2F;LongStream&#x2F;DoubleStream</h5><p>相对比常规Stream，此三种流额外实现几种方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>sum</td>
<td>将流中元素求和</td>
</tr>
<tr>
<td>average</td>
<td>求平均值</td>
</tr>
<tr>
<td>min</td>
<td>最小值(无需提供<code>Comparator</code>实现)</td>
</tr>
<tr>
<td>max</td>
<td>最大值(无需提供<code>Comparator</code>实现)</td>
</tr>
<tr>
<td>summaryStatistics</td>
<td>返回统计结果，包含元素个数、总和、最大值、最小值</td>
</tr>
</tbody></table>
<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>reduce</code>操作一般是处理一组数据生成一个值，上文中提及的<code>sum</code>&#x2F;<code>min</code>&#x2F;<code>max</code>&#x2F;<code>count</code>都是<code>reduce</code>操作，因这些方法使用频繁，因此被单独设置一个方法以方便使用</p>
<h5 id="找最大值"><a href="#找最大值" class="headerlink" title="找最大值"></a>找最大值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; ints = Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">Optional&lt;Integer&gt; optional = ints.reduce((i1, i2) -&gt; i1 &gt; i2 ? i1: i2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optional.isPresent()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + optional.get());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;No result could be computed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上方代码中，<code>reduce</code>操作通过用户自定义的规则<code>(i1, i2) -&gt; i1 &gt; i2 ? i1: i2</code>对整个流中数据进行规约(reduce)，最终求得最大值</p>
<h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，入参<code>BinaryOperator&lt;T&gt; accumulator</code>是由用户提供的函数，用于对所有元素进行操作，返回值会作为新元素添加到流中加入后续的规则应用，而该接口待实现的方法入参有两个，分别代表了当前元素与下一个元素，返回值会作为下一轮的当前元素；<br>入参<code>identity</code>是由用户自定义，相当于在流的开头，人工添加一个元素，需注意的是，在<code>parallel</code>模式中，<code>identity</code>极有可能被重复使用，因此需要额外注意</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).parallel().reduce(<span class="number">9</span>, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i1=&quot;</span> + i1 + <span class="string">&quot; i2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 * <span class="number">10</span> + i2;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;reduce with identity=&quot;</span> + reduce);</span><br><span class="line"></span><br><span class="line"><span class="comment">// i1=9 i2=1</span></span><br><span class="line"><span class="comment">// i1=9 i2=2</span></span><br><span class="line"><span class="comment">// i1=9 i2=5</span></span><br><span class="line"><span class="comment">// i1=9 i2=3</span></span><br><span class="line"><span class="comment">// i1=9 i2=8</span></span><br><span class="line"><span class="comment">// i1=95 i2=93</span></span><br><span class="line"><span class="comment">// i1=92 i2=98</span></span><br><span class="line"><span class="comment">// i1=91 i2=1043</span></span><br><span class="line"><span class="comment">// i1=1018 i2=1953</span></span><br><span class="line"><span class="comment">// reduce with identity=12133</span></span><br></pre></td></tr></table></figure>
<p>入参<code>combiner</code>仅在<code>parallel</code>模式中才会生效，非<code>parallel</code>模式的流将不会执行，而<code>combiner</code>的两个入参，分别是两个<code>accumulator</code>的执行结果，并且<code>combiner</code>本身的执行结果也会加入新的<code>combiner</code>中等待执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">reduce1</span> <span class="operator">=</span> Stream.of(<span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>).parallel().reduce(<span class="number">7</span>, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i1=&quot;</span> + i1 + <span class="string">&quot; i2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 * <span class="number">10</span> + i2;</span><br><span class="line">&#125;, (i1, i2) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a1=&quot;</span> + i1 + <span class="string">&quot; a2=&quot;</span> + i2);</span><br><span class="line">    <span class="keyword">return</span> i1 * <span class="number">10</span> + i2;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;reduce with identity &amp; combiner=&quot;</span> + reduce1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// i1=7 i2=1</span></span><br><span class="line"><span class="comment">// i1=7 i2=2</span></span><br><span class="line"><span class="comment">// i1=7 i2=8</span></span><br><span class="line"><span class="comment">// i1=7 i2=5</span></span><br><span class="line"><span class="comment">// i1=7 i2=3</span></span><br><span class="line"><span class="comment">// a1=72 a2=78</span></span><br><span class="line"><span class="comment">// a1=75 a2=73</span></span><br><span class="line"><span class="comment">// a1=71 a2=823</span></span><br><span class="line"><span class="comment">// a1=798 a2=1533</span></span><br><span class="line"><span class="comment">// reduce with identity &amp; combiner=9513</span></span><br></pre></td></tr></table></figure>

<h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>大多数业务场景都涉及模型的转换，此时，<code>reduce</code>将会力不从心，而<code>collect</code>将会完美的解决这个问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; collect = Stream.of(<span class="number">2</span>, <span class="number">8</span>,